From 91f87d78f2270921668043a4802c893559332ad9 Mon Sep 17 00:00:00 2001
From: xubaikun <xubaikun@canaan-creative.com>
Date: Mon, 26 Sep 2022 19:09:48 +0800
Subject: [PATCH] extended gpio_keys driver to supports event operations

---
 drivers/input/keyboard/gpio_keys.c | 51 ++++++++++++++++++++++++------
 1 file changed, 42 insertions(+), 9 deletions(-)

diff --git a/drivers/input/keyboard/gpio_keys.c b/drivers/input/keyboard/gpio_keys.c
index 052e3767..f2898db5 100644
--- a/drivers/input/keyboard/gpio_keys.c
+++ b/drivers/input/keyboard/gpio_keys.c
@@ -543,15 +543,16 @@ static int gpio_keys_setup_key(struct platform_device *pdev,
 
 	if (bdata->gpiod) {
 		bool active_low = gpiod_is_active_low(bdata->gpiod);
-
-		if (button->debounce_interval) {
-			error = gpiod_set_debounce(bdata->gpiod,
-					button->debounce_interval * 1000);
-			/* use timer if gpiolib doesn't provide debounce */
-			if (error < 0)
-				bdata->software_debounce =
-						button->debounce_interval;
-		}
+		if (button->type == EV_KEY || button->type == EV_SW)
+		{
+			if (button->debounce_interval) {
+				error = gpiod_set_debounce(bdata->gpiod,
+						button->debounce_interval * 1000);
+				/* use timer if gpiolib doesn't provide debounce */
+				if (error < 0)
+					bdata->software_debounce =
+							button->debounce_interval;
+			}
 
 		if (button->irq) {
 			bdata->irq = button->irq;
@@ -589,6 +590,13 @@ static int gpio_keys_setup_key(struct platform_device *pdev,
 			 * not reconfigure the trigger type.
 			 */
 			break;
+			}
+		}
+		else
+		{
+			error = gpiod_direction_output(bdata->gpiod, active_low);
+			if (error < 0)
+				return error;
 		}
 	} else {
 		if (!button->irq) {
@@ -688,6 +696,30 @@ static void gpio_keys_close(struct input_dev *input)
 		pdata->disable(input->dev.parent);
 }
 
+static int gpio_keys_event(struct input_dev *input, unsigned int type, unsigned int code, int value)
+{
+	printk("gpio event, type: 0x%02x, code: 0x%02x, value: 0x%02x\n", type, code, value);
+	struct gpio_keys_drvdata *ddata = input_get_drvdata(input);
+	const struct gpio_keys_platform_data *pdata = ddata->pdata;
+	struct gpio_button_data *bdata = NULL;
+	struct gpio_keys_button *__buttons = NULL;
+	int i = 0;
+	int ret = 0;
+
+	for (i = 0; i < pdata->nbuttons; i++)
+	{
+		__buttons = pdata->buttons + i;
+		bdata = &ddata->data[i];
+		if ((__buttons->type == type) && (__buttons->code == code))
+		{
+			gpiod_set_value(bdata->gpiod, value);
+			break;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * Handlers for alternative sources of platform_data
  */
@@ -816,6 +848,7 @@ static int gpio_keys_probe(struct platform_device *pdev)
 	input->dev.parent = dev;
 	input->open = gpio_keys_open;
 	input->close = gpio_keys_close;
+	input->event = gpio_keys_event;
 
 	input->id.bustype = BUS_HOST;
 	input->id.vendor = 0x0001;
-- 
2.17.1

