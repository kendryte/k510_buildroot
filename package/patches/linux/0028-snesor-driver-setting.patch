From 5db9cbc6860c06cbcd58b9b59e5c91c8219cc9c1 Mon Sep 17 00:00:00 2001
From: alex-guo <guoshidong@canaan-creative.com>
Date: Wed, 31 Aug 2022 14:14:19 +0800
Subject: [PATCH] snesor driver setting

---
 .../media/i2c/soc_camera/canaanchip/gc2053.c  | 140 +++------
 .../media/i2c/soc_camera/canaanchip/gc2093.c  |  84 ++++--
 .../media/i2c/soc_camera/canaanchip/gc2145.c  |  75 +++--
 .../i2c/soc_camera/canaanchip/imx219_0.c      | 219 ++++++++------
 .../i2c/soc_camera/canaanchip/imx219_1.c      | 215 ++++++++-----
 .../media/i2c/soc_camera/canaanchip/imx385.c  | 284 ++++++++++--------
 6 files changed, 560 insertions(+), 457 deletions(-)

diff --git a/drivers/media/i2c/soc_camera/canaanchip/gc2053.c b/drivers/media/i2c/soc_camera/canaanchip/gc2053.c
index c939c890..78611299 100755
--- a/drivers/media/i2c/soc_camera/canaanchip/gc2053.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/gc2053.c
@@ -68,10 +68,10 @@
 #define GC2053_EXPOSURE_MIN     1
 #define GC2053_EXPOSURE_STEP    1
 
-#define GC2053_GAIN_MIN         0x40
-#define GC2053_GAIN_MAX         0x2000
+#define GC2053_GAIN_MIN         256	//0x40
+#define GC2053_GAIN_MAX         16380	//0x2000
 #define GC2053_GAIN_STEP        1
-#define GC2053_GAIN_DEFAULT     64
+#define GC2053_GAIN_DEFAULT     256	//64
 
 #define GC2053_LANES            2
 
@@ -356,6 +356,26 @@ static int gc2053_write_array(struct i2c_client *client,
 	return ret;
 }
 
+static int reg16_write(struct i2c_client *client, u8 addr, const u16 data)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	u8 tx[3];
+	int ret;
+
+	msg.addr = client->addr;
+	msg.buf = tx;
+	msg.len = 3;
+	msg.flags = 0;
+	tx[0] = addr;
+	tx[1] = data >> 8;
+	tx[2] = data & 0xff;
+	ret = i2c_transfer(adap, &msg, 1);
+	udelay(20);//mdelay(2);
+
+	return ret == 1 ? 0 : -EIO;
+}
+
 /* sensor register read */
 static int gc2053_read_reg(struct i2c_client *client, u8 reg, u8 *val)
 {
@@ -414,96 +434,6 @@ gc2053_find_best_fit(struct gc2053 *gc2053, struct v4l2_subdev_format *fmt)
 	return &supported_modes[cur_best_fit];
 }
 
-static uint8_t gain_reg_table[29][4] = {
-	{0x00, 0x00, 0x01, 0x00},
-	{0x00, 0x10, 0x01, 0x0c},
-	{0x00, 0x20, 0x01, 0x1b},
-	{0x00, 0x30, 0x01, 0x2c},
-	{0x00, 0x40, 0x01, 0x3f},
-	{0x00, 0x50, 0x02, 0x16},
-	{0x00, 0x60, 0x02, 0x35},
-	{0x00, 0x70, 0x03, 0x16},
-	{0x00, 0x80, 0x04, 0x02},
-	{0x00, 0x90, 0x04, 0x31},
-	{0x00, 0xa0, 0x05, 0x32},
-	{0x00, 0xb0, 0x06, 0x35},
-	{0x00, 0xc0, 0x08, 0x04},
-	{0x00, 0x5a, 0x09, 0x19},
-	{0x00, 0x83, 0x0b, 0x0f},
-	{0x00, 0x93, 0x0d, 0x12},
-	{0x00, 0x84, 0x10, 0x00},
-	{0x00, 0x94, 0x12, 0x3a},
-	{0x01, 0x2c, 0x1a, 0x02},
-	{0x01, 0x3c, 0x1b, 0x20},
-	{0x00, 0x8c, 0x20, 0x0f},
-	{0x00, 0x9c, 0x26, 0x07},
-	{0x02, 0x64, 0x36, 0x21},
-	{0x02, 0x74, 0x37, 0x3a},
-	{0x00, 0xc6, 0x3d, 0x02},
-	{0x00, 0xdc, 0x3f, 0x3f},
-	{0x02, 0x85, 0x3f, 0x3f},
-	{0x02, 0x95, 0x3f, 0x3f},
-	{0x00, 0xce, 0x3f, 0x3f},
-};
-
-static  uint32_t gain_level_table[30] = {
-	64,
-	76,
-	91,
-	108,
-	127,
-	150,
-	181,
-	214,
-	258,
-	305,
-	370,
-	437,
-	516,
-	601,
-	719,
-	850,
-	1024,
-	1210,
-	1538,
-	1760,
-	2063,
-	2439,
-	2881,
-	3393,
-	3970,
-	4737,
-	5572,
-	6552,
-	7713,
-	0xffffffff
-};
-
-static int gc2053_set_gain(struct gc2053 *gc2053, u32 gain)
-{
-	int ret = 0;
-	uint8_t i = 0;
-	uint8_t total = 0;
-	uint8_t temp = 0;
-
-	total = sizeof(gain_level_table) / sizeof(u32) - 1;
-	for (i = 0; i < total; i++) {
-		if ((gain_level_table[i] <= gain) && (gain < gain_level_table[i+1]))
-			break;
-	}
-
-	ret = gc2053_write_reg(gc2053->client, 0xb4, gain_reg_table[i][0]);
-	ret |= gc2053_write_reg(gc2053->client, 0xb3, gain_reg_table[i][1]);
-	ret |= gc2053_write_reg(gc2053->client, 0xb8, gain_reg_table[i][2]);
-	ret |= gc2053_write_reg(gc2053->client, 0xb9, gain_reg_table[i][3]);
-
-	temp = 64 * gain / gain_level_table[i];
-	ret |= gc2053_write_reg(gc2053->client, 0xb1, (temp >> 6));
-	ret |= gc2053_write_reg(gc2053->client, 0xb2, (temp << 2) & 0xfc);
-
-	return ret;
-}
-
 static int gc2053_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct gc2053 *gc2053 = container_of(ctrl->handler,
@@ -517,6 +447,7 @@ static int gc2053_set_ctrl(struct v4l2_ctrl *ctrl)
 	switch (ctrl->id) {
 	case V4L2_CID_VBLANK:
 		/* Update max exposure while meeting expected vblanking */
+		//max = gc2053->cur_mode->height + ctrl->val - 4;
 		max = gc2053->cur_mode->height + ctrl->val - 1;
 		__v4l2_ctrl_modify_range(gc2053->exposure,
 					 gc2053->exposure->minimum, max,
@@ -527,14 +458,19 @@ static int gc2053_set_ctrl(struct v4l2_ctrl *ctrl)
 
 	switch (ctrl->id) {
 	case V4L2_CID_EXPOSURE:
-		ret = gc2053_write_reg(gc2053->client, GC2053_REG_EXP_H,
-									(ctrl->val >> 8) & 0x3f);
-		ret |= gc2053_write_reg(gc2053->client, GC2053_REG_EXP_L,
-									ctrl->val & 0xff);
+	    ret = reg16_write(gc2053->client, GC2053_REG_EXP_H, ctrl->val);
+		// ret = gc2053_write_reg(gc2053->client, GC2053_REG_EXP_H,
+		// 			   (ctrl->val >> 8) & 0x3f);
+		//ret |= gc2053_write_reg(gc2053->client, GC2053_REG_EXP_L),
+		// 			   ctrl->val & 0xff);
 		break;
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
-		gc2053_set_gain(gc2053, ctrl->val);
+		ret = reg16_write(gc2053->client, 0xb1, ctrl->val);
+		//gain = ctrl->val;
+		//ret = gc2053_write_reg(gc2053->client, 0xb2, gain & 0xfc);
+		//ret |= gc2053_write_reg(gc2053->client, 0xb1, gain >> 8);
+
 		break;
 	case V4L2_CID_VBLANK:
 		vts = ctrl->val + gc2053->cur_mode->height;
@@ -651,8 +587,6 @@ static int gc2053_initialize_controls(struct gc2053 *gc2053)
 				V4L2_CID_GAIN, GC2053_GAIN_MIN,
 				GC2053_GAIN_MAX, GC2053_GAIN_STEP,
 				GC2053_GAIN_DEFAULT);
-
-
 	gc2053->h_flip = v4l2_ctrl_new_std(handler, &gc2053_ctrl_ops,
 				V4L2_CID_HFLIP, 0, 1, 1, 0);
 
@@ -781,7 +715,7 @@ static int __gc2053_start_stream(struct gc2053 *gc2053)
 	ret = gc2053_write_array(gc2053->client, gc2053_start);
 	if (ret)
 		return ret;
-	
+
 	return ret;
 }
 
@@ -968,7 +902,6 @@ static int gc2053_set_fmt(struct v4l2_subdev *sd,
 	fmt->format.width = mode->width;
 	fmt->format.height = mode->height;
 	fmt->format.field = V4L2_FIELD_NONE;
-
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 #ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
 		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
@@ -1169,7 +1102,7 @@ static int gc2053_probe(struct i2c_client *client,
 
 	sd->internal_ops = &gc2053_internal_ops;
 	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
-		     V4L2_SUBDEV_FL_HAS_EVENTS;
+						V4L2_SUBDEV_FL_HAS_EVENTS;
 
 	gc2053->pad.flags = MEDIA_PAD_FL_SOURCE;
 	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
@@ -1255,4 +1188,3 @@ static struct i2c_driver gc2053_i2c_driver = {
 module_i2c_driver(gc2053_i2c_driver);
 MODULE_DESCRIPTION("GC2035 CMOS Image Sensor driver");
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/media/i2c/soc_camera/canaanchip/gc2093.c b/drivers/media/i2c/soc_camera/canaanchip/gc2093.c
index d2832b73..67c2d1a6 100755
--- a/drivers/media/i2c/soc_camera/canaanchip/gc2093.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/gc2093.c
@@ -149,13 +149,13 @@ static const struct gc2093_reg gc2093_800x1080_linear_30fps_settings[] = {
 	{0x03fe, 0xf0},
 	{0x03fe, 0x00},
 	{0x03f2, 0x00},
-	{0x03f3, 0x00}, 
-	{0x03f4, 0x36}, 
+	{0x03f3, 0x00},
+	{0x03f4, 0x36},
 	{0x03f5, 0xc0},
-	{0x03f6, 0x0b}, 
-	{0x03f7, 0x11}, 
+	{0x03f6, 0x0b},
+	{0x03f7, 0x11},
 	{0x03f8, 0x58},
-	{0x03f9, 0x42}, 
+	{0x03f9, 0x42},
 	{0x03fc, 0x8e},
 	/****CISCTL & ANALOG****/
 	{0x0087, 0x18},
@@ -249,7 +249,7 @@ static const struct gc2093_reg gc2093_800x1080_linear_30fps_settings[] = {
 	{0x0193, 0x02}, //Out Window X1[11:8]
 	{0x0194, 0x2f}, //Out Window X1[7:0]
 	{0x0195, 0x04}, //Out Window Height[10:8] 1080=0438
-	{0x0196, 0x38}, //Out Window Height[7:0]  
+	{0x0196, 0x38}, //Out Window Height[7:0]
 	{0x0197, 0x03}, //Out Window Width[11:8]  1920=0780
 	{0x0198, 0x20}, //Out Window Width[7:0] 800=0320
 	/****DVP & MIPI****/
@@ -379,7 +379,7 @@ static const struct gc2093_reg gc2093_1080p_linear_30fps_settings[] = {
 	{0x0192, 0x02}, //Out Window Y1[7:0]
 	{0x0194, 0x03}, //Out Window X1[7:0]
 	{0x0195, 0x04}, //Out Window Height[10:8]
-	{0x0196, 0x38}, //Out Window Height[7:0]  
+	{0x0196, 0x38}, //Out Window Height[7:0]
 	{0x0197, 0x07}, //Out Window Width[11:8]
 	{0x0198, 0x80}, //Out Window Width[7:0]
 	/****DVP & MIPI****/
@@ -509,7 +509,7 @@ static const struct gc2093_reg gc2093_1080p_linear_60fps_settings[] = {
 	{0x0192, 0x02}, //Out Window Y1[7:0]
 	{0x0194, 0x03}, //Out Window X1[7:0]
 	{0x0195, 0x04}, //Out Window Height[10:8]
-	{0x0196, 0x38}, //Out Window Height[7:0]  
+	{0x0196, 0x38}, //Out Window Height[7:0]
 	{0x0197, 0x07}, //Out Window Width[11:8]
 	{0x0198, 0x80}, //Out Window Width[7:0]
 	/****DVP & MIPI****/
@@ -640,7 +640,7 @@ static const struct gc2093_reg gc2093_1080p_hdr_30fps_settings[] = {
 	{0x0192, 0x02}, //Out Window Y1[7:0]
 	{0x0194, 0x03}, //Out Window X1[7:0]
 	{0x0195, 0x04}, //Out Window Height[10:8]
-	{0x0196, 0x38}, //Out Window Height[7:0]  
+	{0x0196, 0x38}, //Out Window Height[7:0]
 	{0x0197, 0x07}, //Out Window Width[11:8]
 	{0x0198, 0x80}, //Out Window Width[7:0]
 	/****DVP & MIPI****/
@@ -771,6 +771,27 @@ static int gc2093_write_array(struct i2c_client *client,
 	return ret;
 }
 
+static int reg16_write(struct i2c_client *client, const u16 addr, const u16 data)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	u8 tx[4];
+	int ret;
+
+	msg.addr = client->addr;
+	msg.buf = tx;
+	msg.len = 4;
+	msg.flags = 0;
+	tx[0] = addr >> 8;
+	tx[1] = addr & 0xff;
+	tx[2] = data >> 8;
+	tx[3] = data & 0xff;
+	ret = i2c_transfer(adap, &msg, 1);
+	udelay(20);//mdelay(2);
+
+	return ret == 1 ? 0 : -EIO;
+}
+
 /* sensor register read */
 static int gc2093_read_reg(struct i2c_client *client, u16 reg, u8 *val)
 {
@@ -833,25 +854,25 @@ static const struct gain_reg_config gain_reg_configs[] = {
 static int gc2093_set_gain(struct gc2093 *gc2093, u32 gain)
 {
 	int ret, i = 0;
-	u16 pre_gain = 0;
+	//u16 pre_gain = 0;
 
-	for (i = 0; i < ARRAY_SIZE(gain_reg_configs) - 1; i++)
-		if ((gain_reg_configs[i].value <= gain) && (gain < gain_reg_configs[i+1].value))
-			break;
+	//for (i = 0; i < ARRAY_SIZE(gain_reg_configs) - 1; i++)
+	//	if ((gain_reg_configs[i].value <= gain) && (gain < gain_reg_configs[i+1].value))
+	//		break;
 
-	ret = gc2093_write_reg(gc2093->client, 0x00b4, gain_reg_configs[i].analog_gain >> 8);
-	ret |= gc2093_write_reg(gc2093->client, 0x00b3, gain_reg_configs[i].analog_gain & 0xff);
-	ret |= gc2093_write_reg(gc2093->client, 0x00b8, gain_reg_configs[i].col_gain >> 8);
-	ret |= gc2093_write_reg(gc2093->client, 0x00b9, gain_reg_configs[i].col_gain & 0xff);
-	ret |= gc2093_write_reg(gc2093->client, 0x00ce, gain_reg_configs[i].analog_sw >> 8);
-	ret |= gc2093_write_reg(gc2093->client, 0x00c2, gain_reg_configs[i].analog_sw & 0xff);
-	ret |= gc2093_write_reg(gc2093->client, 0x00cf, gain_reg_configs[i].ram_width >> 8);
-	ret |= gc2093_write_reg(gc2093->client, 0x00d9, gain_reg_configs[i].ram_width & 0xff);
+	//ret = gc2093_write_reg(gc2093->client, 0x00b4, gain_reg_configs[i].analog_gain >> 8);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00b3, gain_reg_configs[i].analog_gain & 0xff);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00b8, gain_reg_configs[i].col_gain >> 8);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00b9, gain_reg_configs[i].col_gain & 0xff);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00ce, gain_reg_configs[i].analog_sw >> 8);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00c2, gain_reg_configs[i].analog_sw & 0xff);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00cf, gain_reg_configs[i].ram_width >> 8);
+	//ret |= gc2093_write_reg(gc2093->client, 0x00d9, gain_reg_configs[i].ram_width & 0xff);
 
-	pre_gain = 64 * gain / gain_reg_configs[i].value;
+	//pre_gain = 64 * gain / gain_reg_configs[i].value;
 
-	ret |= gc2093_write_reg(gc2093->client, 0x00b1, (pre_gain >> 6));
-	ret |= gc2093_write_reg(gc2093->client, 0x00b2, ((pre_gain & 0x3f) << 2));
+	ret |= gc2093_write_reg(gc2093->client, 0x00b1, (gain >> 8));
+	ret |= gc2093_write_reg(gc2093->client, 0x00b2, (gain & 0xfc));
 
 	return ret;
 }
@@ -878,14 +899,16 @@ static int gc2093_set_ctrl(struct v4l2_ctrl *ctrl)
 
 	switch (ctrl->id) {
 	case V4L2_CID_EXPOSURE:
-		ret = gc2093_write_reg(gc2093->client, GC2093_REG_EXP_LONG_H,
-				       (ctrl->val >> 8) & 0x3f);
-		ret |= gc2093_write_reg(gc2093->client, GC2093_REG_EXP_LONG_L,
-					ctrl->val & 0xff);
+		//ret = gc2093_write_reg(gc2093->client, GC2093_REG_EXP_LONG_H,
+		//		       (ctrl->val >> 8) & 0x3f);
+		//ret |= gc2093_write_reg(gc2093->client, GC2093_REG_EXP_LONG_L,
+		//			ctrl->val & 0xff);
+		ret = reg16_write(gc2093->client,  GC2093_REG_EXP_LONG_H, ctrl->val);
 		break;
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
-		gc2093_set_gain(gc2093, ctrl->val);
+		//gc2093_set_gain(gc2093, ctrl->val);
+		ret = reg16_write(gc2093->client, 0x00b1, ctrl->val);
 		break;
 	case V4L2_CID_VBLANK:
 		/* The exposure goes up and reduces the frame rate, no need to write vb */
@@ -1124,7 +1147,7 @@ static long gc2093_compat_ioctl32(struct v4l2_subdev *sd,
 
 static int gc2093_s_stream(struct v4l2_subdev *sd, int on)
 {
-	struct gc2093 *gc2093 = to_gc2093(sd);	
+	struct gc2093 *gc2093 = to_gc2093(sd);
 	int ret = 0;
 
 	mutex_lock(&gc2093->lock);
@@ -1519,4 +1542,3 @@ static struct i2c_driver gc2093_i2c_driver = {
 module_i2c_driver(gc2093_i2c_driver);
 MODULE_DESCRIPTION("Galaxycore GC2093 Image Sensor driver");
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/media/i2c/soc_camera/canaanchip/gc2145.c b/drivers/media/i2c/soc_camera/canaanchip/gc2145.c
index a1b23d35..93dc2a1c 100755
--- a/drivers/media/i2c/soc_camera/canaanchip/gc2145.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/gc2145.c
@@ -65,6 +65,8 @@
 
 #define REG_NULL			0xFF
 
+#define GC2145219_EXP_LINES_MARGIN 1
+
 #define to_gc2145(sd) container_of(sd, struct gc2145, subdev)
 
 enum {
@@ -166,8 +168,8 @@ static const struct gc2145_reg gc2145_1600x1200_mipi_raw10_settings[] = {
 
 	/*** Analog & Cisctl ***/
 	{0xfe,0x00},
-	{0x03,0x04},//Exposure[12:8] 
-	{0x04,0xe2},//Exposure[7:0] 
+	{0x03,0x04},//Exposure[12:8]
+	{0x04,0xe2},//Exposure[7:0]
 	{0x05,0x01},//hb[11:8]
 	{0x06,0x56},//hb[7:0]
 	{0x07,0x00},//vb[12:8]
@@ -215,7 +217,8 @@ static const struct gc2145_reg gc2145_1600x1200_mipi_raw10_settings[] = {
 	{0x85,0x30},
 	{0x8a,0x00},
 	{0x8b,0x00},
-	{0xb0,0x55},
+	{0xb0,0x10},
+	{0xb1,0x10},
 	{0xc3,0x00},
 	{0xc4,0x80},
 	{0xc5,0x90},
@@ -253,13 +256,13 @@ static const struct gc2145_reg gc2145_1600x1200_mipi_raw10_settings[] = {
 	{0x68,0x20},
 	{0x69,0x20},
 	{0x76,0x00},
-	{0x6a,0x08}, 
-	{0x6b,0x08}, 
-	{0x6c,0x08}, 
-	{0x6d,0x08}, 
-	{0x6e,0x08}, 
-	{0x6f,0x08}, 
-	{0x70,0x08}, 
+	{0x6a,0x08},
+	{0x6b,0x08},
+	{0x6c,0x08},
+	{0x6d,0x08},
+	{0x6e,0x08},
+	{0x6f,0x08},
+	{0x70,0x08},
 	{0x71,0x08},
 	{0x76,0x00},
 	{0x72,0xf0},
@@ -273,7 +276,7 @@ static const struct gc2145_reg gc2145_1600x1200_mipi_raw10_settings[] = {
 
 	/*** dark sun ***/
 	{0xfe,0x00},
-	{0x18,0x22}, 
+	{0x18,0x22},
 	{0xfe,0x02},
 	{0x40,0xbf},
 	{0x46,0xcf},
@@ -360,7 +363,8 @@ static const struct gc2145_reg gc2145_1280x960_mipi_raw10_settings[] = {
 	{0x85, 0x30},
 	{0x8a, 0x00},
 	{0x8b, 0x00},
-	{0xb0, 0x55},
+	{0xb0, 0x10},
+	{0xb1, 0x10},
 	{0xc3, 0x00},
 	{0xc4, 0x80},
 	{0xc5, 0x90},
@@ -378,7 +382,7 @@ static const struct gc2145_reg gc2145_1280x960_mipi_raw10_settings[] = {
 	{0x94, 0x01},//out_win_x1[7:0]
 	{0x95, 0x03},//out_win_height[10:8]
 	{0x96, 0xc0},//out_win_height[7:0] //960
-	{0x97, 0x05},//out_win_width[10:8] 
+	{0x97, 0x05},//out_win_width[10:8]
 	{0x98, 0x00},//out_win_width[7:0] //1280
 
 	/*** BLK ***/
@@ -402,9 +406,9 @@ static const struct gc2145_reg gc2145_1280x960_mipi_raw10_settings[] = {
 	{0x6b, 0x08},
 	{0x6c, 0x08},
 	{0x6d, 0x08},
-	{0x6e, 0x08}, 
+	{0x6e, 0x08},
 	{0x6f, 0x08},
-	{0x70, 0x08}, 
+	{0x70, 0x08},
 	{0x71, 0x08},
 	{0x76, 0x00},
 	{0x72, 0xf0},
@@ -464,7 +468,7 @@ static const struct gc2145_mode supported_modes[] = {
 		},
 		.exp_def = 0x460,
 		.hts_def = 0x780,
-		.vts_def = 0x4e2,		
+		.vts_def = 0x4e2,
 		.link_freq_index = LINK_FREQ_240M_INDEX,
 		.reg_list = gc2145_1600x1200_mipi_raw10_settings,
 	},
@@ -523,6 +527,26 @@ static int gc2145_write_array(struct i2c_client *client,
 	return ret;
 }
 
+static int reg16_write(struct i2c_client *client, u8 addr, const u16 data)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	u8 tx[3];
+	int ret;
+
+	msg.addr = client->addr;
+	msg.buf = tx;
+	msg.len = 3;
+	msg.flags = 0;
+	tx[0] = addr;
+	tx[1] = data >> 8;
+	tx[2] = data & 0xff;
+	ret = i2c_transfer(adap, &msg, 1);
+	udelay(20);//mdelay(2);
+
+	return ret == 1 ? 0 : -EIO;
+}
+
 /* sensor register read */
 static int gc2145_read_reg(struct i2c_client *client, u8 reg, u8 *val)
 {
@@ -584,7 +608,9 @@ static const struct gain_reg_config gain_reg_configs[] = {
 
 static int gc2145_set_gain(struct gc2145 *gc2145, u32 gain)
 {
-	return 0;
+	int ret = 0;
+	ret = gc2145_write_reg(gc2145->client, 0xb1, gain >> 4);
+	return ret;
 }
 
 static int gc2145_set_ctrl(struct v4l2_ctrl *ctrl)
@@ -593,13 +619,14 @@ static int gc2145_set_ctrl(struct v4l2_ctrl *ctrl)
 					     struct gc2145, ctrl_handler);
 	s64 max;
 	int ret = 0;
+
 	dev_dbg(&gc2145->client->dev, "%s enter, id:0x%X val:%d.\n", __func__, ctrl->id, ctrl->val);
 
 	/* Propagate change of current control to all related controls */
 	switch (ctrl->id) {
 	case V4L2_CID_VBLANK:
 		/* Update max exposure while meeting expected vblanking */
-		max = gc2145->cur_mode->height + ctrl->val - 1;
+		max = gc2145->cur_mode->height + ctrl->val - GC2145219_EXP_LINES_MARGIN;
 		__v4l2_ctrl_modify_range(gc2145->exposure,
 					 gc2145->exposure->minimum, max,
 					 gc2145->exposure->step,
@@ -609,10 +636,11 @@ static int gc2145_set_ctrl(struct v4l2_ctrl *ctrl)
 
 	switch (ctrl->id) {
 	case V4L2_CID_EXPOSURE:
+	    ret = reg16_write(gc2145->client,  GC2145_REG_EXP_LONG_H, ctrl->val);
 		break;
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
-		gc2145_set_gain(gc2145, ctrl->val);
+		ret = gc2145_write_reg(gc2145->client,  0xb1, (ctrl->val +256)>>4);
 		break;
 	case V4L2_CID_VBLANK:
 		/* The exposure goes up and reduces the frame rate, no need to write vb */
@@ -669,7 +697,7 @@ static int gc2145_initialize_controls(struct gc2145 *gc2145)
 					   GC2145_VTS_MAX - mode->height,
 					   1, vblank_def);
 
-	exposure_max = mode->vts_def - 1;
+	exposure_max = mode->vts_def - GC2145219_EXP_LINES_MARGIN;
 	gc2145->exposure = v4l2_ctrl_new_std(handler, &gc2145_ctrl_ops,
 					     V4L2_CID_EXPOSURE, GC2145_EXPOSURE_MIN,
 					     exposure_max, GC2145_EXPOSURE_STEP,
@@ -721,7 +749,7 @@ static int __gc2145_power_on(struct gc2145 *gc2145)
 	if (!IS_ERR(gc2145->pwdn_gpio)) {
 		gpiod_set_value_cansleep(gc2145->pwdn_gpio, 0);//exit powerdown mode
 		usleep_range(500, 800);
-	}
+    }
 
 	if (!IS_ERR(gc2145->reset_gpio)) {
 		gpiod_set_value_cansleep(gc2145->reset_gpio, 0);//exit reset mode
@@ -730,7 +758,7 @@ static int __gc2145_power_on(struct gc2145 *gc2145)
 	if (!IS_ERR(gc2145->reset_gpio)) {
 		gpiod_set_value_cansleep(gc2145->reset_gpio, 1);//enter reset mode
 		usleep_range(3000, 6000);
-	}
+    }
 
 	if (!IS_ERR(gc2145->reset_gpio))
 		gpiod_set_value_cansleep(gc2145->reset_gpio, 0);//exit reset mode
@@ -866,7 +894,7 @@ static long gc2145_compat_ioctl32(struct v4l2_subdev *sd,
 
 static int gc2145_s_stream(struct v4l2_subdev *sd, int on)
 {
-	struct gc2145 *gc2145 = to_gc2145(sd);	
+	struct gc2145 *gc2145 = to_gc2145(sd);
 	int ret = 0;
 	dev_info(&gc2145->client->dev, "%s enter\n",__func__);
 
@@ -1261,4 +1289,3 @@ static struct i2c_driver gc2145_i2c_driver = {
 module_i2c_driver(gc2145_i2c_driver);
 MODULE_DESCRIPTION("Galaxycore GC2145 Image Sensor driver");
 MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/media/i2c/soc_camera/canaanchip/imx219_0.c b/drivers/media/i2c/soc_camera/canaanchip/imx219_0.c
index c8002b24..32062927 100644
--- a/drivers/media/i2c/soc_camera/canaanchip/imx219_0.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/imx219_0.c
@@ -188,35 +188,35 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	{0x012a, 0x18}, //REG_EXCK_FREQ_MSB
 	{0x012b, 0x00}, //REG_EXCK_FREQ_LSB
 	//
-	//{0x0154,0x00},// FRAME_DURATION_A 
-	//{0x0155,0x00},// COMP_ENABLE_A 
+	//{0x0154,0x00},// FRAME_DURATION_A
+	//{0x0155,0x00},// COMP_ENABLE_A
 	//{0x0157,0x20},// ANA_GAIN_GLOBAL_A
 	//{0x0158,0x00},// DIG_GAIN_GLOBAL_A [11:8]
-	//{0x0159,0x20},// DIG_GAIN_GLOBAL_A [7:0] 
+	//{0x0159,0x20},// DIG_GAIN_GLOBAL_A [7:0]
 	//
 	//{0x015A,0x00},// COARSE_INTEGRATION_TIME_A[15:8]
 	//{0x015B,0x02},// COARSE_INTEGRATION_TIME_A[7:0]
 	//{0x015D,0x00},// SENSOR_MODE_A XX 0x025D SENSOR_MODE_B X
 	//
 	{0x0160, 0x04},//FRM_LENGTH_A[15:8] 1166
-	{0x0161, 0x8e},//FRM_LENGTH_A[7:0] 1166     
+	{0x0161, 0x8e},//FRM_LENGTH_A[7:0] 1166
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 3448
 	{0x0163, 0x94},//0x78},//LINE_LENGTH_A[7:0]
-	// 
-	{0x0164, 0x02}, //X_ADD_STA_A[11:8] 
-	{0x0165, 0xa8},//X_ADD_STA_A[7:0] 
-	{0x0166, 0x0a}, //X_ADD_END_A[11:8] 
-	{0x0167, 0x27}, //X_ADD_END_A[7:0] 
 	//
-	{0x0168, 0x02},//Y_ADD_STA_A[11:8] 
-	{0x0169, 0xb4},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x06},//Y_ADD_END_A[11:8] 
-	{0x016b, 0xeb},//Y_ADD_END_A[7:0] 
+	{0x0164, 0x02}, //X_ADD_STA_A[11:8]
+	{0x0165, 0xa8},//X_ADD_STA_A[7:0]
+	{0x0166, 0x0a}, //X_ADD_END_A[11:8]
+	{0x0167, 0x27}, //X_ADD_END_A[7:0]
 	//
-	{0x016c, 0x07},//x_output_size[11:8] 
+	{0x0168, 0x02},//Y_ADD_STA_A[11:8]
+	{0x0169, 0xb4},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x06},//Y_ADD_END_A[11:8]
+	{0x016b, 0xeb},//Y_ADD_END_A[7:0]
+	//
+	{0x016c, 0x07},//x_output_size[11:8]
 	{0x016d, 0x80},//x_output_size[7:0]
-	{0x016e, 0x04},//y_output_size[11:8] 
-	{0x016f, 0x38},// y_output_size[7:0] 
+	{0x016e, 0x04},//y_output_size[11:8]
+	{0x016f, 0x38},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -229,29 +229,29 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	//{0x0177, 0x00},//BINNING_CAL_MODE_V_A
 	//
 	//{0x0189,0x00},//ANA_GAIN_GLOBAL_SHORT_A
-	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A 
+	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A
 	//{0x018B,0x00},//COARSE_INTEG_TIME_SHORT_A
-	// 
+	//
 	//{0x018C,0x00},//CSI_DATA_FORMAT_A [15:8]
-	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]	
+	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]
 	//LSC
 	//{0x0190,0x00},//LSC_ENABLE_A
 	//{0x0191,0x00},//LSC_COLOR_MODE_A
-	//{0x0192,0x00},//LSC_SELECT_TABLE_A 
+	//{0x0192,0x00},//LSC_SELECT_TABLE_A
 	//{0x0193,0x00},//LSC_TUNING_ENABLE_A
 	//{0x0194,0x00},//LSC_WHITE_BALANCE_RG_A[15:8]
 	//{0x0195,0x00},//LSC_WHITE_BALANCE_RG_A[7:0]
 	//{0x0198,0x00), //LSC_TUNING_COEF_R_A
-	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A 
-	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A 
+	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A
+	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A
 	//{0x019B,0x00), //LSC_TUNING_COEF_B_A
-	//{0x019C,0x00), //LSC_TUNING_R_A[12:8] 
+	//{0x019C,0x00), //LSC_TUNING_R_A[12:8]
 	//{0x019D,0x00), //LSC_TUNING_R_A[7:0]
 	//{0x019E,0x00), //LSC_TUNING_GR_A[12:8]
-	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0] 
+	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0]
 	//{0x01A0,0x00), //LSC_TUNING_GB_A[12:8]
-	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0] 
-	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8] 
+	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0]
+	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8]
 	//{0x01A3,0x00), //LSC_TUNING_B_A[7:0]
 	//{0x01A4,0x00), //LSC_KNOT_POINT_FORMAT_A
 	//
@@ -268,7 +268,7 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x30},//PLL_OP_MPY[7:0] 0x72
 	//
 	{0x0624, 0x07},
@@ -308,26 +308,26 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	{0x012a, 0x18}, //REG_EXCK_FREQ_MSB
 	{0x012b, 0x00}, //REG_EXCK_FREQ_LSB
 
-	{0x0160, 0x07},//FRM_LENGTH_A[15:8] 1979
-	{0x0161, 0xbb},//FRM_LENGTH_A[7:0] 1979     
+	{0x0160, 0x07},//FRM_LENGTH_A[15:8] 1977
+	{0x0161, 0xb9},//FRM_LENGTH_A[7:0] 1977
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 3453
 	{0x0163, 0x7d},//0x78},//LINE_LENGTH_A[7:0]
 
 	{0x0164, 0x04}, //X_ADD_STA_A[11:8]
-	{0x0165, 0x4c},//X_ADD_STA_A[7:0] 
+	{0x0165, 0x4c},//X_ADD_STA_A[7:0]
 	{0x0166, 0x08}, //X_ADD_END_A[11:8]
-	{0x0167, 0x83}, //X_ADD_END_A[7:0] 
-	
+	{0x0167, 0x83}, //X_ADD_END_A[7:0]
+
 	//
-	{0x0168, 0x01},//Y_ADD_STA_A[11:8] 
-	{0x0169, 0x10},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x08},//Y_ADD_END_A[11:8]  		2175	
-	{0x016b, 0x8f},//Y_ADD_END_A[7:0] 
+	{0x0168, 0x01},//Y_ADD_STA_A[11:8]
+	{0x0169, 0x10},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x08},//Y_ADD_END_A[11:8]  		2175
+	{0x016b, 0x8f},//Y_ADD_END_A[7:0]
 	//
-	{0x016c, 0x04},//x_output_size[11:8] 
+	{0x016c, 0x04},//x_output_size[11:8]
 	{0x016d, 0x38},//x_output_size[7:0]
-	{0x016e, 0x07},//y_output_size[11:8] 
-	{0x016f, 0x80},// y_output_size[7:0] 
+	{0x016e, 0x07},//y_output_size[11:8]
+	{0x016f, 0x80},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -340,29 +340,29 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	//{0x0177, 0x00},//BINNING_CAL_MODE_V_A
 	//
 	//{0x0189,0x00},//ANA_GAIN_GLOBAL_SHORT_A
-	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A 
+	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A
 	//{0x018B,0x00},//COARSE_INTEG_TIME_SHORT_A
-	// 
+	//
 	//{0x018C,0x00},//CSI_DATA_FORMAT_A [15:8]
-	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]	
+	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]
 	//LSC
 	//{0x0190,0x00},//LSC_ENABLE_A
 	//{0x0191,0x00},//LSC_COLOR_MODE_A
-	//{0x0192,0x00},//LSC_SELECT_TABLE_A 
+	//{0x0192,0x00},//LSC_SELECT_TABLE_A
 	//{0x0193,0x00},//LSC_TUNING_ENABLE_A
 	//{0x0194,0x00},//LSC_WHITE_BALANCE_RG_A[15:8]
 	//{0x0195,0x00},//LSC_WHITE_BALANCE_RG_A[7:0]
 	//{0x0198,0x00), //LSC_TUNING_COEF_R_A
-	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A 
-	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A 
+	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A
+	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A
 	//{0x019B,0x00), //LSC_TUNING_COEF_B_A
-	//{0x019C,0x00), //LSC_TUNING_R_A[12:8] 
+	//{0x019C,0x00), //LSC_TUNING_R_A[12:8]
 	//{0x019D,0x00), //LSC_TUNING_R_A[7:0]
 	//{0x019E,0x00), //LSC_TUNING_GR_A[12:8]
-	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0] 
+	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0]
 	//{0x01A0,0x00), //LSC_TUNING_GB_A[12:8]
-	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0] 
-	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8] 
+	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0]
+	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8]
 	//{0x01A3,0x00), //LSC_TUNING_B_A[7:0]
 	//{0x01A4,0x00), //LSC_KNOT_POINT_FORMAT_A
 	//
@@ -380,7 +380,7 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x2c},//PLL_OP_MPY[7:0] 0x72  0x56  0x51  0x40
 	//
 	{0x0624, 0x07},
@@ -402,7 +402,7 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	{0x0157, 0x00},
 	{0x015a, 0x03},
 	{0x015b, 0xe8},
-	{IMX219_TABLE_END, 0x00}	
+	{IMX219_TABLE_END, 0x00}
 };
 
 
@@ -439,7 +439,7 @@ static const struct imx219_reg imx219_init_tab_1280_720_60fps[] = {
 	{0x016c, 0x05},//x_output_size[11:8] 				1280
 	{0x016d, 0x00},//x_output_size[7:0]
 	{0x016e, 0x02},//y_output_size[11:8] 				720
-	{0x016f, 0xd0},// y_output_size[7:0] 
+	{0x016f, 0xd0},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -462,7 +462,7 @@ static const struct imx219_reg imx219_init_tab_1280_720_60fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x55},//PLL_OP_MPY[7:0] 0x36
 
 	//{0x0157, 0x64},//analog gain
@@ -513,18 +513,18 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	{0x0161, 0xcc},//FRM_LENGTH_A[7:0] 0x96  0xca  0x8e     0x4a
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 			line 3476
 	{0x0163, 0x94},//0x78},//LINE_LENGTH_A[7:0]
-	// 
+	//
 #if 0
 
 	{0x0164, 0x02}, //X_ADD_STA_A[11:8] 				   1279
-	{0x0165, 0xa8},//X_ADD_STA_A[7:0] 
-	{0x0166, 0x04}, //X_ADD_END_A[11:8] 
-	{0x0167, 0xff}, //X_ADD_END_A[7:0] 
+	{0x0165, 0xa8},//X_ADD_STA_A[7:0]
+	{0x0166, 0x04}, //X_ADD_END_A[11:8]
+	{0x0167, 0xff}, //X_ADD_END_A[7:0]
 
 	{0x0168, 0x02},//Y_ADD_STA_A[11:8] 						719
-	{0x0169, 0xb4},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x05},//Y_ADD_END_A[11:8] 
-	{0x016b, 0x77},//Y_ADD_END_A[7:0] 
+	{0x0169, 0xb4},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x05},//Y_ADD_END_A[11:8]
+	{0x016b, 0x77},//Y_ADD_END_A[7:0]
 #else
 	{0x0164, 0x05}, //X_ADD_STA_A[11:8] 	0x04
 	{0x0165, 0x28},//X_ADD_STA_A[7:0] 		0x4a
@@ -542,7 +542,7 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	{0x016c, 0x02},//x_output_size[11:8] 				640
 	{0x016d, 0x80},//x_output_size[7:0]
 	{0x016e, 0x01},//y_output_size[11:8] 				480
-	{0x016f, 0xe0},// y_output_size[7:0] 
+	{0x016f, 0xe0},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -565,7 +565,7 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x55},//PLL_OP_MPY[7:0] 0x36
 
 	//{0x0157, 0x64},//analog gain
@@ -690,7 +690,7 @@ static const struct imx219_mode supported_modes[] = {
 			.denominator = 300000,
 		},
 		.hts_def = 0x0d7d - IMX219_EXP_LINES_MARGIN,
-		.vts_def = 0x07bb,
+		.vts_def = 0x07b9,
 		.reg_list = imx219_init_tab_1080_1920_30fps,
 	},
 	{
@@ -761,7 +761,7 @@ static int reg_write(struct i2c_client *client, const u16 addr, const u8 data)
 	tx[1] = addr & 0xff;
 	tx[2] = data;
 	ret = i2c_transfer(adap, &msg, 1);
-	mdelay(2);
+	udelay(20); //mdelay(2);
 
 	return ret == 1 ? 0 : -EIO;
 }
@@ -782,7 +782,7 @@ static int reg16_write(struct i2c_client *client, const u16 addr, const u16 data
 	tx[2] = data >> 8;
 	tx[3] = data & 0xff;
 	ret = i2c_transfer(adap, &msg, 1);
-	mdelay(2);
+	udelay(20); //mdelay(2);
 
 	return ret == 1 ? 0 : -EIO;
 }
@@ -855,14 +855,14 @@ static int imx219_s_stream(struct v4l2_subdev *sd, int enable)
 	{
 		dev_err(&client->dev,"%s:enable(%d)\n",__func__,enable);
 		return reg_write_table(client, stop);
-	}	
+	}
 
 	ret = reg_write_table(client, priv->cur_mode->reg_list);
 	if (ret)
 	{
 		dev_err(&client->dev,"%s:reg_write_table failed,ret(%d)\n",__func__,ret);
 		return ret;
-	}	
+	}
 	//
 	//reg_read_table(client, priv->cur_mode->reg_list);
 	/* Handle crop */
@@ -886,17 +886,17 @@ static int imx219_s_stream(struct v4l2_subdev *sd, int enable)
 	}
 
 	/* Handle flip/mirror */
-	if (priv->hflip)
-		reg |= 0x1;
-	if (priv->vflip)
-		reg |= 0x2;
-
-	ret = reg_write(client, 0x0172, reg);
-	if (ret)
-	{
-		dev_err(&client->dev,"%s:reg(0x0172) failed,ret(%d)\n",__func__,ret);
-		return ret;
-	}
+	// if (priv->hflip)
+	// 	reg |= 0x1;
+	// if (priv->vflip)
+	// 	reg |= 0x2;
+
+	// ret = reg_write(client, 0x0172, reg);
+	// if (ret)
+	// {
+	// 	dev_err(&client->dev,"%s:reg(0x0172) failed,ret(%d)\n",__func__,ret);
+	// 	return ret;
+	// }
 	/* Handle test pattern */
 	if (priv->test_pattern) {
 		ret = reg_write(client, 0x0600, priv->test_pattern >> 8);
@@ -1046,6 +1046,36 @@ static int imx219_g_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static const struct imx219_reg imx219_vflip_table_1920Wx1080H[2][2] =
+{
+	/* 1920Wx1080H */
+	{
+		/* 0 */
+		{0x0169, 0xb4},
+		{0x016b, 0xeb},
+	},
+	{
+		/* 1 */
+		{0x0169, 0xb3},
+		{0x016b, 0xea},
+	},
+};
+
+static const struct imx219_reg imx219_vflip_table_1080Wx1920H[2][2] =
+{
+	/* 1080Wx1920H */
+	{
+		/* 0 */
+		{0x0169, 0x10},
+		{0x016b, 0x8f},
+	},
+	{
+		/* 1 */
+		{0x0169, 0x11},
+		{0x016b, 0x90},
+	},
+};
+
 static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx219 *priv =
@@ -1056,18 +1086,37 @@ static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 	u32 gain = 256; //u16 gain = 256;
 	u8 a_gain = 255; //u16 a_gain = 256;
 	u16 d_gain = 1;
-
+	u8 mf;
+	u16 mflip;
 	dev_dbg(&client->dev,"%s:ctrl->id(0x%x),ctrl->val(%d)\n",__func__,ctrl->id,ctrl->val);
 
 	switch (ctrl->id) {
 	case V4L2_CID_HFLIP:
 		priv->hflip = ctrl->val;
-		break;
+		return 0;
 
 	case V4L2_CID_VFLIP:
 		priv->vflip = ctrl->val;
-		break;
-
+		mf = ctrl->val << 1;
+		ret = reg_write(client, 0x0172, mf);
+		mflip = ((reg_read(client, 0x016c) & 0xf) << 8) + (reg_read(client, 0x016d) & 0xff);
+		if(mflip == 1920)
+		{
+			reg_write(client, 0x0169, imx219_vflip_table_1920Wx1080H[ctrl->val][0].val);
+			reg_write(client, 0x016b, imx219_vflip_table_1920Wx1080H[ctrl->val][1].val);
+			return 0;
+		}
+		else if(mflip == 1080)
+		{
+			reg_write(client, 0x0169, imx219_vflip_table_1080Wx1920H[ctrl->val][0].val);
+			reg_write(client, 0x016b, imx219_vflip_table_1080Wx1920H[ctrl->val][1].val);
+			return 0;
+		}
+		else
+		{
+			return 0;
+		}
+		return 0;
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
 		/*
@@ -1080,7 +1129,7 @@ static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 			gain = 256;
 		if (gain > 43663)
 			gain = 43663;
-			
+
 		/*
 		 * Analog gain, reg range[0, 232], gain value[1, 10.66]
 		 * reg = 256 - 256 / again
@@ -1099,7 +1148,7 @@ static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 			{
 				a_gain = 255 - 65536 / gain; 	//256 - 65536 / gain -1;
 			}
-		
+
 		priv->analogue_gain = a_gain;
 
 		/*
@@ -1199,7 +1248,7 @@ static int imx219_set_fmt(struct v4l2_subdev *sd,
 	const struct imx219_mode *mode;
 	s64 h_blank, v_blank, pixel_rate;
 	u32 fps = 0;
-	
+
 	dev_info(&client->dev,"%s:start\n",__func__);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		return 0;
diff --git a/drivers/media/i2c/soc_camera/canaanchip/imx219_1.c b/drivers/media/i2c/soc_camera/canaanchip/imx219_1.c
index d30c8a51..ce0e31de 100644
--- a/drivers/media/i2c/soc_camera/canaanchip/imx219_1.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/imx219_1.c
@@ -187,35 +187,35 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	{0x012a, 0x18}, //REG_EXCK_FREQ_MSB
 	{0x012b, 0x00}, //REG_EXCK_FREQ_LSB
 	//
-	//{0x0154,0x00},// FRAME_DURATION_A 
-	//{0x0155,0x00},// COMP_ENABLE_A 
+	//{0x0154,0x00},// FRAME_DURATION_A
+	//{0x0155,0x00},// COMP_ENABLE_A
 	//{0x0157,0x20},// ANA_GAIN_GLOBAL_A
 	//{0x0158,0x00},// DIG_GAIN_GLOBAL_A [11:8]
-	//{0x0159,0x20},// DIG_GAIN_GLOBAL_A [7:0] 
+	//{0x0159,0x20},// DIG_GAIN_GLOBAL_A [7:0]
 	//
 	//{0x015A,0x00},// COARSE_INTEGRATION_TIME_A[15:8]
 	//{0x015B,0x02},// COARSE_INTEGRATION_TIME_A[7:0]
 	//{0x015D,0x00},// SENSOR_MODE_A XX 0x025D SENSOR_MODE_B X
 	//
 	{0x0160, 0x04},//FRM_LENGTH_A[15:8] 1166
-	{0x0161, 0x8e},//FRM_LENGTH_A[7:0] 1166     
+	{0x0161, 0x8e},//FRM_LENGTH_A[7:0] 1166
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 3448
 	{0x0163, 0x94},//0x78},//LINE_LENGTH_A[7:0]
-	// 
-	{0x0164, 0x02}, //X_ADD_STA_A[11:8] 
-	{0x0165, 0xa8},//X_ADD_STA_A[7:0] 
-	{0x0166, 0x0a}, //X_ADD_END_A[11:8] 
-	{0x0167, 0x27}, //X_ADD_END_A[7:0] 
 	//
-	{0x0168, 0x02},//Y_ADD_STA_A[11:8] 
-	{0x0169, 0xb4},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x06},//Y_ADD_END_A[11:8] 
-	{0x016b, 0xeb},//Y_ADD_END_A[7:0] 
+	{0x0164, 0x02}, //X_ADD_STA_A[11:8]
+	{0x0165, 0xa8},//X_ADD_STA_A[7:0]
+	{0x0166, 0x0a}, //X_ADD_END_A[11:8]
+	{0x0167, 0x27}, //X_ADD_END_A[7:0]
 	//
-	{0x016c, 0x07},//x_output_size[11:8] 
+	{0x0168, 0x02},//Y_ADD_STA_A[11:8]
+	{0x0169, 0xb4},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x06},//Y_ADD_END_A[11:8]
+	{0x016b, 0xeb},//Y_ADD_END_A[7:0]
+	//
+	{0x016c, 0x07},//x_output_size[11:8]
 	{0x016d, 0x80},//x_output_size[7:0]
-	{0x016e, 0x04},//y_output_size[11:8] 
-	{0x016f, 0x38},// y_output_size[7:0] 
+	{0x016e, 0x04},//y_output_size[11:8]
+	{0x016f, 0x38},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -228,29 +228,29 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	//{0x0177, 0x00},//BINNING_CAL_MODE_V_A
 	//
 	//{0x0189,0x00},//ANA_GAIN_GLOBAL_SHORT_A
-	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A 
+	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A
 	//{0x018B,0x00},//COARSE_INTEG_TIME_SHORT_A
-	// 
+	//
 	//{0x018C,0x00},//CSI_DATA_FORMAT_A [15:8]
-	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]	
+	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]
 	//LSC
 	//{0x0190,0x00},//LSC_ENABLE_A
 	//{0x0191,0x00},//LSC_COLOR_MODE_A
-	//{0x0192,0x00},//LSC_SELECT_TABLE_A 
+	//{0x0192,0x00},//LSC_SELECT_TABLE_A
 	//{0x0193,0x00},//LSC_TUNING_ENABLE_A
 	//{0x0194,0x00},//LSC_WHITE_BALANCE_RG_A[15:8]
 	//{0x0195,0x00},//LSC_WHITE_BALANCE_RG_A[7:0]
 	//{0x0198,0x00), //LSC_TUNING_COEF_R_A
-	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A 
-	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A 
+	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A
+	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A
 	//{0x019B,0x00), //LSC_TUNING_COEF_B_A
-	//{0x019C,0x00), //LSC_TUNING_R_A[12:8] 
+	//{0x019C,0x00), //LSC_TUNING_R_A[12:8]
 	//{0x019D,0x00), //LSC_TUNING_R_A[7:0]
 	//{0x019E,0x00), //LSC_TUNING_GR_A[12:8]
-	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0] 
+	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0]
 	//{0x01A0,0x00), //LSC_TUNING_GB_A[12:8]
-	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0] 
-	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8] 
+	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0]
+	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8]
 	//{0x01A3,0x00), //LSC_TUNING_B_A[7:0]
 	//{0x01A4,0x00), //LSC_KNOT_POINT_FORMAT_A
 	//
@@ -267,7 +267,7 @@ static const struct imx219_reg imx219_init_tab_1920_1080_30fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x30},//PLL_OP_MPY[7:0] 0x72
 	{0x0624, 0x07},
 	{0x0625, 0x80},
@@ -305,26 +305,26 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	{0x012a, 0x18}, //REG_EXCK_FREQ_MSB
 	{0x012b, 0x00}, //REG_EXCK_FREQ_LSB
 
-	{0x0160, 0x07},//FRM_LENGTH_A[15:8] 1979
-	{0x0161, 0xbb},//FRM_LENGTH_A[7:0] 1979     
+	{0x0160, 0x07},//FRM_LENGTH_A[15:8] 1977
+	{0x0161, 0xb9},//FRM_LENGTH_A[7:0] 1977
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 3453
 	{0x0163, 0x7d},//0x78},//LINE_LENGTH_A[7:0]
 
 	{0x0164, 0x04}, //X_ADD_STA_A[11:8]
-	{0x0165, 0x4c},//X_ADD_STA_A[7:0] 
+	{0x0165, 0x4c},//X_ADD_STA_A[7:0]
 	{0x0166, 0x08}, //X_ADD_END_A[11:8]
-	{0x0167, 0x83}, //X_ADD_END_A[7:0] 
-	
+	{0x0167, 0x83}, //X_ADD_END_A[7:0]
+
 	//
-	{0x0168, 0x01},//Y_ADD_STA_A[11:8] 
-	{0x0169, 0x10},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x08},//Y_ADD_END_A[11:8]  		2175	
-	{0x016b, 0x8f},//Y_ADD_END_A[7:0] 
+	{0x0168, 0x01},//Y_ADD_STA_A[11:8]
+	{0x0169, 0x10},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x08},//Y_ADD_END_A[11:8]  		2175
+	{0x016b, 0x8f},//Y_ADD_END_A[7:0]
 	//
-	{0x016c, 0x04},//x_output_size[11:8] 
+	{0x016c, 0x04},//x_output_size[11:8]
 	{0x016d, 0x38},//x_output_size[7:0]
-	{0x016e, 0x07},//y_output_size[11:8] 
-	{0x016f, 0x80},// y_output_size[7:0] 
+	{0x016e, 0x07},//y_output_size[11:8]
+	{0x016f, 0x80},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -337,29 +337,29 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	//{0x0177, 0x00},//BINNING_CAL_MODE_V_A
 	//
 	//{0x0189,0x00},//ANA_GAIN_GLOBAL_SHORT_A
-	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A 
+	//{0x018A,0x00},//COARSE_INTEG_TIME_SHORT_A
 	//{0x018B,0x00},//COARSE_INTEG_TIME_SHORT_A
-	// 
+	//
 	//{0x018C,0x00},//CSI_DATA_FORMAT_A [15:8]
-	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]	
+	//{0x018D,0x00},//CSI_DATA_FORMAT_A [7:0]
 	//LSC
 	//{0x0190,0x00},//LSC_ENABLE_A
 	//{0x0191,0x00},//LSC_COLOR_MODE_A
-	//{0x0192,0x00},//LSC_SELECT_TABLE_A 
+	//{0x0192,0x00},//LSC_SELECT_TABLE_A
 	//{0x0193,0x00},//LSC_TUNING_ENABLE_A
 	//{0x0194,0x00},//LSC_WHITE_BALANCE_RG_A[15:8]
 	//{0x0195,0x00},//LSC_WHITE_BALANCE_RG_A[7:0]
 	//{0x0198,0x00), //LSC_TUNING_COEF_R_A
-	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A 
-	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A 
+	//{0x0199,0x00), //LSC_TUNING_COEF_GR_A
+	//{0x019A,0x00), //LSC_TUNING_COEF_GB_A
 	//{0x019B,0x00), //LSC_TUNING_COEF_B_A
-	//{0x019C,0x00), //LSC_TUNING_R_A[12:8] 
+	//{0x019C,0x00), //LSC_TUNING_R_A[12:8]
 	//{0x019D,0x00), //LSC_TUNING_R_A[7:0]
 	//{0x019E,0x00), //LSC_TUNING_GR_A[12:8]
-	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0] 
+	//{0x019F,0x00), //LSC_TUNING_GR_A[7:0]
 	//{0x01A0,0x00), //LSC_TUNING_GB_A[12:8]
-	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0] 
-	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8] 
+	//{0x01A1,0x00), //LSC_TUNING_GB_A[7:0]
+	//{0x01A2,0x00), //LSC_TUNING_B_A[12:8]
 	//{0x01A3,0x00), //LSC_TUNING_B_A[7:0]
 	//{0x01A4,0x00), //LSC_KNOT_POINT_FORMAT_A
 	//
@@ -377,7 +377,7 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x2c},//PLL_OP_MPY[7:0] 0x72  0x56  0x51  0x40
 	//
 	{0x0624, 0x07},
@@ -399,7 +399,7 @@ static const struct imx219_reg imx219_init_tab_1080_1920_30fps[] = {
 	{0x0157, 0x00},
 	{0x015a, 0x03},
 	{0x015b, 0xe8},
-	{IMX219_TABLE_END, 0x00}	
+	{IMX219_TABLE_END, 0x00}
 };
 
 
@@ -436,7 +436,7 @@ static const struct imx219_reg imx219_init_tab_1280_720_60fps[] = {
 	{0x016c, 0x05},//x_output_size[11:8] 				1280
 	{0x016d, 0x00},//x_output_size[7:0]
 	{0x016e, 0x02},//y_output_size[11:8] 				720
-	{0x016f, 0xd0},// y_output_size[7:0] 
+	{0x016f, 0xd0},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -459,7 +459,7 @@ static const struct imx219_reg imx219_init_tab_1280_720_60fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x55},//PLL_OP_MPY[7:0] 0x36
 
 	//{0x0157, 0x64},//analog gain
@@ -510,18 +510,18 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	{0x0161, 0xcc},//FRM_LENGTH_A[7:0] 0x96  0xca  0x8e     0x4a
 	{0x0162, 0x0d},//0x0d},//LINE_LENGTH_A[15:8] 			line 3476
 	{0x0163, 0x94},//0x78},//LINE_LENGTH_A[7:0]
-	// 
+	//
 #if 0
 
 	{0x0164, 0x02}, //X_ADD_STA_A[11:8] 				   1279
-	{0x0165, 0xa8},//X_ADD_STA_A[7:0] 
-	{0x0166, 0x04}, //X_ADD_END_A[11:8] 
-	{0x0167, 0xff}, //X_ADD_END_A[7:0] 
+	{0x0165, 0xa8},//X_ADD_STA_A[7:0]
+	{0x0166, 0x04}, //X_ADD_END_A[11:8]
+	{0x0167, 0xff}, //X_ADD_END_A[7:0]
 
 	{0x0168, 0x02},//Y_ADD_STA_A[11:8] 						719
-	{0x0169, 0xb4},//Y_ADD_STA_A[7:0] 
-	{0x016a, 0x05},//Y_ADD_END_A[11:8] 
-	{0x016b, 0x77},//Y_ADD_END_A[7:0] 
+	{0x0169, 0xb4},//Y_ADD_STA_A[7:0]
+	{0x016a, 0x05},//Y_ADD_END_A[11:8]
+	{0x016b, 0x77},//Y_ADD_END_A[7:0]
 #else
 	{0x0164, 0x05}, //X_ADD_STA_A[11:8] 	0x04
 	{0x0165, 0x28},//X_ADD_STA_A[7:0] 		0x4a
@@ -539,7 +539,7 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	{0x016c, 0x02},//x_output_size[11:8] 				640
 	{0x016d, 0x80},//x_output_size[7:0]
 	{0x016e, 0x01},//y_output_size[11:8] 				480
-	{0x016f, 0xe0},// y_output_size[7:0] 
+	{0x016f, 0xe0},// y_output_size[7:0]
 	//
 	{0x0170, 0x01},//X_ODD_INC_A
 	{0x0171, 0x01},//Y_ODD_INC_A
@@ -562,7 +562,7 @@ static const struct imx219_reg imx219_init_tab_640_480_75fps[] = {
 	//
 	{0x030b, 0x01},//OPSYCK_DIV
 	//
-	{0x030c, 0x00},//PLL_OP_MPY[10:8] 
+	{0x030c, 0x00},//PLL_OP_MPY[10:8]
 	{0x030d, 0x55},//PLL_OP_MPY[7:0] 0x36
 
 	//{0x0157, 0x64},//analog gain
@@ -687,7 +687,7 @@ static const struct imx219_mode supported_modes[] = {
 			.denominator = 300000,
 		},
 		.hts_def = 0x0d7d - IMX219_EXP_LINES_MARGIN,
-		.vts_def = 0x07bb,
+		.vts_def = 0x07b9,
 		.reg_list = imx219_init_tab_1080_1920_30fps,
 	},
 	{
@@ -759,7 +759,7 @@ static int reg_write(struct i2c_client *client, const u16 addr, const u8 data)
 	tx[1] = addr & 0xff;
 	tx[2] = data;
 	ret = i2c_transfer(adap, &msg, 1);
-	mdelay(2);
+	udelay(20); //mdelay(2);
 
 	return ret == 1 ? 0 : -EIO;
 }
@@ -780,7 +780,7 @@ static int reg16_write(struct i2c_client *client, const u16 addr, const u16 data
 	tx[2] = data >> 8;
 	tx[3] = data & 0xff;
 	ret = i2c_transfer(adap, &msg, 1);
-	mdelay(2);
+	udelay(20); //mdelay(2);
 
 	return ret == 1 ? 0 : -EIO;
 }
@@ -851,14 +851,14 @@ static int imx219_s_stream(struct v4l2_subdev *sd, int enable)
 	{
 		dev_err(&client->dev,"%s:enable(%d)\n",__func__,enable);
 		return reg_write_table(client, stop);
-	}	
+	}
 
 	ret = reg_write_table(client, priv->cur_mode->reg_list);
 	if (ret)
 	{
 		dev_err(&client->dev,"%s:reg_write_table failed,ret(%d)\n",__func__,ret);
 		return ret;
-	}	
+	}
 	/* Handle crop */
 	ret = reg_write(client, 0x0164, priv->crop_rect.left >> 8);
 	ret |= reg_write(client, 0x0165, priv->crop_rect.left & 0xff);
@@ -880,17 +880,17 @@ static int imx219_s_stream(struct v4l2_subdev *sd, int enable)
 	}
 
 	/* Handle flip/mirror */
-	if (priv->hflip)
-		reg |= 0x1;
-	if (priv->vflip)
-		reg |= 0x2;
-
-	ret = reg_write(client, 0x0172, reg);
-	if (ret)
-	{
-		dev_err(&client->dev,"%s:reg(0x0172) failed,ret(%d)\n",__func__,ret);
-		return ret;
-	}
+	// if (priv->hflip)
+	// 	reg |= 0x1;
+	// if (priv->vflip)
+	// 	reg |= 0x2;
+
+	// ret = reg_write(client, 0x0172, reg);
+	// if (ret)
+	// {
+	// 	dev_err(&client->dev,"%s:reg(0x0172) failed,ret(%d)\n",__func__,ret);
+	// 	return ret;
+	// }
 	/* Handle test pattern */
 	if (priv->test_pattern) {
 		ret = reg_write(client, 0x0600, priv->test_pattern >> 8);
@@ -1040,6 +1040,36 @@ static int imx219_g_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static const struct imx219_reg imx219_vflip_table_1920Wx1080H[2][2] =
+{
+	/* 1920Wx1080H */
+	{
+		/* 0 */
+		{0x0169, 0xb4},
+		{0x016b, 0xeb},
+	},
+	{
+		/* 1 */
+		{0x0169, 0xb3},
+		{0x016b, 0xea},
+	},
+};
+
+static const struct imx219_reg imx219_vflip_table_1080Wx1920H[2][2] =
+{
+	/* 1080Wx1920H */
+	{
+		/* 0 */
+		{0x0169, 0x10},
+		{0x016b, 0x8f},
+	},
+	{
+		/* 1 */
+		{0x0169, 0x11},
+		{0x016b, 0x90},
+	},
+};
+
 static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx219 *priv =
@@ -1050,16 +1080,37 @@ static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 	u32 gain = 256; //u16 gain = 256;
 	u8 a_gain = 255; //u16 a_gain = 256;
 	u16 d_gain = 1;
+	u8 mf;
+	u16 mflip;
 	dev_dbg(&client->dev,"%s:ctrl->id(0x%x),ctrl->val(%d)\n",__func__,ctrl->id,ctrl->val);
-	
+
 	switch (ctrl->id) {
 	case V4L2_CID_HFLIP:
 		priv->hflip = ctrl->val;
-		break;
+		return 0;
 
 	case V4L2_CID_VFLIP:
 		priv->vflip = ctrl->val;
-		break;
+		mf = ctrl->val << 1;
+		ret = reg_write(client, 0x0172, mf);
+		mflip = ((reg_read(client, 0x016c) & 0xf) << 8) + (reg_read(client, 0x016d) & 0xff);
+		if(mflip == 1920)
+		{
+			reg_write(client, 0x0169, imx219_vflip_table_1920Wx1080H[ctrl->val][0].val);
+			reg_write(client, 0x016b, imx219_vflip_table_1920Wx1080H[ctrl->val][1].val);
+			return 0;
+		}
+		else if(mflip == 1080)
+		{
+			reg_write(client, 0x0169, imx219_vflip_table_1080Wx1920H[ctrl->val][0].val);
+			reg_write(client, 0x016b, imx219_vflip_table_1080Wx1920H[ctrl->val][1].val);
+			return 0;
+		}
+		else
+		{
+			return 0;
+		}
+		return 0;
 
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
@@ -1092,7 +1143,7 @@ static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 			{
 				a_gain = 255 - 65536 / gain; 	//256 - 65536 / gain -1;
 			}
-		
+
 		priv->analogue_gain = a_gain;
 
 		/*
diff --git a/drivers/media/i2c/soc_camera/canaanchip/imx385.c b/drivers/media/i2c/soc_camera/canaanchip/imx385.c
index ae7a1304..4d5078a8 100755
--- a/drivers/media/i2c/soc_camera/canaanchip/imx385.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/imx385.c
@@ -27,7 +27,7 @@
 #include <media/v4l2-fwnode.h>
 #include <media/v4l2-image-sizes.h>
 #include <media/v4l2-mediabus.h>
-// gpio 
+// gpio
 #include <linux/gpio/driver.h>
 #include <linux/gpio/consumer.h>
 
@@ -87,7 +87,7 @@ struct imx385_mode {
 /* MCLK:24MHz  1920x1080  30fps   MIPI LANE2 */
 static const struct imx385_reg imx385_init_tab_1920_1080_30fps[] = {
 	{0x3000,0x01},
-	{0x3001,0x00},	
+	{0x3001,0x00},
 	{0x3002,0x01},
     {0x3004,0x10},
     {0x3005,0x01},
@@ -208,7 +208,7 @@ static const char *const tp_qmenu[] = {
 	"Stripe Pattern of the Arbitrary Value",
 	"Checker pattern of the Arbitrary Value",
 	"1-pixel Pattern",
-	"Horizontal 2-pixel Pattern",		
+	"Horizontal 2-pixel Pattern",
 };
 
 #define SIZEOF_I2C_TRANSBUF 32
@@ -254,8 +254,8 @@ struct imx385 {
 	struct mutex lock; /* mutex lock for operations */
 };
 /**
- * @brief 
- * 
+ * @brief
+ *
  */
 static const struct imx385_mode supported_modes[] = {
 	{
@@ -271,22 +271,22 @@ static const struct imx385_mode supported_modes[] = {
 	},
 };
 /**
- * @brief 
- * 
- * @param client 
- * @return struct imx385* 
+ * @brief
+ *
+ * @param client
+ * @return struct imx385*
  */
 static struct imx385 *to_imx385(const struct i2c_client *client)
 {
 	return container_of(i2c_get_clientdata(client), struct imx385, subdev);
 }
 /**
- * @brief 
- * 
- * @param client 
- * @param addr 
- * @param data 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @param addr
+ * @param data
+ * @return int
  */
 static int reg_write(struct i2c_client *client, const u16 addr, const u8 data)
 {
@@ -307,13 +307,28 @@ static int reg_write(struct i2c_client *client, const u16 addr, const u8 data)
 
 	return ret == 1 ? 0 : -EIO;
 }
-/**
- * @brief 
- * 
- * @param client 
- * @param addr 
- * @return int 
- */
+
+static int reg16_write(struct i2c_client *client, const u16 addr, const u16 data)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	u8 tx[4];
+	int ret;
+
+	msg.addr = client->addr;
+	msg.buf = tx;
+	msg.len = 4;
+	msg.flags = 0;
+	tx[0] = addr >> 8;
+	tx[1] = addr & 0xff;
+	tx[2] = data >> 8;
+	tx[3] = data & 0xff;
+	ret = i2c_transfer(adap, &msg, 1);
+	mdelay(2);
+
+	return ret == 1 ? 0 : -EIO;
+}
+
 static int reg_read(struct i2c_client *client, const u16 addr)
 {
 	u8 buf[2] = {addr >> 8, addr & 0xff};
@@ -342,11 +357,11 @@ static int reg_read(struct i2c_client *client, const u16 addr)
 	return buf[0];
 }
 /**
- * @brief 
- * 
- * @param client 
- * @param table 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @param table
+ * @return int
  */
 static int reg_write_table(struct i2c_client *client,
 			   const struct imx385_reg table[])
@@ -363,11 +378,11 @@ static int reg_write_table(struct i2c_client *client,
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param client 
- * @param table 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @param table
+ * @return int
  */
 static int reg_read_table(struct i2c_client *client,
 			   const struct imx385_reg table[])
@@ -382,8 +397,8 @@ static int reg_read_table(struct i2c_client *client,
 	return 0;
 }
 /**
- * @brief 
- * 
+ * @brief
+ *
  */
 /* V4L2 subdev video operations */
 static int imx385_s_stream(struct v4l2_subdev *sd, int enable)
@@ -398,14 +413,14 @@ static int imx385_s_stream(struct v4l2_subdev *sd, int enable)
 	{
 		dev_err(&client->dev,"%s:enable(%d)\n",__func__,enable);
 		return reg_write_table(client, stop);
-	}	
+	}
 
 	ret = reg_write_table(client, priv->cur_mode->reg_list);
 	if (ret)
 	{
 		dev_err(&client->dev,"%s:reg_write_table failed,ret(%d)\n",__func__,ret);
 		return ret;
-	}	
+	}
 	//
 	//reg_read_table(client, priv->cur_mode->reg_list);
 	/* Handle flip/mirror */
@@ -469,8 +484,8 @@ static int imx385_s_stream(struct v4l2_subdev *sd, int enable)
 	return reg_write_table(client, start);
 }
 /**
- * @brief 
- * 
+ * @brief
+ *
  */
 /* V4L2 subdev core operations */
 static int imx385_s_power(struct v4l2_subdev *sd, int on)
@@ -606,7 +621,7 @@ static int imx385_s_ctrl_test_pattern(struct v4l2_ctrl *ctrl)
 		priv->test_pattern_pgvpos = 0;
 		priv->test_pattern_pghprm = 1;
 		priv->test_pattern_pgthru = 1;
-		break;	
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -614,11 +629,11 @@ static int imx385_s_ctrl_test_pattern(struct v4l2_ctrl *ctrl)
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param fi 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param fi
+ * @return int
  */
 static int imx385_g_frame_interval(struct v4l2_subdev *sd,
 				   struct v4l2_subdev_frame_interval *fi)
@@ -649,14 +664,14 @@ static void imx385_reset(struct imx385 *priv, int rst)
 	usleep_range(IMX385_RESET_DELAY1, IMX385_RESET_DELAY2);
 }
 /**
- * @brief 
- * 
- * @param ctrl 
- * @return int 
+ * @brief
+ *
+ * @param ctrl
+ * @return int
  */
- 
- 
-static int IMX385_GaindB[481] = 
+
+
+static int IMX385_GaindB[481] =
 {
 	0,     3,     5,     8,   10,   13,   15,   17,   19,   22,
 	24,   26,   28,   30,   32,   33,   35,   37,   39,   40,
@@ -670,7 +685,7 @@ static int IMX385_GaindB[481] =
 	116, 117, 118, 118, 119, 120, 120, 121, 122, 122,
 	123, 124, 124, 125, 126, 126, 127, 128, 128, 129,
 	129, 130, 131, 131, 132, 132, 133, 134, 134, 135,
-	135, 136, 136, 137, 138, 138, 139, 139, 140, 140, 
+	135, 136, 136, 137, 138, 138, 139, 139, 140, 140,
 	141, 141, 142, 142, 143, 144, 144, 145, 145, 146,
 	146, 147, 147, 148, 148, 149, 149, 150, 150, 151,
 	151, 151, 152, 152, 153, 153, 154, 154, 155, 155,
@@ -683,7 +698,7 @@ static int IMX385_GaindB[481] =
 	179, 180, 180, 180, 181, 181, 181, 182, 182, 182,
 	183, 183, 183, 184, 184, 184, 185, 185, 185, 186,
 	186, 186, 187, 187, 187, 187, 188, 188, 188, 189,
-	189, 189, 190, 190, 190, 191, 191, 191, 191, 192, 
+	189, 189, 190, 190, 190, 191, 191, 191, 191, 192,
 	192, 192, 193, 193, 193, 194, 194, 194, 194, 195,
 	195, 195, 196, 196, 196, 196, 197, 197, 197, 198,
 	198, 198, 198, 199, 199, 199, 199, 200, 200, 200,
@@ -696,7 +711,7 @@ static int IMX385_GaindB[481] =
 	215, 216, 216, 216, 216, 217, 217, 217, 217, 217,
 	218, 218, 218, 218, 219, 219, 219, 219, 219, 220,
 	220, 220, 220, 220, 221, 221, 221, 221, 222, 222,
-	222, 222, 222, 223, 223, 223, 223, 223, 224, 224, 
+	222, 222, 222, 223, 223, 223, 223, 223, 224, 224,
 	224, 224, 224, 225, 225, 225, 225, 225, 226, 226,
 	226, 226, 226, 227, 227, 227, 227, 227, 228, 228,
 	228, 228, 228, 229, 229, 229, 229, 229, 230, 230,
@@ -706,7 +721,7 @@ static int IMX385_GaindB[481] =
 	236, 236, 236, 236, 236, 236, 237, 237, 237, 237,
 	237, 238, 238, 238, 238, 238, 238, 239, 239, 239,
 	239, 239, 239, 240, 240, 240, 240, 240, 240, 241,
-	241, 
+	241,
 };
 
 static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
@@ -716,6 +731,8 @@ static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 	struct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);
 	u8 reg;
 	int ret;
+	u16 tempGain;
+	u16 tempET;
 
 	dev_dbg(&client->dev,"%s:ctrl->id(0x%x),ctrl->val(%d)\n",__func__,ctrl->id,ctrl->val);
 
@@ -730,8 +747,8 @@ static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
-	
-	#if 0 
+
+	#if 0
 		priv->digital_gain = ctrl->val*5;
 		ret |= reg_write(client, 0x3015, (priv->digital_gain&0x3000) >> 12);
 		ret |= reg_write(client, 0x3014, (priv->digital_gain/16) & 0xff);
@@ -751,19 +768,24 @@ static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 
 		priv->digital_gain = IMX385_GaindB[priv->digital_gain];
-		ret |= reg_write(client, 0x3015, (priv->digital_gain&0x300) >> 8);
-		ret |= reg_write(client, 0x3014, (priv->digital_gain) & 0xff);
-			
-			
+//		ret |= reg_write(client, 0x3015, (priv->digital_gain&0x300) >> 8);
+//		ret |= reg_write(client, 0x3014, (priv->digital_gain) & 0xff);
+		tempGain = (((priv->digital_gain) & 0xff)<<8) + ((priv->digital_gain&0x300) >> 8);
+		ret = reg16_write(client, 0x3014, tempGain);
+
+
 	#endif
 		return ret;
 
 	case V4L2_CID_EXPOSURE:
-		priv->exposure_time = 1125 - ctrl->val -1;
+//		priv->exposure_time = 1125 - ctrl->val -1;
+		priv->exposure_time = 1124 - ctrl->val;
+//		ret = reg_write(client, 0x3022, (priv->exposure_time >> 16)&0x01);
+//		ret = reg_write(client, 0x3021, priv->exposure_time >> 8);
+//		ret |= reg_write(client, 0x3020, priv->exposure_time & 0xff);
+		tempET = ((priv->exposure_time & 0xff)<<8) + ((priv->exposure_time&0xff00) >> 8);
+		ret = reg16_write(client, 0x3020, tempET);
 
-		ret = reg_write(client, 0x3022, (priv->exposure_time >> 16)&0x01);
-		ret = reg_write(client, 0x3021, priv->exposure_time >> 8);
-		ret |= reg_write(client, 0x3020, priv->exposure_time & 0xff);
 		return ret;
 
 	case V4L2_CID_TEST_PATTERN:
@@ -789,12 +811,12 @@ static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param cfg 
- * @param code 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param cfg
+ * @param code
+ * @return int
  */
 static int imx385_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_pad_config *cfg,
@@ -807,11 +829,11 @@ static int imx385_enum_mbus_code(struct v4l2_subdev *sd,
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param mode 
- * @param framefmt 
- * @return int 
+ * @brief
+ *
+ * @param mode
+ * @param framefmt
+ * @return int
  */
 static int imx385_get_reso_dist(const struct imx385_mode *mode,
 				struct v4l2_mbus_framefmt *framefmt)
@@ -820,10 +842,10 @@ static int imx385_get_reso_dist(const struct imx385_mode *mode,
 	       abs(mode->height - framefmt->height);
 }
 /**
- * @brief 
- * 
- * @param fmt 
- * @return const struct imx385_mode* 
+ * @brief
+ *
+ * @param fmt
+ * @return const struct imx385_mode*
  */
 static const struct imx385_mode *imx385_find_best_fit(
 					struct v4l2_subdev_format *fmt)
@@ -845,12 +867,12 @@ static const struct imx385_mode *imx385_find_best_fit(
 	return &supported_modes[cur_best_fit];
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param cfg 
- * @param fmt 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param cfg
+ * @param fmt
+ * @return int
  */
 static int imx385_set_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
@@ -861,7 +883,7 @@ static int imx385_set_fmt(struct v4l2_subdev *sd,
 	const struct imx385_mode *mode;
 	s64 h_blank, v_blank, pixel_rate;
 	u32 fps = 0;
-	
+
 	dev_info(&client->dev,"%s:start\n",__func__);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		return 0;
@@ -886,10 +908,10 @@ static int imx385_set_fmt(struct v4l2_subdev *sd,
 					pixel_rate, 1, pixel_rate);
 
 	/* reset crop window */
-	priv->crop_rect.left = 1920/2 - (mode->width / 2); 
+	priv->crop_rect.left = 1920/2 - (mode->width / 2);
 	if (priv->crop_rect.left < 0)
 		priv->crop_rect.left = 0;
-	priv->crop_rect.top = 1080/2 - (mode->height / 2); 
+	priv->crop_rect.top = 1080/2 - (mode->height / 2);
 	if (priv->crop_rect.top < 0)
 		priv->crop_rect.top = 0;
 	priv->crop_rect.width = mode->width;
@@ -898,12 +920,12 @@ static int imx385_set_fmt(struct v4l2_subdev *sd,
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param cfg 
- * @param fmt 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param cfg
+ * @param fmt
+ * @return int
  */
 static int imx385_get_fmt(struct v4l2_subdev *sd,
 			  struct v4l2_subdev_pad_config *cfg,
@@ -927,12 +949,12 @@ static int imx385_get_fmt(struct v4l2_subdev *sd,
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param cmd 
- * @param arg 
- * @return long 
+ * @brief
+ *
+ * @param sd
+ * @param cmd
+ * @param arg
+ * @return long
  */
 static long imx385_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
@@ -952,8 +974,8 @@ static long imx385_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return ret;
 }
 /**
- * @brief 
- * 
+ * @brief
+ *
  */
 #ifdef CONFIG_COMPAT
 static long imx385_compat_ioctl32(struct v4l2_subdev *sd,
@@ -998,12 +1020,12 @@ static long imx385_compat_ioctl32(struct v4l2_subdev *sd,
 }
 #endif
 /**
- * @brief 
- * 
- * @param sd 
- * @param cfg 
- * @param fie 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param cfg
+ * @param fie
+ * @return int
  */
 static int imx385_enum_frame_interval(struct v4l2_subdev *sd,
 				       struct v4l2_subdev_pad_config *cfg,
@@ -1024,11 +1046,11 @@ static int imx385_enum_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @param config 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @param config
+ * @return int
  */
 static int IMX385_g_mbus_config(struct v4l2_subdev *sd,
 				struct v4l2_mbus_config *config)
@@ -1090,10 +1112,10 @@ static const struct v4l2_ctrl_ops imx385_ctrl_ops = {
 	.s_ctrl = imx385_s_ctrl,
 };
 /**
- * @brief 
- * 
- * @param client 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @return int
  */
 static int imx385_video_probe(struct i2c_client *client)
 {
@@ -1172,10 +1194,10 @@ static int imx385_video_probe(struct i2c_client *client)
 	return ret;
 }
 /**
- * @brief 
- * 
- * @param sd 
- * @return int 
+ * @brief
+ *
+ * @param sd
+ * @return int
  */
 static int imx385_ctrls_init(struct v4l2_subdev *sd)
 {
@@ -1251,11 +1273,11 @@ static int imx385_ctrls_init(struct v4l2_subdev *sd)
 	return ret;
 }
 /**
- * @brief 
- * 
- * @param client 
- * @param did 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @param did
+ * @return int
  */
 static int imx385_probe(struct i2c_client *client,
 			const struct i2c_device_id *did)
@@ -1356,10 +1378,10 @@ static int imx385_probe(struct i2c_client *client,
 	return ret;
 }
 /**
- * @brief 
- * 
- * @param client 
- * @return int 
+ * @brief
+ *
+ * @param client
+ * @return int
  */
 static int imx385_remove(struct i2c_client *client)
 {
-- 
2.36.1

