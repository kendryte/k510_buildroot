From a7c1ec1d93cfb4ca773947e5ac4e29a1b1b81bcb Mon Sep 17 00:00:00 2001
From: alex-guo <guoshidong@canaan-creative.com>
Date: Wed, 20 Jul 2022 17:44:59 +0800
Subject: [PATCH] update imx385 ae calc accuracy

---
 .../media/i2c/soc_camera/canaanchip/imx385.c  | 83 +++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/drivers/media/i2c/soc_camera/canaanchip/imx385.c b/drivers/media/i2c/soc_camera/canaanchip/imx385.c
index 9be1d979..ae7a1304 100755
--- a/drivers/media/i2c/soc_camera/canaanchip/imx385.c
+++ b/drivers/media/i2c/soc_camera/canaanchip/imx385.c
@@ -31,6 +31,12 @@
 #include <linux/gpio/driver.h>
 #include <linux/gpio/consumer.h>
 
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/bug.h>
+#include <media/dvb_math.h>
+
 #define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x0)
 
 /* IMX385 supported geometry */
@@ -648,6 +654,61 @@ static void imx385_reset(struct imx385 *priv, int rst)
  * @param ctrl 
  * @return int 
  */
+ 
+ 
+static int IMX385_GaindB[481] = 
+{
+	0,     3,     5,     8,   10,   13,   15,   17,   19,   22,
+	24,   26,   28,   30,   32,   33,   35,   37,   39,   40,
+	42,   44,   45,   47,   49,   50,   52,   53,   55,   56,
+	57,   59,   60,   62,   63,   64,   65,   67,   68,   69,
+	70,   72,   73,   74,   75,   76,   77,   78,   80,   81,
+	82,   83,   84,   85,   86,   87,   88,   89,   90,   91,
+	92,   93,   94,   95,   95,   96,   97,   98,   99, 100,
+	101, 102, 102, 103, 104, 105, 106, 106, 107, 108,
+	109, 110, 110, 111, 112, 113, 113, 114, 115, 116,
+	116, 117, 118, 118, 119, 120, 120, 121, 122, 122,
+	123, 124, 124, 125, 126, 126, 127, 128, 128, 129,
+	129, 130, 131, 131, 132, 132, 133, 134, 134, 135,
+	135, 136, 136, 137, 138, 138, 139, 139, 140, 140, 
+	141, 141, 142, 142, 143, 144, 144, 145, 145, 146,
+	146, 147, 147, 148, 148, 149, 149, 150, 150, 151,
+	151, 151, 152, 152, 153, 153, 154, 154, 155, 155,
+	156, 156, 157, 157, 157, 158, 158, 159, 159, 160,
+	160, 160, 161, 161, 162, 162, 163, 163, 163, 164,
+	164, 165, 165, 165, 166, 166, 167, 167, 167, 168,
+	168, 169, 169, 169, 170, 170, 171, 171, 171, 172,
+	172, 172, 173, 173, 174, 174, 174, 175, 175, 175,
+	176, 176, 176, 177, 177, 178, 178, 178, 179, 179,
+	179, 180, 180, 180, 181, 181, 181, 182, 182, 182,
+	183, 183, 183, 184, 184, 184, 185, 185, 185, 186,
+	186, 186, 187, 187, 187, 187, 188, 188, 188, 189,
+	189, 189, 190, 190, 190, 191, 191, 191, 191, 192, 
+	192, 192, 193, 193, 193, 194, 194, 194, 194, 195,
+	195, 195, 196, 196, 196, 196, 197, 197, 197, 198,
+	198, 198, 198, 199, 199, 199, 199, 200, 200, 200,
+	201, 201, 201, 201, 202, 202, 202, 202, 203, 203,
+	203, 203, 204, 204, 204, 204, 205, 205, 205, 206,
+	206, 206, 206, 207, 207, 207, 207, 208, 208, 208,
+	208, 209, 209, 209, 209, 210, 210, 210, 210, 210,
+	211, 211, 211, 211, 212, 212, 212, 212, 213, 213,
+	213, 213, 214, 214, 214, 214, 214, 215, 215, 215,
+	215, 216, 216, 216, 216, 217, 217, 217, 217, 217,
+	218, 218, 218, 218, 219, 219, 219, 219, 219, 220,
+	220, 220, 220, 220, 221, 221, 221, 221, 222, 222,
+	222, 222, 222, 223, 223, 223, 223, 223, 224, 224, 
+	224, 224, 224, 225, 225, 225, 225, 225, 226, 226,
+	226, 226, 226, 227, 227, 227, 227, 227, 228, 228,
+	228, 228, 228, 229, 229, 229, 229, 229, 230, 230,
+	230, 230, 230, 231, 231, 231, 231, 231, 232, 232,
+	232, 232, 232, 232, 233, 233, 233, 233, 233, 234,
+	234, 234, 234, 234, 234, 235, 235, 235, 235, 235,
+	236, 236, 236, 236, 236, 236, 237, 237, 237, 237,
+	237, 238, 238, 238, 238, 238, 238, 239, 239, 239,
+	239, 239, 239, 240, 240, 240, 240, 240, 240, 241,
+	241, 
+};
+
 static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx385 *priv =
@@ -669,10 +730,32 @@ static int imx385_s_ctrl(struct v4l2_ctrl *ctrl)
 
 	case V4L2_CID_ANALOGUE_GAIN:
 	case V4L2_CID_GAIN:
+	
+	#if 0 
 		priv->digital_gain = ctrl->val*5;
 		ret |= reg_write(client, 0x3015, (priv->digital_gain&0x3000) >> 12);
 		ret |= reg_write(client, 0x3014, (priv->digital_gain/16) & 0xff);
+	#else
+		priv->digital_gain = (ctrl->val + 7)>>3;
+		if(priv->digital_gain<=32)
+		{
+			priv->digital_gain = 0;
+		}
+		else
+		{
+			priv->digital_gain -= 32;
+			if(priv->digital_gain>480)
+			{
+				priv->digital_gain = 480;
+			}
+		}
 
+		priv->digital_gain = IMX385_GaindB[priv->digital_gain];
+		ret |= reg_write(client, 0x3015, (priv->digital_gain&0x300) >> 8);
+		ret |= reg_write(client, 0x3014, (priv->digital_gain) & 0xff);
+			
+			
+	#endif
 		return ret;
 
 	case V4L2_CID_EXPOSURE:
-- 
2.36.1

