From 362f693142510b7a66228d03972086edc57e8086 Mon Sep 17 00:00:00 2001
From: wycwyhwyq <5f20.6d9b@gmail.com>
Date: Sat, 27 Aug 2022 16:19:35 +0800
Subject: [PATCH] Add layer0 crop and scale

---
 drivers/gpu/drm/canaan/kendryte_crtc.c | 2731 ++++++++++++------------
 drivers/gpu/drm/canaan/kendryte_vo.c   | 2325 ++++++++++----------
 drivers/gpu/drm/canaan/kendryte_vo.h   |  951 +++++----
 3 files changed, 2954 insertions(+), 3053 deletions(-)

diff --git a/drivers/gpu/drm/canaan/kendryte_crtc.c b/drivers/gpu/drm/canaan/kendryte_crtc.c
index 1b06901f..26300678 100755
--- a/drivers/gpu/drm/canaan/kendryte_crtc.c
+++ b/drivers/gpu/drm/canaan/kendryte_crtc.c
@@ -15,1420 +15,1317 @@
  * GNU General Public License for more details.
  */
 
-#include <drm/drm.h>
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_fourcc.h>
-
-#include <drm/drm_flip_work.h>
-#include <drm/drm_plane_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-
-#ifdef CONFIG_DRM_ANALOGIX_DP
-#include <drm/bridge/analogix_dp.h>
-#endif
-
-#include <linux/debugfs.h>
-#include <linux/fixp-arith.h>
-#include <linux/iopoll.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/iopoll.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/component.h>
-#include <linux/overflow.h>
-#include <linux/regmap.h>
-#include <linux/mfd/syscon.h>
-
-#include <linux/reset.h>
-#include <linux/delay.h>
-#include <linux/sort.h>
-
-#include <uapi/linux/videodev2.h>
-
-#include "kendryte_layer.h"
-#include "kendryte_vo.h"
-
-
-
-
-static int __maybe_unused
-kendryte_atomic_helper_update_plane(struct drm_plane *plane,
-				    struct drm_crtc *crtc,
-				    struct drm_framebuffer *fb,
-				    int crtc_x, int crtc_y,
-				    unsigned int crtc_w, unsigned int crtc_h,
-				    uint32_t src_x, uint32_t src_y,
-				    uint32_t src_w, uint32_t src_h,
-				    struct drm_modeset_acquire_ctx *ctx)
-{
-    struct drm_atomic_state *state;
-	struct drm_plane_state *plane_state;
-	struct kendryte_layer_state *vop_plane_state;
-	int ret = 0;
-
-	//printk("rockchip_atomic_helper_update_plane start \n");
-	state = drm_atomic_state_alloc(plane->dev);
-	if (!state)
-		return -ENOMEM;
-
-	state->acquire_ctx = ctx;
-	plane_state = drm_atomic_get_plane_state(state, plane);
-	if (IS_ERR(plane_state)) {
-		ret = PTR_ERR(plane_state);
-		goto fail;
-	}
-
-    vop_plane_state = state_to_kendryte_layer_state(plane_state);
-
-    ret = drm_atomic_set_crtc_for_plane(plane_state, crtc);
-	if (ret != 0)
-		goto fail;
-
-    drm_atomic_set_fb_for_plane(plane_state, fb);
-	plane_state->crtc_x = crtc_x;
-	plane_state->crtc_y = crtc_y;
-	plane_state->crtc_w = crtc_w;
-	plane_state->crtc_h = crtc_h;
-	plane_state->src_x = src_x;
-	plane_state->src_y = src_y;
-	plane_state->src_w = src_w;
-	plane_state->src_h = src_h;
-
-	ret = drm_atomic_commit(state);
-fail:
-	drm_atomic_state_put(state);
-	return ret;
-}
-
-
-/**
- * drm_atomic_helper_disable_plane copy from drm_atomic_helper_disable_plane
- * be designed to support async commit at ioctl DRM_IOCTL_MODE_SETPLANE.
- *
- * @plane: plane to disable
- * @ctx: lock acquire context
- *
- * Provides a default plane disable handler using the atomic driver interface.
- *
- * RETURNS:
- * Zero on success, error code on failure
- */
-static int __maybe_unused
-kendryte_atomic_helper_disable_plane(struct drm_plane *plane,
-				     struct drm_modeset_acquire_ctx *ctx)
-{
-	struct drm_atomic_state *state;
-	struct drm_plane_state *plane_state;
-	struct kendryte_layer_state *vop_plane_state;
-	int ret = 0;
-
-	state = drm_atomic_state_alloc(plane->dev);
-	if (!state)
-		return -ENOMEM;
-
-	state->acquire_ctx = ctx;
-	plane_state = drm_atomic_get_plane_state(state, plane);
-	if (IS_ERR(plane_state)) {
-		ret = PTR_ERR(plane_state);
-		goto fail;
-	}
-	vop_plane_state = state_to_kendryte_layer_state(plane_state);
-
-	if ((plane_state->crtc && plane_state->crtc->cursor == plane) ||
-	    vop_plane_state->async_commit)
-		plane_state->state->legacy_cursor_update = true;
-		
-/*
-	ret = __drm_atomic_helper_disable_plane(plane, plane_state);
-	if (ret != 0)
-		goto fail;
-*/
-	ret = drm_atomic_commit(state);
-fail:
-	drm_atomic_state_put(state);
-	return ret;
-}
-
-
-static void kendryte_plane_destroy(struct drm_plane *plane)
-{
-	drm_plane_cleanup(plane);
-}
-
-
-static void kendryte_destroy_crtc(struct kendryte_vo *vop)
-{
-	struct drm_crtc *crtc = &vop->crtc;
-	struct drm_device *drm_dev = vop->drm;
-	struct drm_plane *plane, *tmp;
-
-	of_node_put(crtc->port);
-
-	/*
-	 * We need to cleanup the planes now.  Why?
-	 *
-	 * The planes are "&vop->win[i].base".  That means the memory is
-	 * all part of the big "struct vop" chunk of memory.  That memory
-	 * was devm allocated and associated with this component.  We need to
-	 * free it ourselves before vop_unbind() finishes.
-	 */
-	list_for_each_entry_safe(plane, tmp, &drm_dev->mode_config.plane_list,
-				 head)
-		kendryte_plane_destroy(plane);
-
-	/*
-	 * Destroy CRTC after vop_plane_destroy() since vop_disable_plane()
-	 * references the CRTC.
-	 */
-	drm_crtc_cleanup(crtc);
-
-}
-
-static void kendryte_atomic_plane_reset(struct drm_plane *plane)
-{
-	struct kendryte_layer_state *vop_plane_state =
-					state_to_kendryte_layer_state(plane->state);
-
-	if (plane->state && plane->state->fb)
-		__drm_atomic_helper_plane_destroy_state(plane->state);
-	kfree(vop_plane_state);
-	vop_plane_state = kzalloc(sizeof(*vop_plane_state), GFP_KERNEL);
-	if (!vop_plane_state)
-		return;
-
-
-	vop_plane_state->global_alpha = 0xff;
-
-	plane->state = &vop_plane_state->state;
-	plane->state->plane = plane;
-}
-
-
-static struct drm_plane_state *
-kendryte_atomic_plane_duplicate_state(struct drm_plane *plane)
-{
-	struct kendryte_layer_state *old_vop_plane_state;
-	struct kendryte_layer_state *vop_plane_state;
-
-	if (WARN_ON(!plane->state))
-		return NULL;
-	
-//	printk("kendryte_atomic_plane_duplicate_state \n");
-	old_vop_plane_state = state_to_kendryte_layer_state(plane->state);
-	vop_plane_state = kmemdup(old_vop_plane_state,
-				  sizeof(*vop_plane_state), GFP_KERNEL);
-	if (!vop_plane_state)
-		return NULL;
-
-	__drm_atomic_helper_plane_duplicate_state(plane,
-						  &vop_plane_state->state);
-
-	return &vop_plane_state->state;
-}
-
-
-static void kendryte_atomic_plane_destroy_state(struct drm_plane *plane,
-					   struct drm_plane_state *state)
-{
-	struct kendryte_layer_state *vop_state = state_to_kendryte_layer_state(state);
-
-	__drm_atomic_helper_plane_destroy_state(state);
-
-	kfree(vop_state);
-}
-
-static int kendryte_atomic_plane_set_property(struct drm_plane *plane,
-					 struct drm_plane_state *state,
-					 struct drm_property *property,
-					 uint64_t val)
-{
-	struct kendryte_drm_private *private = plane->dev->dev_private;
-//	struct vop_win *win = to_vop_win(plane);
-	struct kendryte_layer_state *plane_state = state_to_kendryte_layer_state(state);
-
-/*
-	//printk("vop_atomic_plane_set_property \n");
-	if (property == win->vop->plane_zpos_prop) {
-		plane_state->zpos = val;
-		return 0;
-	}
-*/
-
-	if (property == private->eotf_prop) {
-		plane_state->eotf = val;
-		return 0;
-	}
-
-	if (property == private->color_space_prop) {
-		plane_state->color_space = val;
-		return 0;
-	}
-
-	if (property == private->global_alpha_prop) {
-		plane_state->global_alpha = val;
-		return 0;
-	}
-
-	if (property == private->blend_mode_prop) {
-		plane_state->blend_mode = val;
-		return 0;
-	}
-
-	if (property == private->async_commit_prop) {
-		plane_state->async_commit = val;
-		return 0;
-	}
-
-	DRM_ERROR("failed to set vop plane property id:%d, name:%s\n",
-		   property->base.id, property->name);
-
-	return -EINVAL;
-}
-
-
-
-static int kendryte_atomic_plane_get_property(struct drm_plane *plane,
-					 const struct drm_plane_state *state,
-					 struct drm_property *property,
-					 uint64_t *val)
-{
-	struct kendryte_layer_state *plane_state = state_to_kendryte_layer_state(state);
-//	struct vop_win *win = to_vop_win(plane);
-	struct kendryte_drm_private *private = plane->dev->dev_private;
-
-	//printk("vop_atomic_plane_get_property \n");
-/*
-	if (property == win->vop->plane_zpos_prop) {
-		*val = plane_state->zpos;
-		return 0;
-	}
-*/
-
-	if (property == private->eotf_prop) {
-		*val = plane_state->eotf;
-		return 0;
-	}
-
-	if (property == private->color_space_prop) {
-		*val = plane_state->color_space;
-		return 0;
-	}
-
-	if (property == private->global_alpha_prop) {
-		*val = plane_state->global_alpha;
-		return 0;
-	}
-
-	if (property == private->blend_mode_prop) {
-		*val = plane_state->blend_mode;
-		return 0;
-	}
-
-	if (property == private->async_commit_prop) {
-		*val = plane_state->async_commit;
-		return 0;
-	}
-
-	if (property == private->share_id_prop) {
-		int i;
-		struct drm_mode_object *obj = &plane->base;
-
-		for (i = 0; i < obj->properties->count; i++) {
-			if (obj->properties->properties[i] == property) {
-				*val = obj->properties->values[i];
-				return 0;
-			}
-		}
-	}
-
-	DRM_ERROR("failed to get vop plane property id:%d, name:%s\n",
-		   property->base.id, property->name);
-
-	return -EINVAL;
-}
-
-
-static const struct drm_plane_funcs kendryte_layer_funcs = {
-	.update_plane	= kendryte_atomic_helper_update_plane,
-	.disable_plane	= kendryte_atomic_helper_disable_plane,
-	.destroy = kendryte_plane_destroy,
-	.reset = kendryte_atomic_plane_reset,
-	.atomic_duplicate_state = kendryte_atomic_plane_duplicate_state,
-	.atomic_destroy_state = kendryte_atomic_plane_destroy_state,
-	.atomic_set_property = kendryte_atomic_plane_set_property,
-	.atomic_get_property = kendryte_atomic_plane_get_property,
-};
-
-
-
-
-
-static void kendryte_plane_atomic_disable(struct drm_plane *plane,
-				     struct drm_plane_state *old_state)
-{
-	struct kendryte_layer *win = to_vop_layer(plane);
-	struct kendryte_vo *vop = to_vop(old_state->crtc);
-#if defined(CONFIG_ROCKCHIP_DRM_DEBUG)
-	struct vop_plane_state *vop_plane_state =
-					to_vop_plane_state(plane->state);
-#endif
-
-	if (!old_state->crtc)
-		return;
-
-
-#if 0 
-	spin_lock(&vop->reg_lock);
-
-	vop_win_disable(vop, win);
-
-	/*
-	 * IC design bug: in the bandwidth tension environment when close win2,
-	 * vop will access the freed memory lead to iommu pagefault.
-	 * so we add this reset to workaround.
-	 */
-	if (VOP_MAJOR(vop->version) == 2 && VOP_MINOR(vop->version) == 5 &&
-	    win->win_id == 2)
-		VOP_WIN_SET(vop, win, yrgb_mst, 0);
-
-
-	spin_unlock(&vop->reg_lock);
-#endif
-}
-
-
-static void kendryte_plane_atomic_update(struct drm_plane *plane,
-		struct drm_plane_state *old_state)
-{
-	struct drm_plane_state *state = plane->state;
-	struct drm_crtc *crtc = state->crtc;
-	struct drm_display_mode *mode = NULL;
-	struct kendryte_layer *layer = to_vop_layer(plane);
-	struct kendryte_layer_state *vop_plane_state = state_to_kendryte_layer_state(state);
-	struct kendryte_crtc_state *s;
-	struct kendryte_vo *vop = to_vop(state->crtc);
-	struct drm_framebuffer *fb = state->fb;
-	unsigned int actual_w, actual_h;
-	unsigned int dsp_stx, dsp_sty;
-	uint32_t act_info, dsp_info, dsp_st;
-	struct drm_rect *src = &vop_plane_state->src;
-	struct drm_rect *dest = &vop_plane_state->dest;
-	uint32_t val;
-	uint32_t stride;
-	bool rb_swap, global_alpha_en;
-
-    struct drm_format_info *format = fb->format;
-
-	/*
-	 * can't update plane when vop is disabled.
-	 */
-	if (WARN_ON(!crtc))
-		return;
-
-	mode = &crtc->state->adjusted_mode;
-	actual_w = drm_rect_width(src) >> 16;
-	actual_h = drm_rect_height(src) >> 16;
-	act_info = (actual_h - 1) << 16 | ((actual_w - 1) & 0xffff);
-
-	dsp_info = (drm_rect_height(dest) - 1) << 16;
-	dsp_info |= (drm_rect_width(dest) - 1) & 0xffff;
-
-	dsp_stx = dest->x1 + mode->crtc_htotal - mode->crtc_hsync_start;
-	dsp_sty = dest->y1 + mode->crtc_vtotal - mode->crtc_vsync_start;
-	dsp_st = dsp_sty << 16 | (dsp_stx & 0xffff);
-
-	s = to_kendryte_crtc_state(crtc->state);
-		
-	if(plane->base.id == vop->layer[0].layer_id)
-	{
-		// config yuv1
-		writel(0x11, vop->base + VO_LAYER0_PINGPANG_SEL_MODE);
-		kendryte_set_layer_uv_endian(vop, LAYER0, VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
-		kendryte_set_layer_postion(vop, LAYER0, actual_h, actual_w, dest->y1, dest->x1, mode);
-		stride = (vop->layer[0].stride / 8 - 1) + ((actual_h) << 16);
-
-		//stride = (actual_w / 8 - 1) + ((actual_h) << 16);
-		kendryte_set_layer_stride(vop, LAYER0, stride);
-		kendryte_set_layer_addr(vop, LAYER0, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->uv_mst, vop_plane_state->uv_mst);
-
-		writel(0x1, vop->base + 0x174);
-		writel(0x1, vop->base + 0x17c);
-
-	}
-
-	if(plane->base.id == vop->layer[1].layer_id)
-	{
-		// config yuv1
-		writel(0x11, vop->base + VO_LAYER1_PINGPANG_SEL_MODE);
-		kendryte_set_layer_uv_endian(vop, LAYER1, VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
-
-		kendryte_layer_set_uv_swap(vop, LAYER1, 0);
-		kendryte_layer_set_in_offset(vop, LAYER1, 0);
-
-		kendryte_set_layer_postion(vop, LAYER1, actual_h, actual_w, dest->y1, dest->x1, mode);
-		stride = (vop->layer[1].stride / 8 -1) + ((actual_h - 1) << 16);
-		//stride = (actual_w / 8 - 1) + ((actual_h) << 16);
-		kendryte_set_layer_stride(vop, LAYER1, stride);
-		kendryte_set_layer_addr(vop, LAYER1, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->uv_mst, vop_plane_state->uv_mst);
-
-	}
-
-	if(plane->base.id == vop->layer[2].layer_id)
-	{
-		// config yuv2
-		writel(0x11, vop->base + VO_LAYER2_PINGPANG_SEL_MODE);
-		kendryte_set_layer_uv_endian(vop, LAYER2, VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
-
-		kendryte_layer_set_uv_swap(vop, LAYER2, 0);
-		kendryte_layer_set_in_offset(vop, LAYER2, 0);
-
-		kendryte_set_layer_postion(vop, LAYER2, actual_h, actual_w, dest->y1, dest->x1, mode);
-		stride = (vop->layer[2].stride / 8 -1) + ((actual_h - 1) << 16);
-		//stride = (actual_w / 8 - 1) + ((actual_h) << 16);
-		kendryte_set_layer_stride(vop, LAYER2, stride);
-		kendryte_set_layer_addr(vop, LAYER2, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->uv_mst, vop_plane_state->uv_mst);
-	}
-
-	if(plane->base.id == vop->layer[3].layer_id)
-	{
-		// config yuv3
-		writel(0x11, vop->base + VO_LAYER3_PINGPANG_SEL_MODE);
-		kendryte_set_layer_uv_endian(vop, LAYER3, VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
-
-		kendryte_layer_set_uv_swap(vop, LAYER3, 0);
-		kendryte_layer_set_in_offset(vop, LAYER3, 0);
-
-		kendryte_set_layer_postion(vop, LAYER3, actual_h, actual_w, dest->y1, dest->x1, mode);
-		stride = (vop->layer[3].stride / 8 -1) + ((actual_h - 1) << 16);
-		//stride = (actual_w / 8 - 1) + ((actual_h) << 16);
-		kendryte_set_layer_stride(vop, LAYER3, stride);
-		kendryte_set_layer_addr(vop, LAYER3, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->uv_mst, vop_plane_state->uv_mst);
-
-	}
-
-	if(plane->base.id == vop->layer[4].layer_id)
-	{
-		// osd0 argb
-		writel(0x100, vop->base + VO_LAYER4_PINGPANG_SEL_MODE);
-		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD0);
-		kendryte_layer_set_uv_swap(vop, OSD0, 1);
-		kendryte_vo_osd_set_format(vop, OSD0, vop_plane_state->format);
-		kendryte_set_layer_postion(vop, OSD0, actual_h, actual_w, dest->y1, dest->x1, mode);
-		kendryte_set_layer_stride(vop, OSD0, (actual_w * 4) / 8);
-		kendryte_set_osd_addr(vop, OSD0, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst);
-
-	}
-
-	if(plane->base.id == vop->layer[5].layer_id)
-	{
-		// osd1 argb
-		writel(0x100, vop->base + VO_LAYER5_PINGPANG_SEL_MODE);
-		kendryte_layer_set_uv_swap(vop, OSD1, 1);
-		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD1);
-		kendryte_vo_osd_set_format(vop, OSD1, vop_plane_state->format);
-		kendryte_set_layer_postion(vop, OSD1, actual_h, actual_w, dest->y1, dest->x1, mode);
-		kendryte_set_layer_stride(vop, OSD1, (actual_w * 4) / 8);
-		kendryte_set_osd_addr(vop, OSD1, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst);
-	}
-
-	if(plane->base.id == vop->layer[6].layer_id)
-	{
-		//osd2 argb
-		writel(0x100, vop->base + VO_LAYER6_PINGPANG_SEL_MODE);
-		kendryte_layer_set_uv_swap(vop, OSD2, 1);
-		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD2);
-		kendryte_vo_osd_set_format(vop, OSD2, vop_plane_state->format);
-		kendryte_set_layer_postion(vop, OSD2, actual_h, actual_w, dest->y1, dest->x1, mode);
-		kendryte_set_layer_stride(vop, OSD2, (actual_w * 4) / 8);
-		kendryte_set_osd_addr(vop, OSD2, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst, vop_plane_state->yrgb_mst);
-	}
-}
-
-
-static void kendryte_layer_atomic_disable(struct drm_plane *plane,
-					       struct drm_plane_state *old_state)
-{
-	struct kendryte_layer_state *layer_state = state_to_kendryte_layer_state(old_state);
-	struct kendryte_layer *layer = to_vop_layer(plane);
-	struct kendryte_vo *vo = layer->vo;
-	int i = 0;
-
-	// close all layer
-	for(i = 0; i < KENDRYTE_VO_NUM_LAYERS; i++)
-	{
-		kendryte_set_layer_enable(vo, LAYER0 + i, 0);
-	}
-}
-
-
-static enum vop_data_format vop_convert_format(uint32_t format)
-{
-	switch (format) {
-	case DRM_FORMAT_XRGB8888:
-	case DRM_FORMAT_ARGB8888:
-	case DRM_FORMAT_XBGR8888:
-	case DRM_FORMAT_ABGR8888:
-		return VOP_FMT_ARGB8888;
-	case DRM_FORMAT_RGB888:
-	case DRM_FORMAT_BGR888:
-		return VOP_FMT_RGB888;
-	case DRM_FORMAT_RGB565:
-	case DRM_FORMAT_BGR565:
-		return VOP_FMT_RGB565;
-	case DRM_FORMAT_ARGB4444:
-	case DRM_FORMAT_ABGR4444:
-	case DRM_FORMAT_RGBA4444:
-	case DRM_FORMAT_BGRA4444:
-		return VOP_FMT_ARGB4444;
-	case DRM_FORMAT_ARGB1555:
-	case DRM_FORMAT_ABGR1555:
-	case DRM_FORMAT_RGBA5551:
-		return VOP_FMT_ARGB1555;
-	case DRM_FORMAT_NV12:
-		return VOP_FMT_YUV420SP;
-	case DRM_FORMAT_NV16:
-		return VOP_FMT_YUV422SP;
-	case DRM_FORMAT_NV24:
-		return VOP_FMT_YUV444SP;
-	case DRM_FORMAT_YUYV:
-		return VOP_FMT_YUYV;
-	
-	default:
-		DRM_ERROR("unsupported format[%08x]\n", format);
-		return -EINVAL;
-	}
-}
-
-
-static int kendryte_plane_atomic_check(struct drm_plane *plane,
-                           struct drm_plane_state *state)
-{       
-
-	struct drm_crtc *crtc = state->crtc;
-	struct drm_crtc_state *crtc_state;
-	struct drm_framebuffer *fb = state->fb;
-	struct kendryte_vo *vop;
-	struct kendryte_layer *layer = to_vop_layer(plane);
-	struct kendryte_layer_state *vop_plane_state = state_to_kendryte_layer_state(state);
-	struct drm_rect *dest = &vop_plane_state->dest;
-	struct drm_rect *src = &vop_plane_state->src;
-	int ret;
-	unsigned long offset;
-	u64 paddr ;
-	struct drm_gem_cma_object *obj ;//= drm_fb_cma_get_gem_obj(fb, 0);
-	struct drm_mode_object *mode_obj = &plane->base;
-	if(fb != NULL)
-	{
-		obj = drm_fb_cma_get_gem_obj(fb, 0);
-	}
-    paddr = obj->paddr;
-
-	crtc = crtc ? crtc : plane->state->crtc;
-
-	if (!crtc || !fb) {
-		layer->status = 0;
-		plane->state->visible = false;
-		return 0;
-	}
-	
-	layer->status = 1;	
-
-	crtc_state = drm_atomic_get_existing_crtc_state(state->state, crtc);
-	if (WARN_ON(!crtc_state))
-		return -EINVAL;
-	
-	src->x1 = state->src_x;
-	src->y1 = state->src_y;
-	src->x2 = state->src_x + state->src_w;
-	src->y2 = state->src_y + state->src_h;
-	dest->x1 = state->crtc_x;
-	dest->y1 = state->crtc_y;
-	dest->x2 = state->crtc_x + state->crtc_w;
-	dest->y2 = state->crtc_y + state->crtc_h;
-
-#if 0
-	// scale operate 
-	ret = drm_atomic_helper_check_plane_state(state, crtc_state,
-						  min_scale, max_scale,
-						  false, false);
-	if (ret)
-		return ret;
-#endif
-
-	vop_plane_state->format = vop_convert_format(fb->format->format);
-	if (vop_plane_state->format < 0)
-		return vop_plane_state->format;
-
-
-	//printk("vop_plane_state->format is %d \n", vop_plane_state->format);
-
-	vop = to_vop(crtc);
-	
-#if 0
-	if (drm_rect_width(src) >> 16 > vop_data->max_input.width ||
-	    drm_rect_height(src) >> 16 > vop_data->max_input.height) {
-		DRM_ERROR("Invalid source: %dx%d. max input: %dx%d\n",
-			  drm_rect_width(src) >> 16,
-			  drm_rect_height(src) >> 16,
-			  vop_data->max_input.width,
-			  vop_data->max_input.height);
-		return -EINVAL;
-	}
-#endif
-
-	// argb  srgb only y
-	vop_plane_state->yrgb_mst = paddr;
-
-	if (vop_plane_state->format == VOP_FMT_YUV420SP) 
-	{
-
-		int hsub = state->crtc_w;
-		int vsub = state->crtc_h;
-
-		layer->stride = fb->pitches[0];
-
-		// 420 
-		vop_plane_state->yrgb_mst = paddr;
-		vop_plane_state->uv_mst = (layer->stride * vsub) + paddr;   // stride ???
-
-	}	
-	return 0;
-}
-
-
-static int kendryte_plane_prepare_fb(struct drm_plane *plane,
-				struct drm_plane_state *new_state)
-{
-
-	if (plane->state->fb)
-		drm_framebuffer_get(plane->state->fb);
-
-	return 0;
-}
-
-
-static void kendryte_plane_cleanup_fb(struct drm_plane *plane, struct drm_plane_state *old_state)
-{
-	if (old_state->fb)
-	{
-		drm_framebuffer_put(old_state->fb);
-	}
-											
-}
-
-static const struct drm_plane_helper_funcs kendryte_layer_helper_funcs = {
-	.prepare_fb	= kendryte_plane_prepare_fb,
-	.atomic_check   = kendryte_plane_atomic_check,
-    	.atomic_update	= kendryte_plane_atomic_update,
-	.atomic_disable	= kendryte_layer_atomic_disable,
-	.cleanup_fb     = kendryte_plane_cleanup_fb,
-};
-
-
-
-static bool kendryte_crtc_mode_fixup(struct drm_crtc *crtc,
-				const struct drm_display_mode *mode,
-				struct drm_display_mode *adj_mode)
-{
-	struct kendryte_vo *vop = to_vop(crtc);
-
-    //printk("vop_crtc_mode_fixup start \n");
-#if 0 
-	const struct vop_data *vop_data = vop->data;
-
-	//printk("vop_crtc_mode_fixup start \n");
-	if (mode->hdisplay > vop_data->max_output.width)
-		return false;
-
-	drm_mode_set_crtcinfo(adj_mode,
-			      CRTC_INTERLACE_HALVE_V | CRTC_STEREO_DOUBLE);
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		adj_mode->crtc_clock *= 2;
-
-	adj_mode->crtc_clock =
-		DIV_ROUND_UP(clk_round_rate(vop->dclk, adj_mode->crtc_clock * 1000),
-			     1000);
-#endif
-
-	return true;
-}
-
-static int kendryte_crtc_atomic_check(struct drm_crtc *crtc,
-				 struct drm_crtc_state *crtc_state)
-{
-	struct drm_atomic_state *state = crtc_state->state;
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc_state);
-	struct kendryte_vo *vop = to_vop(crtc);
-//	const struct vop_data *vop_data = vop->data;
-	struct drm_plane *plane;
-	struct drm_plane_state *pstate;
-	struct kendryte_layer_state *plane_state;
-	struct vop_zpos *pzpos;
-	int dsp_layer_sel = 0;
-	int i, j, cnt = 0, ret = 0;
-
-
-
-	return ret;
-}
-
-
-static void kendryte_crtc_atomic_enable(struct drm_crtc *crtc,
-				   struct drm_crtc_state *old_state)
-{
-	struct kendryte_vo *vop = to_vop(crtc);
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
-	struct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;
-	u16 hsync_len = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;
-	u16 hdisplay = adjusted_mode->crtc_hdisplay;
-	u16 htotal = adjusted_mode->crtc_htotal;
-	u16 hact_st = adjusted_mode->crtc_htotal - adjusted_mode->crtc_hsync_start;
-	u16 hact_end = hact_st + hdisplay;
-	u16 vdisplay = adjusted_mode->crtc_vdisplay;
-	u16 vtotal = adjusted_mode->crtc_vtotal;
-	u16 vsync_len = adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;
-	u16 vact_st = adjusted_mode->crtc_vtotal - adjusted_mode->crtc_vsync_start;
-	u16 vact_end = vact_st + vdisplay;
-//	int sys_status = drm_crtc_index(crtc) ? SYS_STATUS_LCDC1 : SYS_STATUS_LCDC0;
-				
-	uint32_t val;
-	int act_end;
-	bool interlaced = !!(adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE);
-	int for_ddr_freq = 0;
-	bool dclk_inv;
-
-	printk("***###***********************************vop_crtc_atomic_enable start ---------------- \n");
-    kendryte_vo_set_mode(vop, adjusted_mode);
-
-#if 0 
-	rockchip_set_system_status(sys_status);
-
-    
-	vop_lock(vop);
-	DRM_DEV_INFO(vop->dev, "Update mode to %dx%d%s%d, type: %d\n",
-		     hdisplay, vdisplay, interlaced ? "i" : "p",
-		     adjusted_mode->vrefresh, s->output_type);
-	vop_initial(crtc);
-	vop_disable_allwin(vop);
-	VOP_CTRL_SET(vop, standby, 0);
-	s->mode_update = vop_crtc_mode_update(crtc);
-	if (s->mode_update)
-		vop_disable_all_planes(vop);
-	/*
-	 * restore the lut table.
-	 */
-	if (vop->lut_active)
-		vop_crtc_load_lut(crtc);
-
-	if (vop->mcu_timing.mcu_pix_total)
-		vop_mcu_mode(crtc);
-
-	dclk_inv = (s->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
-
-	VOP_CTRL_SET(vop, dclk_pol, dclk_inv);
-	val = (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC) ?
-		   0 : BIT(HSYNC_POSITIVE);
-	val |= (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC) ?
-		   0 : BIT(VSYNC_POSITIVE);
-	VOP_CTRL_SET(vop, pin_pol, val);
-
-	if (vop->dclk_source && vop->pll && vop->pll->pll) {
-		if (clk_set_parent(vop->dclk_source, vop->pll->pll))
-			DRM_DEV_ERROR(vop->dev,
-				      "failed to set dclk's parents\n");
-	}
-
-	switch (s->output_type) {
-	case DRM_MODE_CONNECTOR_DPI:
-	case DRM_MODE_CONNECTOR_LVDS:
-		//output LVDS
-
-		break;
-	case DRM_MODE_CONNECTOR_eDP:
-		//opt put ePD
-
-
-		break;
-	case DRM_MODE_CONNECTOR_HDMIA:
-        //output hdmi
-
-
-		break;
-	case DRM_MODE_CONNECTOR_DSI:
-		VOP_CTRL_SET(vop, mipi_en, 1);
-		VOP_CTRL_SET(vop, mipi_pin_pol, val);
-		VOP_CTRL_SET(vop, mipi_dclk_pol, dclk_inv);
-		VOP_CTRL_SET(vop, mipi_dual_channel_en,
-			!!(s->output_flags & ROCKCHIP_OUTPUT_DSI_DUAL_CHANNEL));
-		VOP_CTRL_SET(vop, data01_swap,
-			!!(s->output_flags & ROCKCHIP_OUTPUT_DSI_DUAL_LINK) ||
-			vop->dual_channel_swap);
-		break;
-	case DRM_MODE_CONNECTOR_DisplayPort:
-		VOP_CTRL_SET(vop, dp_dclk_pol, 0);
-		VOP_CTRL_SET(vop, dp_pin_pol, val);
-		VOP_CTRL_SET(vop, dp_en, 1);
-		break;
-	case DRM_MODE_CONNECTOR_TV:
-
-
-		break;
-	default:
-		DRM_ERROR("unsupported connector_type[%d]\n", s->output_type);
-	}
-/*
-	vop_update_csc(crtc);
-	VOP_CTRL_SET(vop, htotal_pw, (htotal << 16) | hsync_len);
-	val = hact_st << 16;
-	val |= hact_end;
-	VOP_CTRL_SET(vop, hact_st_end, val);
-	VOP_CTRL_SET(vop, hpost_st_end, val);
-
-	val = vact_st << 16;
-	val |= vact_end;
-	VOP_CTRL_SET(vop, vact_st_end, val);
-	VOP_CTRL_SET(vop, vpost_st_end, val);
-
-	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {
-		u16 vact_st_f1 = vtotal + vact_st + 1;
-		u16 vact_end_f1 = vact_st_f1 + vdisplay;
-
-		val = vact_st_f1 << 16 | vact_end_f1;
-		VOP_CTRL_SET(vop, vact_st_end_f1, val);
-		VOP_CTRL_SET(vop, vpost_st_end_f1, val);
-
-		val = vtotal << 16 | (vtotal + vsync_len);
-		VOP_CTRL_SET(vop, vs_st_end_f1, val);
-		VOP_CTRL_SET(vop, dsp_interlace, 1);
-		VOP_CTRL_SET(vop, p2i_en, 1);
-		vtotal += vtotal + 1;
-		act_end = vact_end_f1;
-	} else {
-		VOP_CTRL_SET(vop, dsp_interlace, 0);
-		VOP_CTRL_SET(vop, p2i_en, 0);
-		act_end = vact_end;
-	}
-
-	if (VOP_MAJOR(vop->version) == 3 &&
-	    (VOP_MINOR(vop->version) == 2 || VOP_MINOR(vop->version) == 8))
-		for_ddr_freq = 1000;
-	VOP_INTR_SET(vop, line_flag_num[0], act_end);
-	VOP_INTR_SET(vop, line_flag_num[1],
-		     act_end - us_to_vertical_line(adjusted_mode, for_ddr_freq));
-
-	VOP_CTRL_SET(vop, vtotal_pw, vtotal << 16 | vsync_len);
-
-	VOP_CTRL_SET(vop, core_dclk_div,
-		     !!(adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK));
-
-	VOP_CTRL_SET(vop, win_csc_mode_sel, 1);
-
-	clk_set_rate(vop->dclk, adjusted_mode->crtc_clock * 1000);
-
-	vop_cfg_done(vop);
-*/
-	drm_crtc_vblank_on(crtc);
-
-//	vop_unlock(vop);
-#endif
-}
-
-
-static void kendryte_crtc_atomic_disable(struct drm_crtc *crtc,
-				    struct drm_crtc_state *old_state)
-{
-	struct kendryte_vo *vop = to_vop(crtc);
-//	int sys_status = drm_crtc_index(crtc) ? SYS_STATUS_LCDC1 : SYS_STATUS_LCDC0;
-				
-
-#if 0 
-	vop_lock(vop);
-	VOP_CTRL_SET(vop, reg_done_frm, 1);
-	VOP_CTRL_SET(vop, dsp_interlace, 0);
-	drm_crtc_vblank_off(crtc);
-	VOP_CTRL_SET(vop, afbdc_en, 0);
-	vop_disable_all_planes(vop);
-
-	/*
-	 * Vop standby will take effect at end of current frame,
-	 * if dsp hold valid irq happen, it means standby complete.
-	 *
-	 * we must wait standby complete when we want to disable aclk,
-	 * if not, memory bus maybe dead.
-	 */
-	reinit_completion(&vop->dsp_hold_completion);
-	vop_dsp_hold_valid_irq_enable(vop);
-
-	spin_lock(&vop->reg_lock);
-
-	VOP_CTRL_SET(vop, standby, 1);
-
-	spin_unlock(&vop->reg_lock);
-
-	WARN_ON(!wait_for_completion_timeout(&vop->dsp_hold_completion,
-					     msecs_to_jiffies(50)));
-
-	vop_dsp_hold_valid_irq_disable(vop);
-
-	vop->is_enabled = false;
-	if (vop->is_iommu_enabled) {
-		/*
-		 * vop standby complete, so iommu detach is safe.
-		 */
-		VOP_CTRL_SET(vop, dma_stop, 1);
-		rockchip_drm_dma_detach_device(vop->drm_dev, vop->dev);
-		vop->is_iommu_enabled = false;
-	}
-
-	pm_runtime_put_sync(vop->dev);
-	clk_disable_unprepare(vop->dclk);
-	clk_disable_unprepare(vop->aclk);
-	clk_disable_unprepare(vop->hclk);
-	vop_unlock(vop);
-
-	rockchip_clear_system_status(sys_status);
-#endif
-	if (crtc->state->event && !crtc->state->active) {
-		spin_lock_irq(&crtc->dev->event_lock);
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
-		spin_unlock_irq(&crtc->dev->event_lock);
-
-		crtc->state->event = NULL;
-	}
-
-}
-
-void kendryte_vop_cfg_updata(struct kendryte_vo *vop)
-{
-	int i = 0;
-	for(i =0 ; i < KENDRYTE_VO_NUM_LAYERS; i++)
-	{
-		kendryte_set_layer_enable(vop, i + LAYER0 , vop->layer[i].status);
-	}
-}
-
-
-static void kendryte_crtc_atomic_flush(struct drm_crtc *crtc,
-				  struct drm_crtc_state *old_crtc_state)
-{
-	struct drm_atomic_state *old_state = old_crtc_state->state;
-	struct drm_plane_state *old_plane_state;
-	struct kendryte_vo *vop = to_vop(crtc);
-	struct drm_plane *plane;
-	int i;
-	unsigned long flags;
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
-		
-	kendryte_vop_cfg_updata(vop);
-
-//	kendryte_vo_get_reg_val(vop);
-
-	kendryte_vo_set_config_done(vop);
-
-	spin_lock_irq(&crtc->dev->event_lock);
-	if (crtc->state->event) {
-		// vblank enable
-		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
-		WARN_ON(vop->event);
-
-		vop->event = crtc->state->event;
-		crtc->state->event = NULL;
-	}
-	spin_unlock_irq(&crtc->dev->event_lock);
-
-
-#if 0
-	for_each_plane_in_state(old_state, plane, old_plane_state, i) {
-		if (!old_plane_state->fb)
-			continue;
-
-		if (old_plane_state->fb == plane->state->fb)
-			continue;
-
-		drm_framebuffer_get(old_plane_state->fb);
-		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
-		drm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);
-		set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
-	}
-#else
-	for_each_old_plane_in_state(old_state, plane, old_plane_state, i) {
-		if (!old_plane_state->fb)
-			continue;
-
-		if (old_plane_state->fb == plane->state->fb)
-			continue;
-
-		drm_framebuffer_get(old_plane_state->fb);
-		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
-		drm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);
-		set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
-	}
-#endif
-
-}
-
-
-static const struct drm_crtc_helper_funcs kendryte_crtc_helper_funcs = {
-    .mode_fixup = kendryte_crtc_mode_fixup,
-	.atomic_check = kendryte_crtc_atomic_check,
-	.atomic_flush = kendryte_crtc_atomic_flush,
-	.atomic_enable = kendryte_crtc_atomic_enable,
-	.atomic_disable = kendryte_crtc_atomic_disable,
-};
-
-
-
-static int kendryte_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,
-			       u16 *blue, uint32_t size,
-			       struct drm_modeset_acquire_ctx *ctx)
-{
-
-    printk("kendryte_crtc_gamma_set \n");
-#if 0 
-	struct vop *vop = to_vop(crtc);
-	int len = min(size, vop->lut_len);
-	int i;
-
-	if (!vop->lut)
-		return -EINVAL;
-
-	for (i = 0; i < len; i++)
-		rockchip_vop_crtc_fb_gamma_set(crtc, red[i], green[i],
-					       blue[i], i);
-
-	vop_crtc_load_lut(crtc);
-
-#endif
-	return 0;
-}
-
-static void kendryte_crtc_destroy(struct drm_crtc *crtc)
-{
-	drm_crtc_cleanup(crtc);
-}
-
-
-static void kendryte_crtc_reset(struct drm_crtc *crtc)
-{
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
-
-	if (crtc->state) {
-		__drm_atomic_helper_crtc_destroy_state(crtc->state);
-		kfree(s);
-	}
-
-	s = kzalloc(sizeof(*s), GFP_KERNEL);
-	if (!s)
-		return;
-	crtc->state = &s->base;
-	crtc->state->crtc = crtc;
-
-	s->left_margin = 100;
-	s->right_margin = 100;
-	s->top_margin = 100;
-	s->bottom_margin = 100;
-}
-
-static int kendryte_crtc_atomic_get_property(struct drm_crtc *crtc,
-					const struct drm_crtc_state *state,
-					struct drm_property *property,
-					uint64_t *val)
-{
-	struct drm_device *drm_dev = crtc->dev;
-	struct kendryte_drm_private *private = drm_dev->dev_private;
-	struct drm_mode_config *mode_config = &drm_dev->mode_config;
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
-	struct kendryte_vo *vop = to_vop(crtc);
-
-	if (property == mode_config->tv_left_margin_property) {
-		*val = s->left_margin;
-		return 0;
-	}
-
-	if (property == mode_config->tv_right_margin_property) {
-		*val = s->right_margin;
-		return 0;
-	}
-
-	if (property == mode_config->tv_top_margin_property) {
-		*val = s->top_margin;
-		return 0;
-	}
-
-	if (property == mode_config->tv_bottom_margin_property) {
-		*val = s->bottom_margin;
-		return 0;
-	}
-/*
-	if (property == private->alpha_scale_prop) {
-		*val = (vop->data->feature & VOP_FEATURE_ALPHA_SCALE) ? 1 : 0;
-		return 0;
-	}
-*/
-	DRM_ERROR("failed to get vop crtc property\n");
-	return -EINVAL;
-}
-
-
-static int kendryte_crtc_atomic_set_property(struct drm_crtc *crtc,
-					struct drm_crtc_state *state,
-					struct drm_property *property,
-					uint64_t val)
-{
-	struct drm_device *drm_dev = crtc->dev;
-	struct drm_mode_config *mode_config = &drm_dev->mode_config;
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
-	//struct vop *vop = to_vop(crtc);
-
-	if (property == mode_config->tv_left_margin_property) {
-		s->left_margin = val;
-		return 0;
-	}
-
-	if (property == mode_config->tv_right_margin_property) {
-		s->right_margin = val;
-		return 0;
-	}
-
-	if (property == mode_config->tv_top_margin_property) {
-		s->top_margin = val;
-		return 0;
-	}
-
-	if (property == mode_config->tv_bottom_margin_property) {
-		s->bottom_margin = val;
-		return 0;
-	}
-
-	DRM_ERROR("failed to set vop crtc property\n");
-	return -EINVAL;
-}
-
-static struct drm_crtc_state *kendryte_crtc_duplicate_state(struct drm_crtc *crtc)
-{
-	struct kendryte_crtc_state *kendryte_state, *old_state;
-
-//	printk("kendryte_crtc_duplicate_state ------------------ \n");
-
-	old_state = to_kendryte_crtc_state(crtc->state);
-	kendryte_state = kmemdup(old_state, sizeof(*old_state), GFP_KERNEL);
-	if (!kendryte_state)
-		return NULL;
-
-	__drm_atomic_helper_crtc_duplicate_state(crtc, &kendryte_state->base);
-
-	return &kendryte_state->base;
-}
-
-
-static void kendryte_crtc_destroy_state(struct drm_crtc *crtc,
-				   struct drm_crtc_state *state)
-{
-	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
-
-	__drm_atomic_helper_crtc_destroy_state(&s->base);
-	kfree(s);
-}
-
-
-static int kendryte_crtc_enable_vblank(struct drm_crtc *crtc)
-{
-	struct kendryte_vo * vop= to_vop(crtc);
-	unsigned long flags;
-
-	spin_lock_irqsave(&vop->irq_lock, flags);
-
-	// open vo intr
-	kendryte_vo_set_irq(vop, 1);
-
-	spin_unlock_irqrestore(&vop->irq_lock, flags);
-
-	return 0;
-}
-
-static void kendryte_crtc_disable_vblank(struct drm_crtc *crtc)
-{
-	struct kendryte_vo *vop = to_vop(crtc);
-	unsigned long flags;
-
-	spin_lock_irqsave(&vop->irq_lock, flags);
-
-	//close intr 
-	kendryte_vo_set_irq(vop, 0);
-
-	spin_unlock_irqrestore(&vop->irq_lock, flags);
-
-}
-
-
-
-
-
-static const struct drm_crtc_funcs kendryte_crtc_funcs = {
-    .gamma_set = kendryte_crtc_gamma_set,
-	.set_config = drm_atomic_helper_set_config,
-	.page_flip = drm_atomic_helper_page_flip,
-	.destroy = kendryte_crtc_destroy,
-	.reset = kendryte_crtc_reset,
-	.atomic_get_property = kendryte_crtc_atomic_get_property,
-	.atomic_set_property = kendryte_crtc_atomic_set_property,
-	.atomic_duplicate_state = kendryte_crtc_duplicate_state,
-	.atomic_destroy_state = kendryte_crtc_destroy_state,
-	.enable_vblank = kendryte_crtc_enable_vblank,
-	.disable_vblank = kendryte_crtc_disable_vblank,
-};
-
-
-static const uint32_t kendryte_layer_formats[] = {
-	DRM_FORMAT_NV12,
-	DRM_FORMAT_NV16,
-	DRM_FORMAT_NV21,
-	DRM_FORMAT_NV61,
-	DRM_FORMAT_UYVY,
-	DRM_FORMAT_VYUY,
-	DRM_FORMAT_YUV420,
-	DRM_FORMAT_YUV422,
-	DRM_FORMAT_YUYV,
-	DRM_FORMAT_YVU420,
-	DRM_FORMAT_YVU422,
-	DRM_FORMAT_YVYU,
-};
-
-static const uint32_t kendryte_osd_formats[] = {
-	DRM_FORMAT_ARGB8888,
-	DRM_FORMAT_ARGB4444,
-	DRM_FORMAT_ARGB1555,
-	DRM_FORMAT_RGBA4444,
-	DRM_FORMAT_RGB888,
-	DRM_FORMAT_RGB565,
-	DRM_FORMAT_XRGB8888,
-};
-
-
-int kendryte_create_crtc(struct kendryte_vo *vop)
-{
-
-	struct device *dev = vop->dev;
-	struct drm_device *drm_dev = vop->drm;
-	struct drm_plane *primary = NULL, *cursor = NULL, *plane, *tmp;
-	struct drm_crtc *crtc = &vop->crtc;
-	struct device_node *port;
-
-	const uint32_t *formats = kendryte_layer_formats;
-	unsigned int formats_len = ARRAY_SIZE(kendryte_layer_formats);
-
-	const uint32_t *osd_formats = kendryte_osd_formats;
-	unsigned int ods_formats_len = ARRAY_SIZE(kendryte_osd_formats);
-
-	int ret;
-	int i;
-
-	/*
-	 * Create drm_planes for overlay windows with possible_crtcs restricted
-	 * to the newly created crtc.
-	 */
-
-	for (i = 0; i < 4; i++) {
-		struct kendryte_layer *layer = &vop->layer[i];
-
-		unsigned long possible_crtcs = drm_crtc_mask(crtc);
-		if (layer->type != DRM_PLANE_TYPE_OVERLAY)
-			continue;
-
-		ret = drm_universal_plane_init(drm_dev, &layer->plane,
-					       possible_crtcs,
-					       &kendryte_layer_funcs,
-					       formats,
-					       formats_len,
-					       NULL, layer->type, NULL);
-		if (ret) {
-			DRM_DEV_ERROR(vop->dev, "failed to init overlay %d\n",
-				      ret);
-			goto err_cleanup_crtc;
-		}
-		drm_plane_helper_add(&layer->plane, &kendryte_layer_helper_funcs);
-		
-		plane = &layer->plane;
-		layer->layer_id = plane->base.id;
-		layer->status = 0;
-			
-	}
-	
-	for (i = 0; i < 3; i++) {
-		struct kendryte_layer *layer = &vop->layer[i + 4];
-
-		unsigned long possible_crtcs = drm_crtc_mask(crtc);
-		if (layer->type != DRM_PLANE_TYPE_OVERLAY)
-			continue;
-
-		ret = drm_universal_plane_init(drm_dev, &layer->plane,
-					       possible_crtcs,
-					       &kendryte_layer_funcs,
-					       osd_formats,
-					       ods_formats_len,
-					       NULL, layer->type, NULL);
-		if (ret) {
-			DRM_DEV_ERROR(vop->dev, "failed to init overlay %d\n",
-				      ret);
-			goto err_cleanup_crtc;
-		}
-		drm_plane_helper_add(&layer->plane, &kendryte_layer_helper_funcs);
-		
-		plane = &layer->plane;
-		layer->layer_id = plane->base.id;
-		layer->status = 0;
-
-		// osd2 for DRM_PLANE_TYPE_PRIMARY = 1
-		if(i == 2)
-		{
-			plane->type = DRM_PLANE_TYPE_PRIMARY;
-			layer->type = DRM_PLANE_TYPE_PRIMARY;
-			primary = plane;
-		}
-			
-		// osd1 for DRM_PLANE_TYPE_CURSOR = 2
-		if(i == 1)
-		{
-			plane->type = DRM_PLANE_TYPE_CURSOR;
-			layer->type = DRM_PLANE_TYPE_CURSOR;
-			cursor = plane;
-		}	
-	}
-
-	ret = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,
-					&kendryte_crtc_funcs, NULL);
-	if (ret)
-		goto err_cleanup_planes;
-
-	drm_crtc_helper_add(crtc, &kendryte_crtc_helper_funcs);
-
-	port = of_get_child_by_name(dev->of_node, "port");
-	if (!port) {
-		DRM_DEV_ERROR(vop->dev, "no port node found in %pOF\n",
-			      dev->of_node);
-		ret = -ENOENT;
-		goto err_cleanup_crtc;
-	}
-
-	crtc->port = port;
-
-	return 0;
-err_cleanup_crtc:
-	drm_crtc_cleanup(crtc);
-err_cleanup_planes:
-
-	drm_plane_cleanup(plane);
-	return ret;
-}
-
+#include <drm/drm.h>
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fourcc.h>
+
+#include <drm/drm_flip_work.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+
+#ifdef CONFIG_DRM_ANALOGIX_DP
+#include <drm/bridge/analogix_dp.h>
+#endif
+
+#include <linux/debugfs.h>
+#include <linux/fixp-arith.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/component.h>
+#include <linux/overflow.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#include <linux/reset.h>
+#include <linux/delay.h>
+#include <linux/sort.h>
+
+#include <uapi/linux/videodev2.h>
+
+#include "kendryte_layer.h"
+#include "kendryte_vo.h"
+
+static int __maybe_unused kendryte_atomic_helper_update_plane(
+	struct drm_plane *plane, struct drm_crtc *crtc,
+	struct drm_framebuffer *fb, int crtc_x, int crtc_y, unsigned int crtc_w,
+	unsigned int crtc_h, uint32_t src_x, uint32_t src_y, uint32_t src_w,
+	uint32_t src_h, struct drm_modeset_acquire_ctx *ctx)
+{
+	struct drm_atomic_state *state;
+	struct drm_plane_state *plane_state;
+	struct kendryte_layer_state *vop_plane_state;
+	int ret = 0;
+
+	//printk("rockchip_atomic_helper_update_plane start \n");
+	state = drm_atomic_state_alloc(plane->dev);
+	if (!state)
+		return -ENOMEM;
+
+	state->acquire_ctx = ctx;
+	plane_state = drm_atomic_get_plane_state(state, plane);
+	if (IS_ERR(plane_state)) {
+		ret = PTR_ERR(plane_state);
+		goto fail;
+	}
+
+	vop_plane_state = state_to_kendryte_layer_state(plane_state);
+
+	ret = drm_atomic_set_crtc_for_plane(plane_state, crtc);
+	if (ret != 0)
+		goto fail;
+
+	drm_atomic_set_fb_for_plane(plane_state, fb);
+	plane_state->crtc_x = crtc_x;
+	plane_state->crtc_y = crtc_y;
+	plane_state->crtc_w = crtc_w;
+	plane_state->crtc_h = crtc_h;
+	plane_state->src_x = src_x;
+	plane_state->src_y = src_y;
+	plane_state->src_w = src_w;
+	plane_state->src_h = src_h;
+
+	ret = drm_atomic_commit(state);
+fail:
+	drm_atomic_state_put(state);
+	return ret;
+}
+
+/**
+ * drm_atomic_helper_disable_plane copy from drm_atomic_helper_disable_plane
+ * be designed to support async commit at ioctl DRM_IOCTL_MODE_SETPLANE.
+ *
+ * @plane: plane to disable
+ * @ctx: lock acquire context
+ *
+ * Provides a default plane disable handler using the atomic driver interface.
+ *
+ * RETURNS:
+ * Zero on success, error code on failure
+ */
+static int __maybe_unused kendryte_atomic_helper_disable_plane(
+	struct drm_plane *plane, struct drm_modeset_acquire_ctx *ctx)
+{
+	struct drm_atomic_state *state;
+	struct drm_plane_state *plane_state;
+	struct kendryte_layer_state *vop_plane_state;
+	int ret = 0;
+
+	state = drm_atomic_state_alloc(plane->dev);
+	if (!state)
+		return -ENOMEM;
+
+	state->acquire_ctx = ctx;
+	plane_state = drm_atomic_get_plane_state(state, plane);
+	if (IS_ERR(plane_state)) {
+		ret = PTR_ERR(plane_state);
+		goto fail;
+	}
+	vop_plane_state = state_to_kendryte_layer_state(plane_state);
+
+	if ((plane_state->crtc && plane_state->crtc->cursor == plane) ||
+	    vop_plane_state->async_commit)
+		plane_state->state->legacy_cursor_update = true;
+
+	/*
+	ret = __drm_atomic_helper_disable_plane(plane, plane_state);
+	if (ret != 0)
+		goto fail;
+*/
+	ret = drm_atomic_commit(state);
+fail:
+	drm_atomic_state_put(state);
+	return ret;
+}
+
+static void kendryte_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_cleanup(plane);
+}
+
+static void kendryte_destroy_crtc(struct kendryte_vo *vop)
+{
+	struct drm_crtc *crtc = &vop->crtc;
+	struct drm_device *drm_dev = vop->drm;
+	struct drm_plane *plane, *tmp;
+
+	of_node_put(crtc->port);
+
+	/*
+	 * We need to cleanup the planes now.  Why?
+	 *
+	 * The planes are "&vop->win[i].base".  That means the memory is
+	 * all part of the big "struct vop" chunk of memory.  That memory
+	 * was devm allocated and associated with this component.  We need to
+	 * free it ourselves before vop_unbind() finishes.
+	 */
+	list_for_each_entry_safe (plane, tmp, &drm_dev->mode_config.plane_list,
+				  head)
+		kendryte_plane_destroy(plane);
+
+	/*
+	 * Destroy CRTC after vop_plane_destroy() since vop_disable_plane()
+	 * references the CRTC.
+	 */
+	drm_crtc_cleanup(crtc);
+}
+
+static void kendryte_atomic_plane_reset(struct drm_plane *plane)
+{
+	struct kendryte_layer_state *vop_plane_state =
+		state_to_kendryte_layer_state(plane->state);
+
+	if (plane->state && plane->state->fb)
+		__drm_atomic_helper_plane_destroy_state(plane->state);
+	kfree(vop_plane_state);
+	vop_plane_state = kzalloc(sizeof(*vop_plane_state), GFP_KERNEL);
+	if (!vop_plane_state)
+		return;
+
+	vop_plane_state->global_alpha = 0xff;
+
+	plane->state = &vop_plane_state->state;
+	plane->state->plane = plane;
+}
+
+static struct drm_plane_state *
+	kendryte_atomic_plane_duplicate_state(struct drm_plane *plane)
+{
+	struct kendryte_layer_state *old_vop_plane_state;
+	struct kendryte_layer_state *vop_plane_state;
+
+	if (WARN_ON(!plane->state))
+		return NULL;
+
+	//	printk("kendryte_atomic_plane_duplicate_state \n");
+	old_vop_plane_state = state_to_kendryte_layer_state(plane->state);
+	vop_plane_state = kmemdup(old_vop_plane_state, sizeof(*vop_plane_state),
+				  GFP_KERNEL);
+	if (!vop_plane_state)
+		return NULL;
+
+	__drm_atomic_helper_plane_duplicate_state(plane,
+						  &vop_plane_state->state);
+
+	return &vop_plane_state->state;
+}
+
+static void kendryte_atomic_plane_destroy_state(struct drm_plane *plane,
+						struct drm_plane_state *state)
+{
+	struct kendryte_layer_state *vop_state =
+		state_to_kendryte_layer_state(state);
+
+	__drm_atomic_helper_plane_destroy_state(state);
+
+	kfree(vop_state);
+}
+
+static int kendryte_atomic_plane_set_property(struct drm_plane *plane,
+					      struct drm_plane_state *state,
+					      struct drm_property *property,
+					      uint64_t val)
+{
+	struct kendryte_drm_private *private = plane->dev->dev_private;
+	//	struct vop_win *win = to_vop_win(plane);
+	struct kendryte_layer_state *plane_state =
+		state_to_kendryte_layer_state(state);
+
+	/*
+	//printk("vop_atomic_plane_set_property \n");
+	if (property == win->vop->plane_zpos_prop) {
+		plane_state->zpos = val;
+		return 0;
+	}
+*/
+
+	if (property == private->eotf_prop) {
+		plane_state->eotf = val;
+		return 0;
+	}
+
+	if (property == private->color_space_prop) {
+		plane_state->color_space = val;
+		return 0;
+	}
+
+	if (property == private->global_alpha_prop) {
+		plane_state->global_alpha = val;
+		return 0;
+	}
+
+	if (property == private->blend_mode_prop) {
+		plane_state->blend_mode = val;
+		return 0;
+	}
+
+	if (property == private->async_commit_prop) {
+		plane_state->async_commit = val;
+		return 0;
+	}
+
+	DRM_ERROR("failed to set vop plane property id:%d, name:%s\n",
+		  property->base.id, property->name);
+
+	return -EINVAL;
+}
+
+static int kendryte_atomic_plane_get_property(
+	struct drm_plane *plane, const struct drm_plane_state *state,
+	struct drm_property *property, uint64_t *val)
+{
+	struct kendryte_layer_state *plane_state =
+		state_to_kendryte_layer_state(state);
+	//	struct vop_win *win = to_vop_win(plane);
+	struct kendryte_drm_private *private = plane->dev->dev_private;
+
+	//printk("vop_atomic_plane_get_property \n");
+	/*
+	if (property == win->vop->plane_zpos_prop) {
+		*val = plane_state->zpos;
+		return 0;
+	}
+*/
+
+	if (property == private->eotf_prop) {
+		*val = plane_state->eotf;
+		return 0;
+	}
+
+	if (property == private->color_space_prop) {
+		*val = plane_state->color_space;
+		return 0;
+	}
+
+	if (property == private->global_alpha_prop) {
+		*val = plane_state->global_alpha;
+		return 0;
+	}
+
+	if (property == private->blend_mode_prop) {
+		*val = plane_state->blend_mode;
+		return 0;
+	}
+
+	if (property == private->async_commit_prop) {
+		*val = plane_state->async_commit;
+		return 0;
+	}
+
+	if (property == private->share_id_prop) {
+		int i;
+		struct drm_mode_object *obj = &plane->base;
+
+		for (i = 0; i < obj->properties->count; i++) {
+			if (obj->properties->properties[i] == property) {
+				*val = obj->properties->values[i];
+				return 0;
+			}
+		}
+	}
+
+	DRM_ERROR("failed to get vop plane property id:%d, name:%s\n",
+		  property->base.id, property->name);
+
+	return -EINVAL;
+}
+
+static const struct drm_plane_funcs kendryte_layer_funcs = {
+	.update_plane = kendryte_atomic_helper_update_plane,
+	.disable_plane = kendryte_atomic_helper_disable_plane,
+	.destroy = kendryte_plane_destroy,
+	.reset = kendryte_atomic_plane_reset,
+	.atomic_duplicate_state = kendryte_atomic_plane_duplicate_state,
+	.atomic_destroy_state = kendryte_atomic_plane_destroy_state,
+	.atomic_set_property = kendryte_atomic_plane_set_property,
+	.atomic_get_property = kendryte_atomic_plane_get_property,
+};
+
+static void kendryte_plane_atomic_disable(struct drm_plane *plane,
+					  struct drm_plane_state *old_state)
+{
+	struct kendryte_layer *win = to_vop_layer(plane);
+	struct kendryte_vo *vop = to_vop(old_state->crtc);
+#if defined(CONFIG_ROCKCHIP_DRM_DEBUG)
+	struct vop_plane_state *vop_plane_state =
+		to_vop_plane_state(plane->state);
+#endif
+
+	if (!old_state->crtc)
+		return;
+
+#if 0 
+	spin_lock(&vop->reg_lock);
+
+	vop_win_disable(vop, win);
+
+	/*
+	 * IC design bug: in the bandwidth tension environment when close win2,
+	 * vop will access the freed memory lead to iommu pagefault.
+	 * so we add this reset to workaround.
+	 */
+	if (VOP_MAJOR(vop->version) == 2 && VOP_MINOR(vop->version) == 5 &&
+	    win->win_id == 2)
+		VOP_WIN_SET(vop, win, yrgb_mst, 0);
+
+
+	spin_unlock(&vop->reg_lock);
+#endif
+}
+
+static void kendryte_plane_atomic_update(struct drm_plane *plane,
+					 struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+	struct drm_crtc *crtc = state->crtc;
+	struct drm_display_mode *mode = NULL;
+	struct kendryte_layer *layer = to_vop_layer(plane);
+	struct kendryte_layer_state *vop_plane_state =
+		state_to_kendryte_layer_state(state);
+	struct kendryte_vo *vop = to_vop(state->crtc);
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_rect *src = &vop_plane_state->src;
+	struct drm_rect *dest = &vop_plane_state->dest;
+	uint32_t stride;
+
+	if (fb == NULL)
+		return;
+
+	/*
+	 * can't update plane when vop is disabled.
+	 */
+	if (WARN_ON(!crtc))
+		return;
+
+	mode = &crtc->state->adjusted_mode;
+	stride = ((state->src_h) & 0xFFFF0000) - 0x10000;
+
+	if (plane->base.id == vop->layer[0].layer_id) {
+		// config yuv1
+		writel(0x11, vop->base + VO_LAYER0_PINGPANG_SEL_MODE);
+		kendryte_set_layer_uv_endian(vop, LAYER0,
+					     VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
+		kendryte_set_video_layer_postion(vop, LAYER0, src, dest, mode);
+		stride += (vop->layer[0].stride / 8 - 1);
+		kendryte_set_layer_stride(vop, LAYER0, stride);
+		kendryte_set_layer_addr(vop, LAYER0, vop_plane_state->yrgb_mst,
+					vop_plane_state->yrgb_mst,
+					vop_plane_state->uv_mst,
+					vop_plane_state->uv_mst);
+	} else if (plane->base.id == vop->layer[1].layer_id) {
+		// config yuv1
+		writel(0x11, vop->base + VO_LAYER1_PINGPANG_SEL_MODE);
+		kendryte_set_layer_uv_endian(vop, LAYER1,
+					     VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
+		kendryte_layer_set_uv_swap(vop, LAYER1, 0);
+		kendryte_set_video_layer_postion(vop, LAYER1, src, dest, mode);
+		stride += (vop->layer[1].stride / 8 - 1);
+		kendryte_set_layer_stride(vop, LAYER1, stride);
+		kendryte_set_layer_addr(vop, LAYER1, vop_plane_state->yrgb_mst,
+					vop_plane_state->yrgb_mst,
+					vop_plane_state->uv_mst,
+					vop_plane_state->uv_mst);
+	} else if (plane->base.id == vop->layer[2].layer_id) {
+		// config yuv2
+		writel(0x11, vop->base + VO_LAYER2_PINGPANG_SEL_MODE);
+		kendryte_set_layer_uv_endian(vop, LAYER2,
+					     VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
+		kendryte_layer_set_uv_swap(vop, LAYER2, 0);
+		kendryte_set_video_layer_postion(vop, LAYER2, src, dest, mode);
+		stride += (vop->layer[2].stride / 8 - 1);
+		kendryte_set_layer_stride(vop, LAYER2, stride);
+		kendryte_set_layer_addr(vop, LAYER2, vop_plane_state->yrgb_mst,
+					vop_plane_state->yrgb_mst,
+					vop_plane_state->uv_mst,
+					vop_plane_state->uv_mst);
+	} else if (plane->base.id == vop->layer[3].layer_id) {
+		// config yuv3
+		writel(0x11, vop->base + VO_LAYER3_PINGPANG_SEL_MODE);
+		kendryte_set_layer_uv_endian(vop, LAYER3,
+					     VO_VIDEO_LAYER_UV_ENDIAN_MODE3);
+		kendryte_layer_set_uv_swap(vop, LAYER3, 0);
+		kendryte_set_video_layer_postion(vop, LAYER3, src, dest, mode);
+		stride += (vop->layer[3].stride / 8 - 1);
+		kendryte_set_layer_stride(vop, LAYER3, stride);
+		kendryte_set_layer_addr(vop, LAYER3, vop_plane_state->yrgb_mst,
+					vop_plane_state->yrgb_mst,
+					vop_plane_state->uv_mst,
+					vop_plane_state->uv_mst);
+	} else if (plane->base.id == vop->layer[4].layer_id) {
+		// osd0 argb
+		writel(0x100, vop->base + VO_LAYER4_PINGPANG_SEL_MODE);
+		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD0);
+		kendryte_layer_set_uv_swap(vop, OSD0, 1);
+		kendryte_vo_osd_set_format(vop, OSD0, vop_plane_state->format);
+		kendryte_set_layer_postion(vop, OSD0, state->src_h >> 16,
+					   state->src_w >> 16, dest->y1,
+					   dest->x1, mode);
+		stride = vop->layer[4].stride / 8;
+		kendryte_set_layer_stride(vop, OSD0, stride);
+		kendryte_set_osd_addr(vop, OSD0, vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst);
+	} else if (plane->base.id == vop->layer[5].layer_id) {
+		// osd1 argb
+		writel(0x100, vop->base + VO_LAYER5_PINGPANG_SEL_MODE);
+		kendryte_layer_set_uv_swap(vop, OSD1, 1);
+		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD1);
+		kendryte_vo_osd_set_format(vop, OSD1, vop_plane_state->format);
+		kendryte_set_layer_postion(vop, OSD1, state->src_h >> 16,
+					   state->src_w >> 16, dest->y1,
+					   dest->x1, mode);
+		stride = vop->layer[5].stride / 8;
+		kendryte_set_layer_stride(vop, OSD1, stride);
+		kendryte_set_osd_addr(vop, OSD1, vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst);
+	} else if (plane->base.id == vop->layer[6].layer_id) {
+		//osd2 argb
+		writel(0x100, vop->base + VO_LAYER6_PINGPANG_SEL_MODE);
+		kendryte_layer_set_uv_swap(vop, OSD2, 1);
+		kendryte_vo_osd_set_rgb2yuv_enable(vop, OSD2);
+		kendryte_vo_osd_set_format(vop, OSD2, vop_plane_state->format);
+		kendryte_set_layer_postion(vop, OSD2, state->src_h >> 16,
+					   state->src_w >> 16, dest->y1,
+					   dest->x1, mode);
+		stride = vop->layer[6].stride / 8;
+		kendryte_set_layer_stride(vop, OSD2, stride);
+		kendryte_set_osd_addr(vop, OSD2, vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst,
+				      vop_plane_state->yrgb_mst);
+	}
+}
+
+static void kendryte_layer_atomic_disable(struct drm_plane *plane,
+					  struct drm_plane_state *old_state)
+{
+	struct kendryte_layer_state *layer_state =
+		state_to_kendryte_layer_state(old_state);
+	struct kendryte_layer *layer = to_vop_layer(plane);
+	struct kendryte_vo *vo = layer->vo;
+	int i = 0;
+
+	// close all layer
+	for (i = 0; i < KENDRYTE_VO_NUM_LAYERS; i++) {
+		kendryte_set_layer_enable(vo, LAYER0 + i, 0);
+	}
+}
+
+static enum vop_data_format vop_convert_format(uint32_t format)
+{
+	switch (format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		return VOP_FMT_ARGB8888;
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+		return VOP_FMT_RGB888;
+	case DRM_FORMAT_RGB565:
+	case DRM_FORMAT_BGR565:
+		return VOP_FMT_RGB565;
+	case DRM_FORMAT_ARGB4444:
+	case DRM_FORMAT_ABGR4444:
+	case DRM_FORMAT_RGBA4444:
+	case DRM_FORMAT_BGRA4444:
+		return VOP_FMT_ARGB4444;
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_RGBA5551:
+		return VOP_FMT_ARGB1555;
+	case DRM_FORMAT_NV12:
+		return VOP_FMT_YUV420SP;
+	case DRM_FORMAT_NV16:
+		return VOP_FMT_YUV422SP;
+	case DRM_FORMAT_NV24:
+		return VOP_FMT_YUV444SP;
+	case DRM_FORMAT_YUYV:
+		return VOP_FMT_YUYV;
+
+	default:
+		DRM_ERROR("unsupported format[%08x]\n", format);
+		return -EINVAL;
+	}
+}
+
+static int kendryte_plane_atomic_check(struct drm_plane *plane,
+				       struct drm_plane_state *state)
+{
+	struct drm_crtc *crtc = state->crtc;
+	struct drm_crtc_state *crtc_state;
+	struct drm_framebuffer *fb = state->fb;
+	struct kendryte_vo *vop;
+	struct kendryte_layer *layer = to_vop_layer(plane);
+	struct kendryte_layer_state *vop_plane_state =
+		state_to_kendryte_layer_state(state);
+	struct drm_rect *dest = &vop_plane_state->dest;
+	struct drm_rect *src = &vop_plane_state->src;
+	int ret;
+	unsigned long offset;
+	u64 paddr;
+	struct drm_gem_cma_object *obj; //= drm_fb_cma_get_gem_obj(fb, 0);
+	struct drm_mode_object *mode_obj = &plane->base;
+	if (fb != NULL) {
+		obj = drm_fb_cma_get_gem_obj(fb, 0);
+	}
+	paddr = obj->paddr;
+
+	crtc = crtc ? crtc : plane->state->crtc;
+
+	if (!crtc || !fb) {
+		layer->status = 0;
+		plane->state->visible = false;
+		return 0;
+	}
+
+	layer->status = 1;
+
+	crtc_state = drm_atomic_get_existing_crtc_state(state->state, crtc);
+	if (WARN_ON(!crtc_state))
+		return -EINVAL;
+
+	src->x1 = state->src_x;
+	src->y1 = state->src_y;
+	src->x2 = state->src_x + state->src_w;
+	src->y2 = state->src_y + state->src_h;
+	dest->x1 = state->crtc_x;
+	dest->y1 = state->crtc_y;
+	dest->x2 = state->crtc_x + state->crtc_w;
+	dest->y2 = state->crtc_y + state->crtc_h;
+
+#if 0
+	// scale operate 
+	ret = drm_atomic_helper_check_plane_state(state, crtc_state,
+						  min_scale, max_scale,
+						  false, false);
+	if (ret)
+		return ret;
+#endif
+
+	vop_plane_state->format = vop_convert_format(fb->format->format);
+	if (vop_plane_state->format < 0)
+		return vop_plane_state->format;
+
+		//printk("vop_plane_state->format is %d \n", vop_plane_state->format);
+
+#if 0
+	if (drm_rect_width(src) >> 16 > vop_data->max_input.width ||
+	    drm_rect_height(src) >> 16 > vop_data->max_input.height) {
+		DRM_ERROR("Invalid source: %dx%d. max input: %dx%d\n",
+			  drm_rect_width(src) >> 16,
+			  drm_rect_height(src) >> 16,
+			  vop_data->max_input.width,
+			  vop_data->max_input.height);
+		return -EINVAL;
+	}
+#endif
+
+	// argb  srgb only y
+	vop_plane_state->yrgb_mst = paddr;
+	layer->stride = fb->pitches[0];
+	if (vop_plane_state->format == VOP_FMT_YUV420SP)
+		vop_plane_state->uv_mst = fb->offsets[1] + paddr;
+	return 0;
+}
+
+static int kendryte_plane_prepare_fb(struct drm_plane *plane,
+				     struct drm_plane_state *new_state)
+{
+	if (plane->state->fb)
+		drm_framebuffer_get(plane->state->fb);
+
+	return 0;
+}
+
+static void kendryte_plane_cleanup_fb(struct drm_plane *plane,
+				      struct drm_plane_state *old_state)
+{
+	if (old_state->fb) {
+		drm_framebuffer_put(old_state->fb);
+	}
+}
+
+static const struct drm_plane_helper_funcs kendryte_layer_helper_funcs = {
+	.prepare_fb = kendryte_plane_prepare_fb,
+	.atomic_check = kendryte_plane_atomic_check,
+	.atomic_update = kendryte_plane_atomic_update,
+	.atomic_disable = kendryte_layer_atomic_disable,
+	.cleanup_fb = kendryte_plane_cleanup_fb,
+};
+
+static bool kendryte_crtc_mode_fixup(struct drm_crtc *crtc,
+				     const struct drm_display_mode *mode,
+				     struct drm_display_mode *adj_mode)
+{
+	struct kendryte_vo *vop = to_vop(crtc);
+
+	//printk("vop_crtc_mode_fixup start \n");
+#if 0 
+	const struct vop_data *vop_data = vop->data;
+
+	//printk("vop_crtc_mode_fixup start \n");
+	if (mode->hdisplay > vop_data->max_output.width)
+		return false;
+
+	drm_mode_set_crtcinfo(adj_mode,
+			      CRTC_INTERLACE_HALVE_V | CRTC_STEREO_DOUBLE);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		adj_mode->crtc_clock *= 2;
+
+	adj_mode->crtc_clock =
+		DIV_ROUND_UP(clk_round_rate(vop->dclk, adj_mode->crtc_clock * 1000),
+			     1000);
+#endif
+
+	return true;
+}
+
+static int kendryte_crtc_atomic_check(struct drm_crtc *crtc,
+				      struct drm_crtc_state *crtc_state)
+{
+	struct drm_atomic_state *state = crtc_state->state;
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc_state);
+	struct kendryte_vo *vop = to_vop(crtc);
+	//	const struct vop_data *vop_data = vop->data;
+	struct drm_plane *plane;
+	struct drm_plane_state *pstate;
+	struct kendryte_layer_state *plane_state;
+	struct vop_zpos *pzpos;
+	int dsp_layer_sel = 0;
+	int i, j, cnt = 0, ret = 0;
+
+	return ret;
+}
+
+static void kendryte_crtc_atomic_enable(struct drm_crtc *crtc,
+					struct drm_crtc_state *old_state)
+{
+	struct kendryte_vo *vop = to_vop(crtc);
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
+	struct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;
+	u16 hsync_len =
+		adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;
+	u16 hdisplay = adjusted_mode->crtc_hdisplay;
+	u16 htotal = adjusted_mode->crtc_htotal;
+	u16 hact_st =
+		adjusted_mode->crtc_htotal - adjusted_mode->crtc_hsync_start;
+	u16 hact_end = hact_st + hdisplay;
+	u16 vdisplay = adjusted_mode->crtc_vdisplay;
+	u16 vtotal = adjusted_mode->crtc_vtotal;
+	u16 vsync_len =
+		adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;
+	u16 vact_st =
+		adjusted_mode->crtc_vtotal - adjusted_mode->crtc_vsync_start;
+	u16 vact_end = vact_st + vdisplay;
+	//	int sys_status = drm_crtc_index(crtc) ? SYS_STATUS_LCDC1 : SYS_STATUS_LCDC0;
+
+	uint32_t val;
+	int act_end;
+	bool interlaced = !!(adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE);
+	int for_ddr_freq = 0;
+	bool dclk_inv;
+
+	printk("***###***********************************vop_crtc_atomic_enable start ---------------- \n");
+	kendryte_vo_set_mode(vop, adjusted_mode);
+
+#if 0 
+	rockchip_set_system_status(sys_status);
+
+    
+	vop_lock(vop);
+	DRM_DEV_INFO(vop->dev, "Update mode to %dx%d%s%d, type: %d\n",
+		     hdisplay, vdisplay, interlaced ? "i" : "p",
+		     adjusted_mode->vrefresh, s->output_type);
+	vop_initial(crtc);
+	vop_disable_allwin(vop);
+	VOP_CTRL_SET(vop, standby, 0);
+	s->mode_update = vop_crtc_mode_update(crtc);
+	if (s->mode_update)
+		vop_disable_all_planes(vop);
+	/*
+	 * restore the lut table.
+	 */
+	if (vop->lut_active)
+		vop_crtc_load_lut(crtc);
+
+	if (vop->mcu_timing.mcu_pix_total)
+		vop_mcu_mode(crtc);
+
+	dclk_inv = (s->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
+
+	VOP_CTRL_SET(vop, dclk_pol, dclk_inv);
+	val = (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC) ?
+		   0 : BIT(HSYNC_POSITIVE);
+	val |= (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC) ?
+		   0 : BIT(VSYNC_POSITIVE);
+	VOP_CTRL_SET(vop, pin_pol, val);
+
+	if (vop->dclk_source && vop->pll && vop->pll->pll) {
+		if (clk_set_parent(vop->dclk_source, vop->pll->pll))
+			DRM_DEV_ERROR(vop->dev,
+				      "failed to set dclk's parents\n");
+	}
+
+	switch (s->output_type) {
+	case DRM_MODE_CONNECTOR_DPI:
+	case DRM_MODE_CONNECTOR_LVDS:
+		//output LVDS
+
+		break;
+	case DRM_MODE_CONNECTOR_eDP:
+		//opt put ePD
+
+
+		break;
+	case DRM_MODE_CONNECTOR_HDMIA:
+        //output hdmi
+
+
+		break;
+	case DRM_MODE_CONNECTOR_DSI:
+		VOP_CTRL_SET(vop, mipi_en, 1);
+		VOP_CTRL_SET(vop, mipi_pin_pol, val);
+		VOP_CTRL_SET(vop, mipi_dclk_pol, dclk_inv);
+		VOP_CTRL_SET(vop, mipi_dual_channel_en,
+			!!(s->output_flags & ROCKCHIP_OUTPUT_DSI_DUAL_CHANNEL));
+		VOP_CTRL_SET(vop, data01_swap,
+			!!(s->output_flags & ROCKCHIP_OUTPUT_DSI_DUAL_LINK) ||
+			vop->dual_channel_swap);
+		break;
+	case DRM_MODE_CONNECTOR_DisplayPort:
+		VOP_CTRL_SET(vop, dp_dclk_pol, 0);
+		VOP_CTRL_SET(vop, dp_pin_pol, val);
+		VOP_CTRL_SET(vop, dp_en, 1);
+		break;
+	case DRM_MODE_CONNECTOR_TV:
+
+
+		break;
+	default:
+		DRM_ERROR("unsupported connector_type[%d]\n", s->output_type);
+	}
+/*
+	vop_update_csc(crtc);
+	VOP_CTRL_SET(vop, htotal_pw, (htotal << 16) | hsync_len);
+	val = hact_st << 16;
+	val |= hact_end;
+	VOP_CTRL_SET(vop, hact_st_end, val);
+	VOP_CTRL_SET(vop, hpost_st_end, val);
+
+	val = vact_st << 16;
+	val |= vact_end;
+	VOP_CTRL_SET(vop, vact_st_end, val);
+	VOP_CTRL_SET(vop, vpost_st_end, val);
+
+	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		u16 vact_st_f1 = vtotal + vact_st + 1;
+		u16 vact_end_f1 = vact_st_f1 + vdisplay;
+
+		val = vact_st_f1 << 16 | vact_end_f1;
+		VOP_CTRL_SET(vop, vact_st_end_f1, val);
+		VOP_CTRL_SET(vop, vpost_st_end_f1, val);
+
+		val = vtotal << 16 | (vtotal + vsync_len);
+		VOP_CTRL_SET(vop, vs_st_end_f1, val);
+		VOP_CTRL_SET(vop, dsp_interlace, 1);
+		VOP_CTRL_SET(vop, p2i_en, 1);
+		vtotal += vtotal + 1;
+		act_end = vact_end_f1;
+	} else {
+		VOP_CTRL_SET(vop, dsp_interlace, 0);
+		VOP_CTRL_SET(vop, p2i_en, 0);
+		act_end = vact_end;
+	}
+
+	if (VOP_MAJOR(vop->version) == 3 &&
+	    (VOP_MINOR(vop->version) == 2 || VOP_MINOR(vop->version) == 8))
+		for_ddr_freq = 1000;
+	VOP_INTR_SET(vop, line_flag_num[0], act_end);
+	VOP_INTR_SET(vop, line_flag_num[1],
+		     act_end - us_to_vertical_line(adjusted_mode, for_ddr_freq));
+
+	VOP_CTRL_SET(vop, vtotal_pw, vtotal << 16 | vsync_len);
+
+	VOP_CTRL_SET(vop, core_dclk_div,
+		     !!(adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK));
+
+	VOP_CTRL_SET(vop, win_csc_mode_sel, 1);
+
+	clk_set_rate(vop->dclk, adjusted_mode->crtc_clock * 1000);
+
+	vop_cfg_done(vop);
+*/
+	drm_crtc_vblank_on(crtc);
+
+//	vop_unlock(vop);
+#endif
+}
+
+static void kendryte_crtc_atomic_disable(struct drm_crtc *crtc,
+					 struct drm_crtc_state *old_state)
+{
+	struct kendryte_vo *vop = to_vop(crtc);
+	//	int sys_status = drm_crtc_index(crtc) ? SYS_STATUS_LCDC1 : SYS_STATUS_LCDC0;
+
+#if 0 
+	vop_lock(vop);
+	VOP_CTRL_SET(vop, reg_done_frm, 1);
+	VOP_CTRL_SET(vop, dsp_interlace, 0);
+	drm_crtc_vblank_off(crtc);
+	VOP_CTRL_SET(vop, afbdc_en, 0);
+	vop_disable_all_planes(vop);
+
+	/*
+	 * Vop standby will take effect at end of current frame,
+	 * if dsp hold valid irq happen, it means standby complete.
+	 *
+	 * we must wait standby complete when we want to disable aclk,
+	 * if not, memory bus maybe dead.
+	 */
+	reinit_completion(&vop->dsp_hold_completion);
+	vop_dsp_hold_valid_irq_enable(vop);
+
+	spin_lock(&vop->reg_lock);
+
+	VOP_CTRL_SET(vop, standby, 1);
+
+	spin_unlock(&vop->reg_lock);
+
+	WARN_ON(!wait_for_completion_timeout(&vop->dsp_hold_completion,
+					     msecs_to_jiffies(50)));
+
+	vop_dsp_hold_valid_irq_disable(vop);
+
+	vop->is_enabled = false;
+	if (vop->is_iommu_enabled) {
+		/*
+		 * vop standby complete, so iommu detach is safe.
+		 */
+		VOP_CTRL_SET(vop, dma_stop, 1);
+		rockchip_drm_dma_detach_device(vop->drm_dev, vop->dev);
+		vop->is_iommu_enabled = false;
+	}
+
+	pm_runtime_put_sync(vop->dev);
+	clk_disable_unprepare(vop->dclk);
+	clk_disable_unprepare(vop->aclk);
+	clk_disable_unprepare(vop->hclk);
+	vop_unlock(vop);
+
+	rockchip_clear_system_status(sys_status);
+#endif
+	if (crtc->state->event && !crtc->state->active) {
+		spin_lock_irq(&crtc->dev->event_lock);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+
+		crtc->state->event = NULL;
+	}
+}
+
+void kendryte_vop_cfg_updata(struct kendryte_vo *vop)
+{
+	int i = 0;
+	for (i = 0; i < KENDRYTE_VO_NUM_LAYERS; i++) {
+		kendryte_set_layer_enable(vop, i + LAYER0,
+					  vop->layer[i].status);
+	}
+}
+
+static void kendryte_crtc_atomic_flush(struct drm_crtc *crtc,
+				       struct drm_crtc_state *old_crtc_state)
+{
+	struct drm_atomic_state *old_state = old_crtc_state->state;
+	struct drm_plane_state *old_plane_state;
+	struct kendryte_vo *vop = to_vop(crtc);
+	struct drm_plane *plane;
+	int i;
+	unsigned long flags;
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
+
+	kendryte_vop_cfg_updata(vop);
+
+	//	kendryte_vo_get_reg_val(vop);
+
+	kendryte_vo_set_config_done(vop);
+
+	spin_lock_irq(&crtc->dev->event_lock);
+	if (crtc->state->event) {
+		// vblank enable
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+		WARN_ON(vop->event);
+
+		vop->event = crtc->state->event;
+		crtc->state->event = NULL;
+	}
+	spin_unlock_irq(&crtc->dev->event_lock);
+
+#if 0
+	for_each_plane_in_state(old_state, plane, old_plane_state, i) {
+		if (!old_plane_state->fb)
+			continue;
+
+		if (old_plane_state->fb == plane->state->fb)
+			continue;
+
+		drm_framebuffer_get(old_plane_state->fb);
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+		drm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);
+		set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
+	}
+#else
+	for_each_old_plane_in_state (old_state, plane, old_plane_state, i) {
+		if (!old_plane_state->fb)
+			continue;
+
+		if (old_plane_state->fb == plane->state->fb)
+			continue;
+
+		drm_framebuffer_get(old_plane_state->fb);
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+		drm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);
+		set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
+	}
+#endif
+}
+
+static const struct drm_crtc_helper_funcs kendryte_crtc_helper_funcs = {
+	.mode_fixup = kendryte_crtc_mode_fixup,
+	.atomic_check = kendryte_crtc_atomic_check,
+	.atomic_flush = kendryte_crtc_atomic_flush,
+	.atomic_enable = kendryte_crtc_atomic_enable,
+	.atomic_disable = kendryte_crtc_atomic_disable,
+};
+
+static int kendryte_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,
+				   u16 *blue, uint32_t size,
+				   struct drm_modeset_acquire_ctx *ctx)
+{
+	printk("kendryte_crtc_gamma_set \n");
+#if 0 
+	struct vop *vop = to_vop(crtc);
+	int len = min(size, vop->lut_len);
+	int i;
+
+	if (!vop->lut)
+		return -EINVAL;
+
+	for (i = 0; i < len; i++)
+		rockchip_vop_crtc_fb_gamma_set(crtc, red[i], green[i],
+					       blue[i], i);
+
+	vop_crtc_load_lut(crtc);
+
+#endif
+	return 0;
+}
+
+static void kendryte_crtc_destroy(struct drm_crtc *crtc)
+{
+	drm_crtc_cleanup(crtc);
+}
+
+static void kendryte_crtc_reset(struct drm_crtc *crtc)
+{
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(crtc->state);
+
+	if (crtc->state) {
+		__drm_atomic_helper_crtc_destroy_state(crtc->state);
+		kfree(s);
+	}
+
+	s = kzalloc(sizeof(*s), GFP_KERNEL);
+	if (!s)
+		return;
+	crtc->state = &s->base;
+	crtc->state->crtc = crtc;
+
+	s->left_margin = 100;
+	s->right_margin = 100;
+	s->top_margin = 100;
+	s->bottom_margin = 100;
+}
+
+static int kendryte_crtc_atomic_get_property(struct drm_crtc *crtc,
+					     const struct drm_crtc_state *state,
+					     struct drm_property *property,
+					     uint64_t *val)
+{
+	struct drm_device *drm_dev = crtc->dev;
+	struct kendryte_drm_private *private = drm_dev->dev_private;
+	struct drm_mode_config *mode_config = &drm_dev->mode_config;
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
+	struct kendryte_vo *vop = to_vop(crtc);
+
+	if (property == mode_config->tv_left_margin_property) {
+		*val = s->left_margin;
+		return 0;
+	}
+
+	if (property == mode_config->tv_right_margin_property) {
+		*val = s->right_margin;
+		return 0;
+	}
+
+	if (property == mode_config->tv_top_margin_property) {
+		*val = s->top_margin;
+		return 0;
+	}
+
+	if (property == mode_config->tv_bottom_margin_property) {
+		*val = s->bottom_margin;
+		return 0;
+	}
+	/*
+	if (property == private->alpha_scale_prop) {
+		*val = (vop->data->feature & VOP_FEATURE_ALPHA_SCALE) ? 1 : 0;
+		return 0;
+	}
+*/
+	DRM_ERROR("failed to get vop crtc property\n");
+	return -EINVAL;
+}
+
+static int kendryte_crtc_atomic_set_property(struct drm_crtc *crtc,
+					     struct drm_crtc_state *state,
+					     struct drm_property *property,
+					     uint64_t val)
+{
+	struct drm_device *drm_dev = crtc->dev;
+	struct drm_mode_config *mode_config = &drm_dev->mode_config;
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
+	//struct vop *vop = to_vop(crtc);
+
+	if (property == mode_config->tv_left_margin_property) {
+		s->left_margin = val;
+		return 0;
+	}
+
+	if (property == mode_config->tv_right_margin_property) {
+		s->right_margin = val;
+		return 0;
+	}
+
+	if (property == mode_config->tv_top_margin_property) {
+		s->top_margin = val;
+		return 0;
+	}
+
+	if (property == mode_config->tv_bottom_margin_property) {
+		s->bottom_margin = val;
+		return 0;
+	}
+
+	DRM_ERROR("failed to set vop crtc property\n");
+	return -EINVAL;
+}
+
+static struct drm_crtc_state *
+	kendryte_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct kendryte_crtc_state *kendryte_state, *old_state;
+
+	//	printk("kendryte_crtc_duplicate_state ------------------ \n");
+
+	old_state = to_kendryte_crtc_state(crtc->state);
+	kendryte_state = kmemdup(old_state, sizeof(*old_state), GFP_KERNEL);
+	if (!kendryte_state)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &kendryte_state->base);
+
+	return &kendryte_state->base;
+}
+
+static void kendryte_crtc_destroy_state(struct drm_crtc *crtc,
+					struct drm_crtc_state *state)
+{
+	struct kendryte_crtc_state *s = to_kendryte_crtc_state(state);
+
+	__drm_atomic_helper_crtc_destroy_state(&s->base);
+	kfree(s);
+}
+
+static int kendryte_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+	struct kendryte_vo *vop = to_vop(crtc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&vop->irq_lock, flags);
+
+	// open vo intr
+	kendryte_vo_set_irq(vop, 1);
+
+	spin_unlock_irqrestore(&vop->irq_lock, flags);
+
+	return 0;
+}
+
+static void kendryte_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+	struct kendryte_vo *vop = to_vop(crtc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&vop->irq_lock, flags);
+
+	//close intr
+	kendryte_vo_set_irq(vop, 0);
+
+	spin_unlock_irqrestore(&vop->irq_lock, flags);
+}
+
+static const struct drm_crtc_funcs kendryte_crtc_funcs = {
+	.gamma_set = kendryte_crtc_gamma_set,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.destroy = kendryte_crtc_destroy,
+	.reset = kendryte_crtc_reset,
+	.atomic_get_property = kendryte_crtc_atomic_get_property,
+	.atomic_set_property = kendryte_crtc_atomic_set_property,
+	.atomic_duplicate_state = kendryte_crtc_duplicate_state,
+	.atomic_destroy_state = kendryte_crtc_destroy_state,
+	.enable_vblank = kendryte_crtc_enable_vblank,
+	.disable_vblank = kendryte_crtc_disable_vblank,
+};
+
+static const uint32_t kendryte_layer_formats[] = {
+	DRM_FORMAT_NV12,   DRM_FORMAT_NV16,   DRM_FORMAT_NV21,
+	DRM_FORMAT_NV61,   DRM_FORMAT_UYVY,   DRM_FORMAT_VYUY,
+	DRM_FORMAT_YUV420, DRM_FORMAT_YUV422, DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVU420, DRM_FORMAT_YVU422, DRM_FORMAT_YVYU,
+};
+
+static const uint32_t kendryte_osd_formats[] = {
+	DRM_FORMAT_ARGB8888, DRM_FORMAT_ARGB4444, DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_RGBA4444, DRM_FORMAT_RGB888,	  DRM_FORMAT_RGB565,
+	DRM_FORMAT_XRGB8888,
+};
+
+int kendryte_create_crtc(struct kendryte_vo *vop)
+{
+	struct device *dev = vop->dev;
+	struct drm_device *drm_dev = vop->drm;
+	struct drm_plane *primary = NULL, *cursor = NULL, *plane, *tmp;
+	struct drm_crtc *crtc = &vop->crtc;
+	struct device_node *port;
+
+	const uint32_t *formats = kendryte_layer_formats;
+	unsigned int formats_len = ARRAY_SIZE(kendryte_layer_formats);
+
+	const uint32_t *osd_formats = kendryte_osd_formats;
+	unsigned int ods_formats_len = ARRAY_SIZE(kendryte_osd_formats);
+
+	int ret;
+	int i;
+
+	/*
+	 * Create drm_planes for overlay windows with possible_crtcs restricted
+	 * to the newly created crtc.
+	 */
+
+	for (i = 0; i < 4; i++) {
+		struct kendryte_layer *layer = &vop->layer[i];
+
+		unsigned long possible_crtcs = drm_crtc_mask(crtc);
+		if (layer->type != DRM_PLANE_TYPE_OVERLAY)
+			continue;
+
+		ret = drm_universal_plane_init(drm_dev, &layer->plane,
+					       possible_crtcs,
+					       &kendryte_layer_funcs, formats,
+					       formats_len, NULL, layer->type,
+					       NULL);
+		if (ret) {
+			DRM_DEV_ERROR(vop->dev, "failed to init overlay %d\n",
+				      ret);
+			goto err_cleanup_crtc;
+		}
+		drm_plane_helper_add(&layer->plane,
+				     &kendryte_layer_helper_funcs);
+
+		plane = &layer->plane;
+		layer->layer_id = plane->base.id;
+		layer->status = 0;
+	}
+
+	for (i = 0; i < 3; i++) {
+		struct kendryte_layer *layer = &vop->layer[i + 4];
+
+		unsigned long possible_crtcs = drm_crtc_mask(crtc);
+		if (layer->type != DRM_PLANE_TYPE_OVERLAY)
+			continue;
+
+		ret = drm_universal_plane_init(drm_dev, &layer->plane,
+					       possible_crtcs,
+					       &kendryte_layer_funcs,
+					       osd_formats, ods_formats_len,
+					       NULL, layer->type, NULL);
+		if (ret) {
+			DRM_DEV_ERROR(vop->dev, "failed to init overlay %d\n",
+				      ret);
+			goto err_cleanup_crtc;
+		}
+		drm_plane_helper_add(&layer->plane,
+				     &kendryte_layer_helper_funcs);
+
+		plane = &layer->plane;
+		layer->layer_id = plane->base.id;
+		layer->status = 0;
+
+		// osd2 for DRM_PLANE_TYPE_PRIMARY = 1
+		if (i == 2) {
+			plane->type = DRM_PLANE_TYPE_PRIMARY;
+			layer->type = DRM_PLANE_TYPE_PRIMARY;
+			primary = plane;
+		}
+
+		// osd1 for DRM_PLANE_TYPE_CURSOR = 2
+		if (i == 1) {
+			plane->type = DRM_PLANE_TYPE_CURSOR;
+			layer->type = DRM_PLANE_TYPE_CURSOR;
+			cursor = plane;
+		}
+	}
+
+	ret = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,
+					&kendryte_crtc_funcs, NULL);
+	if (ret)
+		goto err_cleanup_planes;
+
+	drm_crtc_helper_add(crtc, &kendryte_crtc_helper_funcs);
+
+	port = of_get_child_by_name(dev->of_node, "port");
+	if (!port) {
+		DRM_DEV_ERROR(vop->dev, "no port node found in %pOF\n",
+			      dev->of_node);
+		ret = -ENOENT;
+		goto err_cleanup_crtc;
+	}
+
+	crtc->port = port;
+
+	return 0;
+err_cleanup_crtc:
+	drm_crtc_cleanup(crtc);
+err_cleanup_planes:
+
+	drm_plane_cleanup(plane);
+	return ret;
+}
diff --git a/drivers/gpu/drm/canaan/kendryte_vo.c b/drivers/gpu/drm/canaan/kendryte_vo.c
index 295fac68..4443bf33 100755
--- a/drivers/gpu/drm/canaan/kendryte_vo.c
+++ b/drivers/gpu/drm/canaan/kendryte_vo.c
@@ -4,1174 +4,1167 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
 */
-#include <linux/clk.h>
-#include <linux/component.h>
-#include <linux/crc-ccitt.h>
-#include <linux/module.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/regmap.h>
-#include <linux/reset.h>
-#include <linux/slab.h>
-#include <linux/log2.h>
-#include <linux/of.h>
-#include <linux/uaccess.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/init.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_mipi_dsi.h>
-#include <drm/drm_panel.h>
-#include <drm/drm_print.h>
-
-
-
-#include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_of.h>
-#include <drm/drmP.h>
-
-
-#include "vo_table.h"
-#include "kendryte_vo.h"
-
-
-void kendryte_vo_enable_vblank(struct kendryte_vo *vo, bool enable)
-{
-
-
-    printk("%sabling VBLANK interrupt\n", enable ? "En" : "Dis");
-
-}
-
-EXPORT_SYMBOL(kendryte_vo_enable_vblank);
-
-
-
-
-
-void kendryte_vo_wrap_init(struct kendryte_vo *vo)
-{
-    uint8_t i = 0;
-
- 
-    writel(0x11, vo->base + VO_DMA_SW_CTL);
-    writel(0x88, vo->base + VO_DMA_RD_CTL_OUT);
-    writel(0x0, vo->base + VO_DMA_ARB_MODE);
-    
-    for(i = 0; i < 8; i++)
-    {
-        writel(0x1010101, vo->base + 0x14 + (4 * i));
-    }
-
-    writel(0x76543210, vo->base + 0x34);
-    writel(0x76543210, vo->base + 0x3c);
-    writel(0x76543210, vo->base + 0x44);
-    writel(0x76543210, vo->base + VO_DMA_ID_RD_0);
-
-    writel(0xfedcba98, vo->base + 0x38);
-    writel(0xfedcba98, vo->base + 0x40);
-    writel(0xfedcba98, vo->base + 0x48);
-    writel(0xfedcba98, vo->base + 0x80);
-
-    for(i = 0; i < 10; i++)
-    {
-        writel(0x701, vo->base + VO_LAYER0_LINE0_BD_CTL + (4 * i));
-    }
-
-   
-}
-
-void kendryte_vo_table_init(struct kendryte_vo *vo)
-{
-    int i = 0;
-
-    // init VSCALE
-    for(i = 0; i < 64; i++)
-    {
-        writel(V_Coef[i*2],(vo->base + VO_VSCALE_BASE + ((i*2)<<2)));
-    	writel(V_Coef[i*2+1],(vo->base + VO_VSCALE_BASE + ((i*2+1)<<2)));
-    }
-
-    // init HSCALE
-    for(i = 0; i < 64; i++)
-    {
-        writel(H_Coef[i*3], (vo->base + VO_HSCALE_BASE + ((i*4)<<2)));
-		writel(H_Coef[i*3 + 1],(vo->base + VO_HSCALE_BASE + ((i*4+1)<<2)));
-		writel(H_Coef[i*3 +2 ],(vo->base + VO_HSCALE_BASE + ((i*4+2)<<2)));
-    }
-/*
-    // init GAMMA
-    for(i = 0; i < 255; i++)
-    {
-        writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x00 +((i)<<2)));
-		writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x400 +((i)<<2)));
-		writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x800 +((i)<<2)));
-    }
-*/
-
-}
-
-void kendryte_vo_set_yuv_background(struct kendryte_vo *vo, uint16_t y, uint32_t u, uint32_t v)
-{
-    uint32_t reg = 0;
-
-    reg = y + (u << 8) + (v << 16);
-
-    writel(reg, vo->base + VO_DISP_BACKGROUND);
-    
-}
-
-
-void kendryte_vo_software_reset(struct kendryte_vo *vo)
-{
-    writel(0x0f, vo->base + VO_SOFT_RST_CTL);
-}
-
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/crc-ccitt.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/log2.h>
+#include <linux/of.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/init.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drmP.h>
+
+#include "vo_table.h"
+#include "kendryte_vo.h"
+
+void kendryte_vo_enable_vblank(struct kendryte_vo *vo, bool enable)
+{
+	printk("%sabling VBLANK interrupt\n", enable ? "En" : "Dis");
+}
+
+EXPORT_SYMBOL(kendryte_vo_enable_vblank);
+
+void kendryte_vo_wrap_init(struct kendryte_vo *vo)
+{
+	uint8_t i = 0;
+
+	writel(0x11, vo->base + VO_DMA_SW_CTL);
+	writel(0x88, vo->base + VO_DMA_RD_CTL_OUT);
+	writel(0x0, vo->base + VO_DMA_ARB_MODE);
+
+	for (i = 0; i < 8; i++) {
+		writel(0x1010101, vo->base + 0x14 + (4 * i));
+	}
+
+	writel(0x76543210, vo->base + 0x34);
+	writel(0x76543210, vo->base + 0x3c);
+	writel(0x76543210, vo->base + 0x44);
+	writel(0x76543210, vo->base + VO_DMA_ID_RD_0);
+
+	writel(0xfedcba98, vo->base + 0x38);
+	writel(0xfedcba98, vo->base + 0x40);
+	writel(0xfedcba98, vo->base + 0x48);
+	writel(0xfedcba98, vo->base + 0x80);
+
+	for (i = 0; i < 10; i++) {
+		writel(0x701, vo->base + VO_LAYER0_LINE0_BD_CTL + (4 * i));
+	}
+}
+
+void kendryte_vo_table_init(struct kendryte_vo *vo)
+{
+	int i = 0;
+
+	// init VSCALE
+	for (i = 0; i < 64; i++) {
+		writel(V_Coef[i * 2],
+		       (vo->base + VO_VSCALE_BASE + ((i * 2) << 2)));
+		writel(V_Coef[i * 2 + 1],
+		       (vo->base + VO_VSCALE_BASE + ((i * 2 + 1) << 2)));
+	}
+
+	// init HSCALE
+	for (i = 0; i < 64; i++) {
+		writel(H_Coef[i * 3],
+		       (vo->base + VO_HSCALE_BASE + ((i * 4) << 2)));
+		writel(H_Coef[i * 3 + 1],
+		       (vo->base + VO_HSCALE_BASE + ((i * 4 + 1) << 2)));
+		writel(H_Coef[i * 3 + 2],
+		       (vo->base + VO_HSCALE_BASE + ((i * 4 + 2) << 2)));
+	}
+	/*
+    // init GAMMA
+    for(i = 0; i < 255; i++)
+    {
+        writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x00 +((i)<<2)));
+		writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x400 +((i)<<2)));
+		writel(GammaCoef[i],(vo->base + VO_GAMMA_BASE + 0x800 +((i)<<2)));
+    }
+*/
+}
+
+void kendryte_vo_set_yuv_background(struct kendryte_vo *vo, uint16_t y,
+				    uint32_t u, uint32_t v)
+{
+	uint32_t reg = 0;
+
+	reg = y + (u << 8) + (v << 16);
+
+	writel(reg, vo->base + VO_DISP_BACKGROUND);
+}
+
+void kendryte_vo_software_reset(struct kendryte_vo *vo)
+{
+	writel(0x0f, vo->base + VO_SOFT_RST_CTL);
+}
 
 void kendryte_vo_set_mode(struct kendryte_vo *vo, struct drm_display_mode *mode)
 {
-    uint32_t reg_val = 0x00;
-    uint32_t htotal, hdisplay, hbp = 0, hfp = 0, hsa = 0;
-    uint32_t vtotal, vdisplay, vbp = 0, vfp = 0, vsa = 0;
-    uint32_t xzone_start, xzone_stop;
-    uint32_t yzone_start, yzone_stop;
-
-    htotal      = mode->htotal;
-    hdisplay    = mode->hdisplay;
-    hsa         = mode->hsync_end - mode->hsync_start;
-    hbp         = mode->htotal - mode->hsync_end;
-    hfp         = mode->hsync_start - mode->hdisplay;
-    vtotal      = mode->vtotal;
-    vdisplay    = mode->vdisplay;
-    vsa         = mode->vsync_end - mode->vsync_start;
-    vbp         = mode->vtotal - mode->vsync_end;
-    vfp         = mode->vsync_start - mode->vdisplay;
-    xzone_start = hsa + hbp;
-    xzone_stop  = hdisplay + hsa + hbp;
-    yzone_start = vsa + vbp + 1;
-    yzone_stop  = vdisplay + vsa + vbp + 1;
-
-    printk("crtc htotal %d\n", htotal);
-    printk("crtc hdisplay %d\n", hdisplay);
-    printk("crtc xzone_start %d\n", xzone_start);
-    printk("crtc xzone_stop %d\n", xzone_stop);
-    printk("crtc vtotal %d\n", vtotal);
-    printk("crtc vdisplay %d\n", vdisplay);
-    printk("crtc yzone_start %d\n", yzone_start);
-    printk("crtc yzone_stop %d\n", yzone_stop);
-    // update draw frame
-    reg_val = ((hdisplay - 1) & 0x1FFF) | (((vdisplay - 1) & 0x1FFF) << 16) | (1UL << 15);
-    writel(reg_val, vo->base + ADDR_VO_DISP_DRAW_FRAME_CMD);
-    uint32_t enable_flag = readl(vo->base + VO_DISP_ENABLE);
-    if ((enable_flag & 0x80) == 0)
-        return;
-    writel(0, vo->base + VO_DISP_ENABLE);
-
-    reg_val = 0x05 + (0x19 << 16);
-    writel(reg_val, vo->base + VO_DISP_HSYNC_CTL);
-
-    reg_val = 0x01 + (0x05 << 16);
-    writel(reg_val, vo->base + VO_DISP_HSYNC1_CTL);
-
-    reg_val = 0x01 + (0x01 << 16);
-    writel(reg_val, vo->base + VO_DISP_VSYNC1_CTL);
-
-    reg_val = htotal + (vtotal << 16);
-    writel(reg_val, vo->base + VO_DISP_TOTAL_SIZE);
-
-    reg_val = xzone_start + ((xzone_stop -1) << 16);
-    writel(reg_val, vo->base + VO_DISP_XZONE_CTL);
-
-    reg_val = yzone_start + ((yzone_stop -1) << 16);
-    writel(reg_val, vo->base + VO_DISP_YZONE_CTL);
+	uint32_t reg_val = 0x00;
+	uint32_t htotal, hdisplay, hbp = 0, hfp = 0, hsa = 0;
+	uint32_t vtotal, vdisplay, vbp = 0, vfp = 0, vsa = 0;
+	uint32_t xzone_start, xzone_stop;
+	uint32_t yzone_start, yzone_stop;
+
+	htotal = mode->htotal;
+	hdisplay = mode->hdisplay;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	hfp = mode->hsync_start - mode->hdisplay;
+	vtotal = mode->vtotal;
+	vdisplay = mode->vdisplay;
+	vsa = mode->vsync_end - mode->vsync_start;
+	vbp = mode->vtotal - mode->vsync_end;
+	vfp = mode->vsync_start - mode->vdisplay;
+	xzone_start = hsa + hbp;
+	xzone_stop = hdisplay + hsa + hbp;
+	yzone_start = vsa + vbp + 1;
+	yzone_stop = vdisplay + vsa + vbp + 1;
+
+	printk("crtc htotal %d\n", htotal);
+	printk("crtc hdisplay %d\n", hdisplay);
+	printk("crtc xzone_start %d\n", xzone_start);
+	printk("crtc xzone_stop %d\n", xzone_stop);
+	printk("crtc vtotal %d\n", vtotal);
+	printk("crtc vdisplay %d\n", vdisplay);
+	printk("crtc yzone_start %d\n", yzone_start);
+	printk("crtc yzone_stop %d\n", yzone_stop);
+	// update draw frame
+	reg_val = ((hdisplay - 1) & 0x1FFF) |
+		  (((vdisplay - 1) & 0x1FFF) << 16) | (1UL << 15);
+	writel(reg_val, vo->base + ADDR_VO_DISP_DRAW_FRAME_CMD);
+	uint32_t enable_flag = readl(vo->base + VO_DISP_ENABLE);
+	if ((enable_flag & 0x80) == 0)
+		return;
+	writel(0, vo->base + VO_DISP_ENABLE);
+
+	reg_val = 0x05 + (0x19 << 16);
+	writel(reg_val, vo->base + VO_DISP_HSYNC_CTL);
+
+	reg_val = 0x01 + (0x05 << 16);
+	writel(reg_val, vo->base + VO_DISP_HSYNC1_CTL);
+
+	reg_val = 0x01 + (0x01 << 16);
+	writel(reg_val, vo->base + VO_DISP_VSYNC1_CTL);
+
+	reg_val = htotal + (vtotal << 16);
+	writel(reg_val, vo->base + VO_DISP_TOTAL_SIZE);
+
+	reg_val = xzone_start + ((xzone_stop - 1) << 16);
+	writel(reg_val, vo->base + VO_DISP_XZONE_CTL);
+
+	reg_val = yzone_start + ((yzone_stop - 1) << 16);
+	writel(reg_val, vo->base + VO_DISP_YZONE_CTL);
+}
+
+void kendryte_vo_timing_init(struct kendryte_vo *vo,
+			     struct kendryte_vo_timing *vo_timing)
+{
+	uint32_t reg = 0;
+	// default VO_SYSTEM_MODE_1080x1920x30P
+	printk("kendryte_vo_timing_init start");
+
+	// write hsa = hsa_end - hsa_start
+	reg = vo_timing->hsa_start + (vo_timing->hsa_end << 16);
+	writel(reg, vo->base + VO_DISP_HSYNC_CTL);
+
+	//write vsa = vas_end - vas_start ( + 1)
+	reg = vo_timing->vas_start + (vo_timing->vas_end << 16);
+	writel(reg, vo->base + VO_DISP_HSYNC1_CTL);
+
+	// vas hsa
+	reg = 0x01 + (0x01 << 16);
+	writel(reg, vo->base + VO_DISP_VSYNC1_CTL);
+
+	// write vo totle size
+	reg = vo_timing->total_size.VT + (vo_timing->total_size.HT << 16);
+	writel(reg, vo->base + VO_DISP_TOTAL_SIZE);
+
+	/*
+        rite x zone  
+        HBP = zone_x_start - hsa
+        HFP = total_size.HT - act.h - hbp - hsa 
+    */
+	reg = vo_timing->zone_x_start + ((vo_timing->zone_x_stop - 1) << 16);
+	writel(reg, vo->base + VO_DISP_XZONE_CTL);
+
+	/*
+        write y zone
+        VBP = zone_y_start - 1
+        VFP = total_size.VT - act.v - vbp
+    */
+	reg = vo_timing->zone_y_start + ((vo_timing->zone_y_stop - 1) << 16);
+	writel(reg, vo->base + VO_DISP_YZONE_CTL);
+
+	writel(0x105d08cc, vo->base + VO_DISP_HSYNC2_CTL);
+	writel(0xfdf1a55, vo->base + VO_DISP_VSYNC2_CTL);
+
+	// config default layer location
+
+	writel(0x1fff0000, vo->base + VO_DISP_LAYER0_XCTL);
+	writel(0x1ce01ce, vo->base + VO_DISP_LAYER0_YCTL);
+
+	writel(0x1fff0000, vo->base + VO_DISP_LAYER1_XCTL);
+	writel(0xe020701, vo->base + VO_DISP_LAYER1_YCTL);
+
+	writel(0x1fff0000, vo->base + VO_DISP_LAYER2_XCTL);
+	writel(0x2081088, vo->base + VO_DISP_LAYER2_YCTL);
+
+	writel(0x1fff0000, vo->base + VO_DISP_LAYER3_XCTL);
+	writel(0x10001, vo->base + VO_DISP_LAYER3_YCTL);
+
+	writel(0x50004, vo->base + VO_DISP_LAYER4_XCTL);
+	writel(0x80005, vo->base + VO_DISP_LAYER4_YCTL);
+
+	writel(0x11000a, vo->base + VO_DISP_LAYER5_XCTL);
+	writel(0x14000b, vo->base + VO_DISP_LAYER5_YCTL);
+
+	writel(0x20001, vo->base + VO_DISP_LAYER6_XCTL);
+	writel(0xe0007, vo->base + VO_DISP_LAYER6_YCTL);
+}
+
+// uv addr form
+void kendryte_set_layer_addr(struct kendryte_vo *vo, enum VO_LAYER layer,
+			     uint32_t y_addr0, uint32_t y_addr1,
+			     uint32_t uv_addr0, uint32_t uv_addr1)
+{
+	switch (layer) {
+	case LAYER0:
+		writel(y_addr0, vo->base + VO_DISP_LAYER0_Y_ADDR0);
+		writel(y_addr1, vo->base + VO_DISP_LAYER0_Y_ADDR1);
+
+		writel(uv_addr0, vo->base + VO_DISP_LAYER0_UV_ADDR0);
+		writel(uv_addr1, vo->base + VO_DISP_LAYER0_UV_ADDR1);
+
+		break;
+	case LAYER1:
+		writel(y_addr0, vo->base + VO_DISP_LAYER1_Y_ADDR0);
+		writel(y_addr1, vo->base + VO_DISP_LAYER1_Y_ADDR1);
+
+		writel(uv_addr0, vo->base + VO_DISP_LAYER1_UV_ADDR0);
+		writel(uv_addr1, vo->base + VO_DISP_LAYER1_UV_ADDR1);
+
+		break;
+	case LAYER2:
+		writel(y_addr0, vo->base + VO_DISP_LAYER2_Y_ADDR0);
+		writel(y_addr1, vo->base + VO_DISP_LAYER2_Y_ADDR1);
+
+		writel(uv_addr0, vo->base + VO_DISP_LAYER2_UV_ADDR0);
+		writel(uv_addr1, vo->base + VO_DISP_LAYER2_UV_ADDR1);
+
+		break;
+	case LAYER3:
+		writel(y_addr0, vo->base + VO_DISP_LAYER3_Y_ADDR0);
+		writel(y_addr1, vo->base + VO_DISP_LAYER3_Y_ADDR1);
+
+		writel(uv_addr0, vo->base + VO_DISP_LAYER3_UV_ADDR0);
+		writel(uv_addr1, vo->base + VO_DISP_LAYER3_UV_ADDR1);
+
+		break;
+
+	default:
+		printk("The number of layers does not exist is %d", layer);
+		break;
+	}
+}
+
+// uv addr form
+void kendryte_set_osd_addr(struct kendryte_vo *vo, enum VO_LAYER layer,
+			   uint32_t alpha_addr0, uint32_t alpha_addr1,
+			   uint32_t value0, uint32_t value1)
+{
+	switch (layer) {
+	case OSD0:
+
+		writel(alpha_addr0, vo->base + VO_DISP_OSD0_ALP_ADDR0);
+		writel(alpha_addr1, vo->base + VO_DISP_OSD0_ALP_ADDR1);
+
+		writel(value0, vo->base + VO_DISP_OSD0_VLU_ADDR0);
+		writel(value1, vo->base + VO_DISP_OSD0_VLU_ADDR1);
+		break;
+	case OSD1:
+
+		writel(alpha_addr0, vo->base + VO_DISP_OSD1_ALP_ADDR0);
+		writel(alpha_addr1, vo->base + VO_DISP_OSD1_ALP_ADDR1);
+
+		writel(value0, vo->base + VO_DISP_OSD1_VLU_ADDR0);
+		writel(value1, vo->base + VO_DISP_OSD1_VLU_ADDR1);
+		break;
+
+	case OSD2:
+
+		writel(alpha_addr0, vo->base + VO_DISP_OSD2_ALP_ADDR0);
+		writel(alpha_addr1, vo->base + VO_DISP_OSD2_ALP_ADDR1);
+
+		writel(value0, vo->base + VO_DISP_OSD2_VLU_ADDR0);
+		writel(value1, vo->base + VO_DISP_OSD2_VLU_ADDR1);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
 }
 
-void kendryte_vo_timing_init(struct kendryte_vo *vo, struct kendryte_vo_timing *vo_timing)
-{
-    uint32_t reg = 0;
-    // default VO_SYSTEM_MODE_1080x1920x30P
-    printk("kendryte_vo_timing_init start");
-
-    // write hsa = hsa_end - hsa_start
-    reg = vo_timing->hsa_start + (vo_timing->hsa_end << 16);
-    writel(reg, vo->base + VO_DISP_HSYNC_CTL);
-
-    //write vsa = vas_end - vas_start ( + 1)
-    reg = vo_timing->vas_start + (vo_timing->vas_end << 16);
-    writel(reg, vo->base + VO_DISP_HSYNC1_CTL);
-
-    // vas hsa
-    reg = 0x01 + (0x01 << 16);
-    writel(reg, vo->base + VO_DISP_VSYNC1_CTL);
-
-    // write vo totle size
-    reg = vo_timing->total_size.VT + (vo_timing->total_size.HT << 16);
-    writel(reg, vo->base + VO_DISP_TOTAL_SIZE);
-
-    /*
-        rite x zone  
-        HBP = zone_x_start - hsa
-        HFP = total_size.HT - act.h - hbp - hsa 
-    */
-    reg = vo_timing->zone_x_start + ((vo_timing->zone_x_stop - 1) << 16);
-    writel(reg, vo->base + VO_DISP_XZONE_CTL);  
-
-    /*
-        write y zone
-        VBP = zone_y_start - 1
-        VFP = total_size.VT - act.v - vbp
-    */
-    reg = vo_timing->zone_y_start + ((vo_timing->zone_y_stop -1) << 16) ;
-    writel(reg, vo->base + VO_DISP_YZONE_CTL);
-
-
-    writel(0x105d08cc, vo->base + VO_DISP_HSYNC2_CTL);
-    writel(0xfdf1a55, vo->base + VO_DISP_VSYNC2_CTL);
-
-    // config default layer location
-
-    writel(0x1fff0000, vo->base + VO_DISP_LAYER0_XCTL);
-    writel(0x1ce01ce, vo->base + VO_DISP_LAYER0_YCTL);
-
-    writel(0x1fff0000, vo->base + VO_DISP_LAYER1_XCTL);
-    writel(0xe020701, vo->base + VO_DISP_LAYER1_YCTL);
-
-    writel(0x1fff0000, vo->base + VO_DISP_LAYER2_XCTL);
-    writel(0x2081088, vo->base + VO_DISP_LAYER2_YCTL);
-
-    writel(0x1fff0000, vo->base + VO_DISP_LAYER3_XCTL);
-    writel(0x10001, vo->base + VO_DISP_LAYER3_YCTL);
-
-    writel(0x50004, vo->base + VO_DISP_LAYER4_XCTL);
-    writel(0x80005, vo->base + VO_DISP_LAYER4_YCTL);
-
-    writel(0x11000a, vo->base + VO_DISP_LAYER5_XCTL);
-    writel(0x14000b, vo->base + VO_DISP_LAYER5_YCTL);
-
-    writel(0x20001, vo->base + VO_DISP_LAYER6_XCTL);
-    writel(0xe0007, vo->base + VO_DISP_LAYER6_YCTL);
-
-
-}
-
-// uv addr form 
-void kendryte_set_layer_addr(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t y_addr0, uint32_t y_addr1, uint32_t uv_addr0, uint32_t uv_addr1)
-{
-    switch (layer)
-    {
-        case LAYER0 :
-            writel(y_addr0, vo->base + VO_DISP_LAYER0_Y_ADDR0);
-            writel(y_addr1, vo->base + VO_DISP_LAYER0_Y_ADDR1);
-
-            writel(uv_addr0, vo->base + VO_DISP_LAYER0_UV_ADDR0);
-            writel(uv_addr1, vo->base + VO_DISP_LAYER0_UV_ADDR1);
-
-            break;
-        case LAYER1 :
-            writel(y_addr0, vo->base + VO_DISP_LAYER1_Y_ADDR0);
-            writel(y_addr1, vo->base + VO_DISP_LAYER1_Y_ADDR1);
-
-            writel(uv_addr0, vo->base + VO_DISP_LAYER1_UV_ADDR0);
-            writel(uv_addr1, vo->base + VO_DISP_LAYER1_UV_ADDR1);
-
-            break;
-        case LAYER2 :
-            writel(y_addr0, vo->base + VO_DISP_LAYER2_Y_ADDR0);
-            writel(y_addr1, vo->base + VO_DISP_LAYER2_Y_ADDR1);
-
-            writel(uv_addr0, vo->base + VO_DISP_LAYER2_UV_ADDR0);
-            writel(uv_addr1, vo->base + VO_DISP_LAYER2_UV_ADDR1);
-
-            break;
-        case LAYER3 :
-            writel(y_addr0, vo->base + VO_DISP_LAYER3_Y_ADDR0);
-            writel(y_addr1, vo->base + VO_DISP_LAYER3_Y_ADDR1);
-
-            writel(uv_addr0, vo->base + VO_DISP_LAYER3_UV_ADDR0);
-            writel(uv_addr1, vo->base + VO_DISP_LAYER3_UV_ADDR1);
-
-            break;
-    
-        default:
-            printk("The number of layers does not exist is %d", layer);
-            break;
-    }    
-}
-
-// uv addr form 
-void kendryte_set_osd_addr(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t alpha_addr0, uint32_t alpha_addr1, uint32_t value0, uint32_t value1)
-{
-    switch (layer)
-    {
-        case OSD0 :
-
-            writel(alpha_addr0, vo->base + VO_DISP_OSD0_ALP_ADDR0);
-            writel(alpha_addr1, vo->base + VO_DISP_OSD0_ALP_ADDR1);
-
-            writel(value0, vo->base + VO_DISP_OSD0_VLU_ADDR0);
-            writel(value1, vo->base + VO_DISP_OSD0_VLU_ADDR1);
-            break;
-        case OSD1 :
-        
-            writel(alpha_addr0, vo->base + VO_DISP_OSD1_ALP_ADDR0);
-            writel(alpha_addr1, vo->base + VO_DISP_OSD1_ALP_ADDR1);
-
-            writel(value0, vo->base + VO_DISP_OSD1_VLU_ADDR0);
-            writel(value1, vo->base + VO_DISP_OSD1_VLU_ADDR1);
-            break;
-        
-        case OSD2 :
-        
-            writel(alpha_addr0, vo->base + VO_DISP_OSD2_ALP_ADDR0);
-            writel(alpha_addr1, vo->base + VO_DISP_OSD2_ALP_ADDR1);
-
-            writel(value0, vo->base + VO_DISP_OSD2_VLU_ADDR0);
-            writel(value1, vo->base + VO_DISP_OSD2_VLU_ADDR1);
-            break;
-    
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }    
-}
-
-
-void kendryte_set_layer_enable(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t status)
-{
-    uint32_t reg = 0;
-    uint32_t val = 0;
-    switch (layer)
-    {
-        case LAYER0 :
-
-            writel(status, vo->base + VO_LAYER0_CTL);
-            
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(0))) | (status << 0);
-            writel(val, vo->base + VO_DISP_ENABLE);
-
-
-            break;
-
-        case LAYER1 :
-
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            val = (reg & ~(BIT_MASK(1))) | (status << 0);
-            writel(val, vo->base + VO_LAYER1_CTL);
-
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(1))) | (status << 1);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-        
-        case LAYER2 :
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            val = (reg & ~(BIT_MASK(1))) | (status << 0);
-            writel(val, vo->base + VO_LAYER2_CTL);
-
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(2))) | (status << 2);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-        
-        case LAYER3 :
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            val = (reg & ~(BIT_MASK(1))) | (status << 0);
-            writel(val, vo->base + VO_LAYER3_CTL);
-
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(3))) | (status << 3);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-
-        case OSD0 :
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(4))) | (status << 4);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-
-        case OSD1 :
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(5))) | (status << 5);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-
-        case OSD2 :
-            reg = readl(vo->base + VO_DISP_ENABLE);
-            val = (reg & ~(BIT_MASK(6))) | (status << 6);
-            writel(val, vo->base + VO_DISP_ENABLE);
-            break;
-        
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }   
-
-}
-
-void kendryte_set_layer_postion(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vpos, uint32_t hpos, uint32_t v_offset, uint32_t h_offset, struct drm_display_mode *mode)
-{
-    uint32_t val ;
-    uint32_t hsa = mode->crtc_hsync_end - mode->crtc_hsync_start;
-    uint32_t hbp = mode->crtc_htotal - mode->crtc_hsync_end;
-    uint32_t vsa = mode->crtc_vsync_end - mode->crtc_vsync_start;
-    uint32_t vbp = mode->crtc_vtotal - mode->crtc_vsync_end;
-
-
-    switch(layer)
-    {
-        case LAYER0 :
-            // set layer0 in size 
-            val = ((vpos -1 ) << 16) + (hpos - 1);
-            writel(val, vo->base + VO_DISP_LAYER0_IN_ACT_SIZE);
-            // set layer0 out size
-            writel(val, vo->base + VO_DISP_LAYER0_OUT_ACT_SIZE);
-
-            // set layer0 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER0_XCTL);
-            // set layer0 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER0_YCTL);
-            break;
-
-        case LAYER1 :
-            // set layer1 size 
-            val = ((vpos -1 ) << 16) + (hpos - 1);
-            writel(val, vo->base + VO_DISP_LAYER1_ACT_SIZE);
-            // set layer1 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER1_XCTL);
-            // set layer1 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER1_YCTL);
-            break;
-        
-        case LAYER2 :
-            // set layer2 size 
-            val = ((vpos -1 ) << 16) + (hpos - 1);
-            writel(val, vo->base + VO_DISP_LAYER2_ACT_SIZE);
-            // set layer2 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER2_XCTL);
-            // set layer2 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER2_YCTL);
-
-            break;
-        
-        case LAYER3 :
-            // set layer3 size 
-            val = ((vpos -1 ) << 16) + (hpos - 1);
-            writel(val, vo->base + VO_DISP_LAYER3_ACT_SIZE);
-            // set layer3 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER3_XCTL);
-            // set layer3 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER3_YCTL);
-            break;
-
-        case OSD0 :
-            // set osd0 size 
-            val = (vpos << 16) + hpos;
-            writel(val, vo->base + VO_DISP_OSD0_ACT_SIZE);
-            // set osd0 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER4_XCTL);
-            // set osd0 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER4_YCTL);
-            break;
-        case OSD1 :
-            // set osd1 size 
-            val = (vpos << 16) + hpos;
-            writel(val, vo->base + VO_DISP_OSD1_ACT_SIZE);
-            // set osd1 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER5_XCTL);
-            // set osd1 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER5_YCTL);
-
-            break;
-        case OSD2 :
-            // set osd2 size 
-            val = (vpos << 16) + hpos;
-            writel(val, vo->base + VO_DISP_OSD2_ACT_SIZE);
-            // set osd2 x start and stop
-            val = (h_offset + hsa + hbp) + ((hpos + (h_offset + hsa + hbp) - 1) << 16);
-            writel(val, vo->base + VO_DISP_LAYER6_XCTL);
-            // set osd2 y start and stop
-            val = (v_offset + vsa + vbp + 1) + ((vpos + (v_offset + vsa + vbp)) << 16);
-            writel(val, vo->base + VO_DISP_LAYER6_YCTL);
-            break;
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_set_layer_stride(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t stride)
-{
-    uint32_t val;
-
-    switch(layer)
-    {
-        case LAYER0 :
-            writel(stride, vo->base + VO_LAYER0_IMG_IN_STRIDE);
-            break;
-
-        case LAYER1 :
-            
-            writel(stride, vo->base + VO_LAYER1_IMG_IN_STRIDE);
-            break;
-        
-        case LAYER2 :
-
-            writel(stride, vo->base + VO_LAYER2_IMG_IN_STRIDE);
-            break;
-        
-        case LAYER3 :
-            writel(stride, vo->base + VO_LAYER3_IMG_IN_STRIDE);
-            break;
-
-        case OSD0 :
-            val = (stride << 16 ) + stride;
-            writel(val, vo->base + VO_DISP_OSD0_STRIDE);
-            break;
-        case OSD1 :
-            val = (stride << 16 ) + stride;
-            writel(val, vo->base + VO_DISP_OSD1_STRIDE);
-            break;
-        case OSD2 :
-            val = (stride << 16 ) + stride;
-            writel(val, vo->base + VO_DISP_OSD2_STRIDE);
-            break;  
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_set_layer_y_endian(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_VIDEOLAYER_Y_ENDIAN_E ENDIAN)
-{
-    uint32_t reg = 0;
-
-    
-    switch(layer)
-    {
-        case LAYER0 :
-            reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            reg = (reg & ~(GENMASK(9, 8))) | (ENDIAN << 8);
-            writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            break;
-
-        case LAYER1 :
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
-            writel(reg, vo->base + VO_LAYER1_CTL);
-            break;
-        
-        case LAYER2 :
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
-            writel(reg, vo->base + VO_LAYER2_CTL);
-
-            break;
-        
-        case LAYER3 :
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
-            writel(reg, vo->base + VO_LAYER3_CTL);
-            break;
-
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_set_layer_uv_endian(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_VIDEOLAYER_UV_ENDIAN_E ENDIAN)
-{
-    uint32_t reg = 0;
-
-    
-    switch(layer)
-    {
-        case LAYER0 :
-            reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            reg = (reg & ~(GENMASK(14, 12))) | (ENDIAN << 12);
-            writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            break;
-
-        case LAYER1 :
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
-            writel(reg, vo->base + VO_LAYER1_CTL);
-            break;
-        
-        case LAYER2 :
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
-            writel(reg, vo->base + VO_LAYER2_CTL);
-            break;
-        
-        case LAYER3 :
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
-            writel(reg, vo->base + VO_LAYER3_CTL);
-            break;
-
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-/*
-    mode 0 : Hw switch the pingpang address automatically
-    mode 1 : w switch the pingpang address according to register
-
-*/
-void kendryte_vo_set_pingpang_mode(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_LAYER_PINGPANG_MODE mode)
-{
-    uint32_t reg = 0x1100;
-
-    switch(layer)
-    {
-        case LAYER0 :
-            writel(reg, vo->base + VO_LAYER0_PINGPANG_SEL_MODE);
-            break;
-
-        case LAYER1 :
-            writel(reg, vo->base + VO_LAYER1_PINGPANG_SEL_MODE);
-            break;
-        
-        case LAYER2 :
-            writel(reg, vo->base + VO_LAYER2_PINGPANG_SEL_MODE);
-            break;
-        
-        case LAYER3 :
-            writel(reg, vo->base + VO_LAYER3_PINGPANG_SEL_MODE);
-            break;
-        
-        case OSD0 :
-            writel(reg, vo->base + VO_LAYER4_PINGPANG_SEL_MODE);
-            break;
-
-        case OSD1 :
-            writel(reg, vo->base + VO_LAYER5_PINGPANG_SEL_MODE);
-            break;
-        
-        case OSD2 :
-            writel(reg, vo->base + VO_LAYER6_PINGPANG_SEL_MODE);
-            break;
-
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_vo_set_layer_format(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_LAYER_FORMATS formats)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case LAYER0 :
-            reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            reg = (reg & ~(BIT_MASK(0))) | (0x8 << 0);                // 420
-            writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            break;
-
-        case LAYER1 :           
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            reg = (reg & ~(BIT_MASK(4))) | (0 << 4);                //close 422
-            writel(reg, vo->base + VO_LAYER1_CTL);
-
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            reg = (reg & ~(BIT_MASK(8))) | (1 << 8);                //xuyaogai 420
-            writel(reg, vo->base + VO_LAYER1_CTL);
-            break;
-        
-        case LAYER2 :
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            reg = (reg & ~(BIT_MASK(4))) | (0 << 4);                //close 422
-            writel(reg, vo->base + VO_LAYER2_CTL);
-
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            reg = (reg & ~(BIT_MASK(8))) | (1 << 8);                //xuyaogai 420
-            writel(reg, vo->base + VO_LAYER2_CTL);
-            break;
-        
-        case LAYER3 :
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            reg = (reg & ~(BIT_MASK(4))) | (0 << 4);                //close 422
-            writel(reg, vo->base + VO_LAYER3_CTL);
-
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            reg = (reg & ~(BIT_MASK(8))) | ((1 << 8));                //xuyaogai 420
-            writel(reg, vo->base + VO_LAYER3_CTL);
-            break;
-        
-        case OSD0 :
-            writel(0x3, vo->base + VO_DISP_OSD0_INFO);             //   RGB-32-bit rgb888
-            break;
-
-        case OSD1 :
-            writel(0x3, vo->base + VO_DISP_OSD1_INFO);
-            break;
-        
-        case OSD2 :
-            writel(0x3, vo->base + VO_DISP_OSD2_INFO);
-            break;
-
-        default:
-            printk("The number of osd does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_vo_blenth_init(struct kendryte_vo *vo)
-{
-    uint32_t reg = 0;
-    writel(0x07, vo->base + VO_LAYER0_SCALE_BLENTH);
-    writel(0x0f, vo->base + VO_LAYER1_IMG_IN_BLENTH);
-    writel(0x0f, vo->base + VO_LAYER2_IMG_IN_BLENTH);
-    writel(0x0f, vo->base + VO_LAYER3_IMG_IN_BLENTH);
-
-    reg = (0 << 6) + (0 << 4) + 0xf;   //6:mem[OSD_ADDR] is R  045: original order  0-3:dma _blenth
-    writel(0x4f, vo->base + VO_DISP_OSD0_DMA_CTRL);
-    writel(0x4f, vo->base + VO_DISP_OSD1_DMA_CTRL);
-    writel(0x4f, vo->base + VO_DISP_OSD2_DMA_CTRL);
-
-}
-
-
-// layer set 1 uv swap  ,  osd set 1 mem(argb)
-void kendryte_layer_set_uv_swap(struct kendryte_vo *vo, enum VO_LAYER layer, int swap)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case LAYER0 :
-            reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            reg = (reg & ~(BIT_MASK(24))) | (swap << 24); 
-
-            writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
-            break;
-
-        case LAYER1 :
-            reg = readl(vo->base + VO_LAYER1_CTL);
-            reg = (reg & ~(BIT_MASK(28))) | (swap << 28); 
-
-            writel(reg, vo->base + VO_LAYER1_CTL);
-            break;
-        
-        case LAYER2 :
-            reg = readl(vo->base + VO_LAYER2_CTL);
-            reg = (reg & ~(BIT_MASK(28))) | (swap << 28); 
-
-            writel(reg, vo->base + VO_LAYER2_CTL);
-            break;
-        
-        case LAYER3 :
-            reg = readl(vo->base + VO_LAYER3_CTL);
-            reg = (reg & ~(BIT_MASK(28))) | (swap << 28); 
-
-            writel(reg, vo->base + VO_LAYER3_CTL);
-            break;
-
-        case OSD0 :
-            reg = readl(vo->base + VO_DISP_OSD0_DMA_CTRL);
-            reg = (reg & ~(BIT_MASK(6))) | (swap << 6); 
-
-            writel(reg, vo->base + VO_DISP_OSD0_DMA_CTRL);             //   RGB-32-bit rgb888
-            break;
-
-        case OSD1 :
-            reg = readl(vo->base + VO_DISP_OSD1_DMA_CTRL);
-            reg = (reg & ~(BIT_MASK(6))) | (swap << 6); 
-
-            writel(reg, vo->base + VO_DISP_OSD1_DMA_CTRL);
-            break;
-        
-        case OSD2 :
-            reg = readl(vo->base + VO_DISP_OSD2_DMA_CTRL);
-            reg = (reg & ~(BIT_MASK(6))) | (swap << 6); 
-
-            writel(reg, vo->base + VO_DISP_OSD2_DMA_CTRL);
-            break;
-
-        default:
-            printk("The number of layer does not exist is %d", layer);
-            break;
-    }
-}
-
-
-void kendryte_layer_set_in_offset(struct kendryte_vo *vo, enum VO_LAYER layer, int offset)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case LAYER0 :
-
-            reg = offset;
-
-            writel(reg, vo->base + VO_LAYER0_IMG_IN_OFFSET);
-            break;
-
-        case LAYER1 :
-
-            reg = offset;
-
-            writel(reg, vo->base + VO_LAYER1_IMG_IN_OFFSET);
-            break;
-        
-        case LAYER2 :
-
-            reg = offset;
-
-            writel(reg, vo->base + VO_LAYER2_IMG_IN_OFFSET);
-            break;
-        
-        case LAYER3 :
-
-            reg = offset;
-
-            writel(reg, vo->base + VO_LAYER3_IMG_IN_OFFSET);
-            break;
-
-
-        default:
-            printk("The number of layer does not exist is %d", layer);
-            break;
-    }
-}
-
-void kendryte_display_crtl(struct kendryte_vo *vo, int status)
-{
-    if(status == 0)
-    {
-        writel(0x0, vo->base + VO_DISP_ENABLE);
-    }
-    else
-    {
-        // open display,close all plan
-        writel(0x80, vo->base + VO_DISP_ENABLE);
-    }
-}
-
-
-void kendryte_vo_set_config_done(struct kendryte_vo *vo)
-{
-    writel(0x11, vo->base + VO_REG_LOAD_CTL);
-}
-
-
-void kendryte_vo_set_config_mix(struct kendryte_vo *vo)
-{
-
-    
-    writel(0x7f, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_EN);
-    writel(0xffffffff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA0);
-    writel(0xffffffff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA1);
-    writel(0x76543210, vo->base + ADDR_VO_DISP_MIX_SEL);
-
-    // config csc 
-    writel(0x1, vo->base + ADDR_VO_DISP_YUV2RGB_CTL);
-    // disp gamma enable
-    writel(0x0, vo->base + ADDR_VO_DISP_CLUT_CTL);
-    // disp dith enable
-    writel(0x1, vo->base + ADDR_VO_DISP_DITH_CTL);
-
-    writel(0x10001, vo->base + VO_OSD_RGB2YUV_CTL);
-
-    writel(0xff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_EN);
-    
-    //close vo irq
-    writel(0x0, vo->base + ADDR_VO_DISP_IRQ0_CTL);
-    writel(0x0, vo->base + ADDR_VO_DISP_IRQ1_CTL);
-    writel(0x0, vo->base + ADDR_VO_DISP_IRQ2_CTL);
-
-    writel(0x80300, vo->base + VO_DISP_CTL);
-
-    kendryte_display_crtl(vo, 0);              // open 0  close  1
-
-    // ????
-    writel(0x077F8437, vo->base + 0x780);
-
-}
-
-
-void kendryte_vo_clear_intr(struct kendryte_vo *vop)
-{
-    writel(0xffffffff, vop->base + ADDR_VO_DISP_IRQ_STATUS);
-}
-
-
-void kendryte_vo_set_irq(struct kendryte_vo *vop, int status)
-{
-     // k510 irq only use vsync irq
-    uint32_t reg = 0;
-   
-    reg = status << 20;
-    writel(reg, vop->base + ADDR_VO_DISP_IRQ0_CTL);
-    
-}
-
-void kendryte_vo_get_reg_val(struct kendryte_vo *vop)
-{
-    int i = 0;
-
-    for(i = 0; i < 0x4A0; i = i + 4)  //0x49c
-    {
-    	printk("VO REG:Reg[0x%x]= 0x%x\n", i, readl(vop->base + i));
-    }
-
-}
-
-int kendryte_vo_draw_frame(struct kendryte_vo *vop, struct vo_draw_frame *frame)
-{
-    uint32_t reg = 0;
-
-
-    U_VO_REMAP_CTRL_FILL_INFO_AREA_0  info0_udata;
-    U_VO_REMAP_CTRL_FILL_INFO_AREA_1  info1_udata;
-    U_VO_REMAP_CTRL_FILL_DATA_AREA_0  data_udata;
-
-
-    if(frame->frame_num > 31 || frame->frame_num < 0 )
-    {
-        return -1;
-    }
-
-
-    // set flil info area 0 0           base = vo->base + 0x600 + (frame->frame_num * 4 * 2 )
-    reg = ADDR_VO_DISP_DRAW_FRAME + (frame->frame_num * 4 * 2);
-    info0_udata.u32 = readl(vop->base + reg);
-
-    info0_udata.bits.line_draw_en     = frame->draw_en;
-    info0_udata.bits.v_line_u_en      = 0;
-    info0_udata.bits.h_line_b_en      = 0;
-    info0_udata.bits.v_line_l_en      = 0;
-    info0_udata.bits.v_line_r_en      = 0;
-    info0_udata.bits.line_start_pos_x = frame->line_x_start;
-    info0_udata.bits.line_end_pos_x   = frame->line_x_end;//frame->line_y_start;
-    writel(info0_udata.u32, vop->base + reg);
-
-
-    // set fill info area 0 1           base = vo->base + 0x600 + (frame->frame_num * 4 * 2 + 0x4)
-    reg = ADDR_VO_DISP_DRAW_FRAME + (frame->frame_num * 4 * 2 + 0x4);
-    info1_udata.u32 = readl(vop->base + reg);
-
-    info1_udata.bits.line_start_pos_y = frame->line_y_start;//frame->line_x_end;
-    info1_udata.bits.line_end_pos_y   = frame->line_y_end;
-    info1_udata.bits.line_width_h     = 0;
-    info1_udata.bits.line_width_l     = 5;
-	writel(info1_udata.u32, vop->base + reg);
-
-    // set fill data area 0 0           base = vo->base + 0x600 + 0x100
-    reg = ADDR_VO_DISP_DRAW_FRAME + 0x100 + (frame->frame_num * 4);
-    data_udata.u32 = readl(vop->base + reg);
-
-    data_udata.bits.fill_value_y      = 47;
-    data_udata.bits.fill_value_cb     = 104;
-    data_udata.bits.fill_value_cr     = 226;
-    data_udata.bits.fill_alpha        = 0;
-    writel(data_udata.u32, vop->base + reg);
-
-    return 0;
-}
-
-
-void kendryte_vo_set_osd_alpha_tpye(struct kendryte_vo *vo, enum VO_LAYER layer, int type)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case OSD0 :
-            reg = readl(vo->base + VO_DISP_OSD0_INFO);
-            reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
-
-            writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-32-bit rgb888
-            break;
-
-        case OSD1 :
-            reg = readl(vo->base + VO_DISP_OSD1_INFO);
-            reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
-
-            writel(reg, vo->base + VO_DISP_OSD1_INFO);
-            break;
-        
-        case OSD2 :
-            reg = readl(vo->base + VO_DISP_OSD2_INFO);
-            reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
-
-            writel(reg, vo->base + VO_DISP_OSD2_INFO);
-            break;
-
-        default:
-            printk("The type of layer does not exist is %d", layer);
-            break;
-    }
-
-  
-}
-
-int kendryte_vo_osd_set_rgb2yuv_enable(struct kendryte_vo *vo, enum VO_LAYER layer)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case OSD0 :
-            reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
-            reg = (reg & ~(BIT_MASK(0))) | (1 << 0); 
-            writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
-            break;
-        
-        case OSD1:
-            reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
-            reg = (reg & ~(BIT_MASK(8))) | (1 << 8); 
-            writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
-            break;
-
-        case OSD2:
-            reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
-            reg = (reg & ~(BIT_MASK(16))) | (1 << 16); 
-            writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
-            break;
-        
-        default:
-            break;
-    }
-}
-
-int kendryte_vo_osd_set_format(struct kendryte_vo *vo, enum VO_LAYER layer, int type)
-{
-    uint32_t reg = 0;
-
-    switch(layer)
-    {
-        case OSD0 :
-            reg = readl(vo->base + VO_DISP_OSD0_INFO);
-            switch(type)
-            {
-                case VOP_FMT_ARGB8888:
-                    reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-32-bit argb888
-
-                    break;
-
-                case VOP_FMT_RGB888:
-                    reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-24-bit rgb888
-                    break;
-
-                case VOP_FMT_RGB565:
-                    reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-16-bit rgb565
-                    break;
-
-                case VOP_FMT_ARGB4444:
-                    reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-24-bit rgb4444
-                    break;
-                    
-                case VOP_FMT_ARGB1555:
-                    reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD0_INFO);             //   RGB-25-bit rgb1555
-                    break;
-
-                default :
-                    break;
-            }
-            
-            break;
-
-        case OSD1 :
-            reg = readl(vo->base + VO_DISP_OSD1_INFO);
-            switch(type)
-            {
-                case VOP_FMT_ARGB8888:
-                    reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD1_INFO);             //   RGB-32-bit argb888
-
-                    break;
-
-                case VOP_FMT_RGB888:
-                    reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD1_INFO);             //   RGB-24-bit rgb888
-                    break;
-                    
-                case VOP_FMT_RGB565:
-                    reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD1_INFO);             //   RGB-16-bit rgb565
-                    break;
-
-                case VOP_FMT_ARGB4444:
-                    reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD1_INFO);             //   RGB-24-bit rgb4444
-                    break;
-
-                case VOP_FMT_ARGB1555:
-                    reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD1_INFO);             //   RGB-25-bit rgb1555
-                    break;
-
-                default :
-                    break;
-            }
-            break;
-        
-        case OSD2 :
-            reg = readl(vo->base + VO_DISP_OSD2_INFO);
-            switch(type)
-            {
-                case VOP_FMT_ARGB8888:
-                    reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD2_INFO);             //   RGB-32-bit argb888
-                    break;
-
-                case VOP_FMT_RGB888:
-                    reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD2_INFO);             //   RGB-24-bit rgb888
-                    break;
-
-                case VOP_FMT_RGB565:
-                    reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD2_INFO);             //   RGB-16-bit rgb565
-                    break;
-
-                case VOP_FMT_ARGB4444:
-                    reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD2_INFO);             //   RGB-24-bit rgb4444
-                    break;
-
-                case VOP_FMT_ARGB1555:
-                    reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
-                    writel(reg, vo->base + VO_DISP_OSD2_INFO);             //   RGB-25-bit rgb1555
-                    break;
-
-                default :
-                    break;
-            }
-            break;
-
-        default:
-            printk("The type of layer does not exist is %d", layer);
-            break;
-    }
-}
+void kendryte_set_layer_enable(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       uint32_t status)
+{
+	uint32_t reg = 0;
+	uint32_t val = 0;
+	switch (layer) {
+	case LAYER0:
+
+		writel(status, vo->base + VO_LAYER0_CTL);
+
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(0))) | (status << 0);
+		writel(val, vo->base + VO_DISP_ENABLE);
+
+		break;
+
+	case LAYER1:
+
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		val = (reg & ~(BIT_MASK(1))) | (status << 0);
+		writel(val, vo->base + VO_LAYER1_CTL);
+
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(1))) | (status << 1);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	case LAYER2:
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		val = (reg & ~(BIT_MASK(1))) | (status << 0);
+		writel(val, vo->base + VO_LAYER2_CTL);
+
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(2))) | (status << 2);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	case LAYER3:
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		val = (reg & ~(BIT_MASK(1))) | (status << 0);
+		writel(val, vo->base + VO_LAYER3_CTL);
+
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(3))) | (status << 3);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	case OSD0:
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(4))) | (status << 4);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	case OSD1:
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(5))) | (status << 5);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	case OSD2:
+		reg = readl(vo->base + VO_DISP_ENABLE);
+		val = (reg & ~(BIT_MASK(6))) | (status << 6);
+		writel(val, vo->base + VO_DISP_ENABLE);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_set_video_layer_postion(struct kendryte_vo *vo,
+				      enum VO_LAYER layer, struct drm_rect *src,
+				      struct drm_rect *dst,
+				      struct drm_display_mode *mode)
+{
+	uint32_t val;
+	uint32_t src_width = drm_rect_width(src) >> 16;
+	uint32_t src_height = drm_rect_height(src) >> 16;
+	uint32_t dst_width = drm_rect_width(dst);
+	uint32_t dst_height = drm_rect_height(dst);
+	uint32_t has = mode->crtc_htotal - mode->crtc_hsync_start + dst->x1;
+	uint32_t vas = mode->crtc_vtotal - mode->crtc_vsync_start + dst->y1 + 1;
+	uint32_t in_size = (src_width - 1) + ((src_height - 1) << 16);
+	uint32_t in_offset = (src->x1 / 8) + (src->y1 << 16);
+	uint32_t xctl = has + ((dst_width + has - 1) << 16);
+	uint32_t yctl = vas + ((dst_height + vas - 1) << 16);
+
+	switch (layer) {
+	case LAYER0:
+		writel(in_size, vo->base + VO_DISP_LAYER0_IN_ACT_SIZE);
+		val = (dst_width - 1) + ((dst_height - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER0_OUT_ACT_SIZE);
+		writel(in_offset, vo->base + VO_LAYER0_IMG_IN_OFFSET);
+		val = (src_height / dst_height) |
+		      ((((src_height << 16) / dst_height) & 0xFFFF) << 16);
+		writel(val, vo->base + 0x174);
+		val = (src_width / dst_width) |
+		      ((((src_width << 16) / dst_width) & 0xFFFF) << 16);
+		writel(val, vo->base + 0x17c);
+		writel(xctl, vo->base + VO_DISP_LAYER0_XCTL);
+		writel(yctl, vo->base + VO_DISP_LAYER0_YCTL);
+		break;
+	case LAYER1:
+		writel(in_size, vo->base + VO_DISP_LAYER1_ACT_SIZE);
+		writel(in_offset, vo->base + VO_LAYER1_IMG_IN_OFFSET);
+		writel(xctl, vo->base + VO_DISP_LAYER1_XCTL);
+		writel(yctl, vo->base + VO_DISP_LAYER1_YCTL);
+		break;
+	case LAYER2:
+		writel(in_size, vo->base + VO_DISP_LAYER2_ACT_SIZE);
+		writel(in_offset, vo->base + VO_LAYER2_IMG_IN_OFFSET);
+		writel(xctl, vo->base + VO_DISP_LAYER2_XCTL);
+		writel(yctl, vo->base + VO_DISP_LAYER2_YCTL);
+		break;
+	case LAYER3:
+		writel(in_size, vo->base + VO_DISP_LAYER3_ACT_SIZE);
+		writel(in_offset, vo->base + VO_LAYER3_IMG_IN_OFFSET);
+		writel(xctl, vo->base + VO_DISP_LAYER3_XCTL);
+		writel(yctl, vo->base + VO_DISP_LAYER3_YCTL);
+		break;
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_set_layer_postion(struct kendryte_vo *vo, enum VO_LAYER layer,
+				uint32_t vpos, uint32_t hpos, uint32_t v_offset,
+				uint32_t h_offset,
+				struct drm_display_mode *mode)
+{
+	uint32_t val;
+	uint32_t has = mode->crtc_htotal - mode->crtc_hsync_start + h_offset;
+	uint32_t vas =
+		mode->crtc_vtotal - mode->crtc_vsync_start + v_offset + 1;
+
+	switch (layer) {
+	case OSD0:
+		// set osd0 size
+		val = (vpos << 16) + hpos;
+		writel(val, vo->base + VO_DISP_OSD0_ACT_SIZE);
+		// set osd0 x start and stop
+		val = has + ((hpos + has - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER4_XCTL);
+		// set osd0 y start and stop
+		val = vas + ((vpos + vas - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER4_YCTL);
+		break;
+	case OSD1:
+		// set osd1 size
+		val = (vpos << 16) + hpos;
+		writel(val, vo->base + VO_DISP_OSD1_ACT_SIZE);
+		// set osd1 x start and stop
+		val = has + ((hpos + has - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER5_XCTL);
+		// set osd1 y start and stop
+		val = vas + ((vpos + vas - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER5_YCTL);
+		break;
+	case OSD2:
+		// set osd2 size
+		val = (vpos << 16) + hpos;
+		writel(val, vo->base + VO_DISP_OSD2_ACT_SIZE);
+		// set osd2 x start and stop
+		val = has + ((hpos + has - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER6_XCTL);
+		// set osd2 y start and stop
+		val = vas + ((vpos + vas - 1) << 16);
+		writel(val, vo->base + VO_DISP_LAYER6_YCTL);
+		break;
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_set_layer_stride(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       uint32_t stride)
+{
+	uint32_t val;
+
+	switch (layer) {
+	case LAYER0:
+		writel(stride, vo->base + VO_LAYER0_IMG_IN_STRIDE);
+		break;
+
+	case LAYER1:
+
+		writel(stride, vo->base + VO_LAYER1_IMG_IN_STRIDE);
+		break;
+
+	case LAYER2:
+
+		writel(stride, vo->base + VO_LAYER2_IMG_IN_STRIDE);
+		break;
+
+	case LAYER3:
+		writel(stride, vo->base + VO_LAYER3_IMG_IN_STRIDE);
+		break;
+
+	case OSD0:
+		val = (stride << 16) + stride;
+		writel(val, vo->base + VO_DISP_OSD0_STRIDE);
+		break;
+	case OSD1:
+		val = (stride << 16) + stride;
+		writel(val, vo->base + VO_DISP_OSD1_STRIDE);
+		break;
+	case OSD2:
+		val = (stride << 16) + stride;
+		writel(val, vo->base + VO_DISP_OSD2_STRIDE);
+		break;
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_set_layer_y_endian(struct kendryte_vo *vo, enum VO_LAYER layer,
+				 enum VO_VIDEOLAYER_Y_ENDIAN_E ENDIAN)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case LAYER0:
+		reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		reg = (reg & ~(GENMASK(9, 8))) | (ENDIAN << 8);
+		writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		break;
+
+	case LAYER1:
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
+		writel(reg, vo->base + VO_LAYER1_CTL);
+		break;
+
+	case LAYER2:
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
+		writel(reg, vo->base + VO_LAYER2_CTL);
+
+		break;
+
+	case LAYER3:
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		reg = (reg & ~(2 << 12)) | (ENDIAN << 12);
+		writel(reg, vo->base + VO_LAYER3_CTL);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_set_layer_uv_endian(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  enum VO_VIDEOLAYER_UV_ENDIAN_E ENDIAN)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case LAYER0:
+		reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		reg = (reg & ~(GENMASK(14, 12))) | (ENDIAN << 12);
+		writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		break;
+
+	case LAYER1:
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
+		writel(reg, vo->base + VO_LAYER1_CTL);
+		break;
+
+	case LAYER2:
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
+		writel(reg, vo->base + VO_LAYER2_CTL);
+		break;
+
+	case LAYER3:
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		reg = (reg & ~(GENMASK(18, 16))) | (ENDIAN << 16);
+		writel(reg, vo->base + VO_LAYER3_CTL);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+/*
+    mode 0 : Hw switch the pingpang address automatically
+    mode 1 : w switch the pingpang address according to register
+
+*/
+void kendryte_vo_set_pingpang_mode(struct kendryte_vo *vo, enum VO_LAYER layer,
+				   enum VO_LAYER_PINGPANG_MODE mode)
+{
+	uint32_t reg = 0x1100;
+
+	switch (layer) {
+	case LAYER0:
+		writel(reg, vo->base + VO_LAYER0_PINGPANG_SEL_MODE);
+		break;
+
+	case LAYER1:
+		writel(reg, vo->base + VO_LAYER1_PINGPANG_SEL_MODE);
+		break;
+
+	case LAYER2:
+		writel(reg, vo->base + VO_LAYER2_PINGPANG_SEL_MODE);
+		break;
+
+	case LAYER3:
+		writel(reg, vo->base + VO_LAYER3_PINGPANG_SEL_MODE);
+		break;
+
+	case OSD0:
+		writel(reg, vo->base + VO_LAYER4_PINGPANG_SEL_MODE);
+		break;
+
+	case OSD1:
+		writel(reg, vo->base + VO_LAYER5_PINGPANG_SEL_MODE);
+		break;
+
+	case OSD2:
+		writel(reg, vo->base + VO_LAYER6_PINGPANG_SEL_MODE);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_vo_set_layer_format(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  enum VO_LAYER_FORMATS formats)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case LAYER0:
+		reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		reg = (reg & ~(BIT_MASK(0))) | (0x8 << 0); // 420
+		writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		break;
+
+	case LAYER1:
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		reg = (reg & ~(BIT_MASK(4))) | (0 << 4); //close 422
+		writel(reg, vo->base + VO_LAYER1_CTL);
+
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		reg = (reg & ~(BIT_MASK(8))) | (1 << 8); //xuyaogai 420
+		writel(reg, vo->base + VO_LAYER1_CTL);
+		break;
+
+	case LAYER2:
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		reg = (reg & ~(BIT_MASK(4))) | (0 << 4); //close 422
+		writel(reg, vo->base + VO_LAYER2_CTL);
+
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		reg = (reg & ~(BIT_MASK(8))) | (1 << 8); //xuyaogai 420
+		writel(reg, vo->base + VO_LAYER2_CTL);
+		break;
+
+	case LAYER3:
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		reg = (reg & ~(BIT_MASK(4))) | (0 << 4); //close 422
+		writel(reg, vo->base + VO_LAYER3_CTL);
+
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		reg = (reg & ~(BIT_MASK(8))) | ((1 << 8)); //xuyaogai 420
+		writel(reg, vo->base + VO_LAYER3_CTL);
+		break;
+
+	case OSD0:
+		writel(0x3,
+		       vo->base + VO_DISP_OSD0_INFO); //   RGB-32-bit rgb888
+		break;
+
+	case OSD1:
+		writel(0x3, vo->base + VO_DISP_OSD1_INFO);
+		break;
+
+	case OSD2:
+		writel(0x3, vo->base + VO_DISP_OSD2_INFO);
+		break;
+
+	default:
+		printk("The number of osd does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_vo_blenth_init(struct kendryte_vo *vo)
+{
+	uint32_t reg = 0;
+	writel(0x07, vo->base + VO_LAYER0_SCALE_BLENTH);
+	writel(0x0f, vo->base + VO_LAYER1_IMG_IN_BLENTH);
+	writel(0x0f, vo->base + VO_LAYER2_IMG_IN_BLENTH);
+	writel(0x0f, vo->base + VO_LAYER3_IMG_IN_BLENTH);
+
+	reg = (0 << 6) + (0 << 4) +
+	      0xf; //6:mem[OSD_ADDR] is R  045: original order  0-3:dma _blenth
+	writel(0x4f, vo->base + VO_DISP_OSD0_DMA_CTRL);
+	writel(0x4f, vo->base + VO_DISP_OSD1_DMA_CTRL);
+	writel(0x4f, vo->base + VO_DISP_OSD2_DMA_CTRL);
+}
+
+// layer set 1 uv swap  ,  osd set 1 mem(argb)
+void kendryte_layer_set_uv_swap(struct kendryte_vo *vo, enum VO_LAYER layer,
+				int swap)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case LAYER0:
+		reg = readl(vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		reg = (reg & ~(BIT_MASK(24))) | (swap << 24);
+
+		writel(reg, vo->base + VO_LAYER0_IMG_IN_DAT_MODE);
+		break;
+
+	case LAYER1:
+		reg = readl(vo->base + VO_LAYER1_CTL);
+		reg = (reg & ~(BIT_MASK(28))) | (swap << 28);
+
+		writel(reg, vo->base + VO_LAYER1_CTL);
+		break;
+
+	case LAYER2:
+		reg = readl(vo->base + VO_LAYER2_CTL);
+		reg = (reg & ~(BIT_MASK(28))) | (swap << 28);
+
+		writel(reg, vo->base + VO_LAYER2_CTL);
+		break;
+
+	case LAYER3:
+		reg = readl(vo->base + VO_LAYER3_CTL);
+		reg = (reg & ~(BIT_MASK(28))) | (swap << 28);
+
+		writel(reg, vo->base + VO_LAYER3_CTL);
+		break;
+
+	case OSD0:
+		reg = readl(vo->base + VO_DISP_OSD0_DMA_CTRL);
+		reg = (reg & ~(BIT_MASK(6))) | (swap << 6);
+
+		writel(reg,
+		       vo->base +
+			       VO_DISP_OSD0_DMA_CTRL); //   RGB-32-bit rgb888
+		break;
+
+	case OSD1:
+		reg = readl(vo->base + VO_DISP_OSD1_DMA_CTRL);
+		reg = (reg & ~(BIT_MASK(6))) | (swap << 6);
+
+		writel(reg, vo->base + VO_DISP_OSD1_DMA_CTRL);
+		break;
+
+	case OSD2:
+		reg = readl(vo->base + VO_DISP_OSD2_DMA_CTRL);
+		reg = (reg & ~(BIT_MASK(6))) | (swap << 6);
+
+		writel(reg, vo->base + VO_DISP_OSD2_DMA_CTRL);
+		break;
+
+	default:
+		printk("The number of layer does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_layer_set_in_offset(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  int offset)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case LAYER0:
+
+		reg = offset;
+
+		writel(reg, vo->base + VO_LAYER0_IMG_IN_OFFSET);
+		break;
+
+	case LAYER1:
+
+		reg = offset;
+
+		writel(reg, vo->base + VO_LAYER1_IMG_IN_OFFSET);
+		break;
+
+	case LAYER2:
+
+		reg = offset;
+
+		writel(reg, vo->base + VO_LAYER2_IMG_IN_OFFSET);
+		break;
+
+	case LAYER3:
+
+		reg = offset;
+
+		writel(reg, vo->base + VO_LAYER3_IMG_IN_OFFSET);
+		break;
+
+	default:
+		printk("The number of layer does not exist is %d", layer);
+		break;
+	}
+}
+
+void kendryte_display_crtl(struct kendryte_vo *vo, int status)
+{
+	if (status == 0) {
+		writel(0x0, vo->base + VO_DISP_ENABLE);
+	} else {
+		// open display,close all plan
+		writel(0x80, vo->base + VO_DISP_ENABLE);
+	}
+}
+
+void kendryte_vo_set_config_done(struct kendryte_vo *vo)
+{
+	writel(0x11, vo->base + VO_REG_LOAD_CTL);
+}
+
+void kendryte_vo_set_config_mix(struct kendryte_vo *vo)
+{
+	writel(0x7f, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_EN);
+	writel(0xffffffff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA0);
+	writel(0xffffffff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA1);
+	writel(0x76543210, vo->base + ADDR_VO_DISP_MIX_SEL);
+
+	// config csc
+	writel(0x1, vo->base + ADDR_VO_DISP_YUV2RGB_CTL);
+	// disp gamma enable
+	writel(0x0, vo->base + ADDR_VO_DISP_CLUT_CTL);
+	// disp dith enable
+	writel(0x1, vo->base + ADDR_VO_DISP_DITH_CTL);
+
+	writel(0x10001, vo->base + VO_OSD_RGB2YUV_CTL);
+
+	writel(0xff, vo->base + ADDR_VO_DISP_MIX_LAYER_GLB_EN);
+
+	//close vo irq
+	writel(0x0, vo->base + ADDR_VO_DISP_IRQ0_CTL);
+	writel(0x0, vo->base + ADDR_VO_DISP_IRQ1_CTL);
+	writel(0x0, vo->base + ADDR_VO_DISP_IRQ2_CTL);
+
+	writel(0x80300, vo->base + VO_DISP_CTL);
+
+	kendryte_display_crtl(vo, 0); // open 0  close  1
+
+	// ????
+	writel(0x077F8437, vo->base + 0x780);
+}
+
+void kendryte_vo_clear_intr(struct kendryte_vo *vop)
+{
+	writel(0xffffffff, vop->base + ADDR_VO_DISP_IRQ_STATUS);
+}
+
+void kendryte_vo_set_irq(struct kendryte_vo *vop, int status)
+{
+	// k510 irq only use vsync irq
+	uint32_t reg = 0;
+
+	reg = status << 20;
+	writel(reg, vop->base + ADDR_VO_DISP_IRQ0_CTL);
+}
+
+void kendryte_vo_get_reg_val(struct kendryte_vo *vop)
+{
+	int i = 0;
+
+	for (i = 0; i < 0x4A0; i = i + 4) //0x49c
+	{
+		printk("VO REG:Reg[0x%x]= 0x%x\n", i, readl(vop->base + i));
+	}
+}
+
+int kendryte_vo_draw_frame(struct kendryte_vo *vop, struct vo_draw_frame *frame)
+{
+	uint32_t reg = 0;
+
+	U_VO_REMAP_CTRL_FILL_INFO_AREA_0 info0_udata;
+	U_VO_REMAP_CTRL_FILL_INFO_AREA_1 info1_udata;
+	U_VO_REMAP_CTRL_FILL_DATA_AREA_0 data_udata;
+
+	if (frame->frame_num > 31 || frame->frame_num < 0) {
+		return -1;
+	}
+
+	// set flil info area 0 0           base = vo->base + 0x600 + (frame->frame_num * 4 * 2 )
+	reg = ADDR_VO_DISP_DRAW_FRAME + (frame->frame_num * 4 * 2);
+	info0_udata.u32 = readl(vop->base + reg);
+
+	info0_udata.bits.line_draw_en = frame->draw_en;
+	info0_udata.bits.v_line_u_en = 0;
+	info0_udata.bits.h_line_b_en = 0;
+	info0_udata.bits.v_line_l_en = 0;
+	info0_udata.bits.v_line_r_en = 0;
+	info0_udata.bits.line_start_pos_x = frame->line_x_start;
+	info0_udata.bits.line_end_pos_x =
+		frame->line_x_end; //frame->line_y_start;
+	writel(info0_udata.u32, vop->base + reg);
+
+	// set fill info area 0 1           base = vo->base + 0x600 + (frame->frame_num * 4 * 2 + 0x4)
+	reg = ADDR_VO_DISP_DRAW_FRAME + (frame->frame_num * 4 * 2 + 0x4);
+	info1_udata.u32 = readl(vop->base + reg);
+
+	info1_udata.bits.line_start_pos_y =
+		frame->line_y_start; //frame->line_x_end;
+	info1_udata.bits.line_end_pos_y = frame->line_y_end;
+	info1_udata.bits.line_width_h = 0;
+	info1_udata.bits.line_width_l = 5;
+	writel(info1_udata.u32, vop->base + reg);
+
+	// set fill data area 0 0           base = vo->base + 0x600 + 0x100
+	reg = ADDR_VO_DISP_DRAW_FRAME + 0x100 + (frame->frame_num * 4);
+	data_udata.u32 = readl(vop->base + reg);
+
+	data_udata.bits.fill_value_y = 47;
+	data_udata.bits.fill_value_cb = 104;
+	data_udata.bits.fill_value_cr = 226;
+	data_udata.bits.fill_alpha = 0;
+	writel(data_udata.u32, vop->base + reg);
+
+	return 0;
+}
+
+void kendryte_vo_set_osd_alpha_tpye(struct kendryte_vo *vo, enum VO_LAYER layer,
+				    int type)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case OSD0:
+		reg = readl(vo->base + VO_DISP_OSD0_INFO);
+		reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
+
+		writel(reg,
+		       vo->base + VO_DISP_OSD0_INFO); //   RGB-32-bit rgb888
+		break;
+
+	case OSD1:
+		reg = readl(vo->base + VO_DISP_OSD1_INFO);
+		reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
+
+		writel(reg, vo->base + VO_DISP_OSD1_INFO);
+		break;
+
+	case OSD2:
+		reg = readl(vo->base + VO_DISP_OSD2_INFO);
+		reg = (reg & ~(GENMASK(6, 4))) | (type << 4);
+
+		writel(reg, vo->base + VO_DISP_OSD2_INFO);
+		break;
+
+	default:
+		printk("The type of layer does not exist is %d", layer);
+		break;
+	}
+}
+
+int kendryte_vo_osd_set_rgb2yuv_enable(struct kendryte_vo *vo,
+				       enum VO_LAYER layer)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case OSD0:
+		reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
+		reg = (reg & ~(BIT_MASK(0))) | (1 << 0);
+		writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
+		break;
+
+	case OSD1:
+		reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
+		reg = (reg & ~(BIT_MASK(8))) | (1 << 8);
+		writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
+		break;
+
+	case OSD2:
+		reg = readl(vo->base + VO_OSD_RGB2YUV_CTL);
+		reg = (reg & ~(BIT_MASK(16))) | (1 << 16);
+		writel(reg, vo->base + VO_OSD_RGB2YUV_CTL);
+		break;
+
+	default:
+		break;
+	}
+}
+
+int kendryte_vo_osd_set_format(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       int type)
+{
+	uint32_t reg = 0;
+
+	switch (layer) {
+	case OSD0:
+		reg = readl(vo->base + VO_DISP_OSD0_INFO);
+		switch (type) {
+		case VOP_FMT_ARGB8888:
+			reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD0_INFO); //   RGB-32-bit argb888
+
+			break;
+
+		case VOP_FMT_RGB888:
+			reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD0_INFO); //   RGB-24-bit rgb888
+			break;
+
+		case VOP_FMT_RGB565:
+			reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD0_INFO); //   RGB-16-bit rgb565
+			break;
+
+		case VOP_FMT_ARGB4444:
+			reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD0_INFO); //   RGB-24-bit rgb4444
+			break;
+
+		case VOP_FMT_ARGB1555:
+			reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD0_INFO); //   RGB-25-bit rgb1555
+			break;
+
+		default:
+			break;
+		}
+
+		break;
+
+	case OSD1:
+		reg = readl(vo->base + VO_DISP_OSD1_INFO);
+		switch (type) {
+		case VOP_FMT_ARGB8888:
+			reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD1_INFO); //   RGB-32-bit argb888
+
+			break;
+
+		case VOP_FMT_RGB888:
+			reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD1_INFO); //   RGB-24-bit rgb888
+			break;
+
+		case VOP_FMT_RGB565:
+			reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD1_INFO); //   RGB-16-bit rgb565
+			break;
+
+		case VOP_FMT_ARGB4444:
+			reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD1_INFO); //   RGB-24-bit rgb4444
+			break;
+
+		case VOP_FMT_ARGB1555:
+			reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD1_INFO); //   RGB-25-bit rgb1555
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	case OSD2:
+		reg = readl(vo->base + VO_DISP_OSD2_INFO);
+		switch (type) {
+		case VOP_FMT_ARGB8888:
+			reg = (reg & ~(GENMASK(6, 0))) | (0x53 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD2_INFO); //   RGB-32-bit argb888
+			break;
+
+		case VOP_FMT_RGB888:
+			reg = (reg & ~(GENMASK(3, 0))) | (0 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD2_INFO); //   RGB-24-bit rgb888
+			break;
+
+		case VOP_FMT_RGB565:
+			reg = (reg & ~(GENMASK(3, 0))) | (2 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD2_INFO); //   RGB-16-bit rgb565
+			break;
+
+		case VOP_FMT_ARGB4444:
+			reg = (reg & ~(GENMASK(3, 0))) | (4 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD2_INFO); //   RGB-24-bit rgb4444
+			break;
+
+		case VOP_FMT_ARGB1555:
+			reg = (reg & ~(GENMASK(3, 0))) | (5 << 0);
+			writel(reg,
+			       vo->base +
+				       VO_DISP_OSD2_INFO); //   RGB-25-bit rgb1555
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	default:
+		printk("The type of layer does not exist is %d", layer);
+		break;
+	}
+}
diff --git a/drivers/gpu/drm/canaan/kendryte_vo.h b/drivers/gpu/drm/canaan/kendryte_vo.h
index 81776815..5d5bec47 100755
--- a/drivers/gpu/drm/canaan/kendryte_vo.h
+++ b/drivers/gpu/drm/canaan/kendryte_vo.h
@@ -4,474 +4,485 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
 */
-#ifndef _KENDRYTE_VO_H_
-#define _KENDRYTE_VO_H_
-
-#include "kendryte_layer.h"
-#include <drm/drm_flip_work.h>
-
-
-#define VO_SOFT_RST_CTL                                             0x00
-#define VO_REG_LOAD_CTL                                             0x04
-#define VO_DMA_SW_CTL                                               0x08
-#define VO_DMA_RD_CTL_OUT                                           0x0c
-#define VO_DMA_ARB_MODE                                             0x10
-#define VO_DMA_WEIGHT_RD0                                           0x24
-#define VO_DMA_WEIGHT_RD1                                           0x28
-#define VO_DMA_WEIGHT_RD2                                           0x2c
-#define VO_DMA_WEIGHT_RD3                                           0x30
-
-#define VO_DMA_PRIORITY_RD_1                                        0x40
-#define VO_DMA_ID_RD_0                                              0x4c
-#define VO_DMA_ID_RD_1                                              0x50
-
-#define VO_CONFIG_LINE_BASE                                         0x0600
-#define VO_HSCALE_BASE                                              0x8000
-#define VO_VSCALE_BASE                                              0x8C00
-#define VO_GAMMA_BASE                                               0xC000
-  
-
-#define VO_LAYER0_LINE0_BD_CTL                                      0x80
-#define VO_LAYER0_LINE1_BD_CTL                                      0x84
-#define VO_LAYER0_LINE2_BD_CTL                                      0x88
-#define VO_LAYER0_LINE3_BD_CTL                                      0x8C
-#define VO_LAYER1_BD_CTL                                            0x90
-#define VO_LAYER2_BD_CTL                                            0x94
-#define VO_LAYER3_BD_CTL                                            0x98
-#define VO_LAYER4_BD_CTL                                            0x9c
-#define VO_LAYER5_BD_CTL                                            0xa0
-#define VO_LAYER6_BD_CTL                                            0xa4
-
-//TIMING 
-#define VO_DISP_HSYNC_CTL                                           0x100
-#define VO_DISP_HSYNC1_CTL                                          0x104
-#define VO_DISP_VSYNC1_CTL                                          0x108
-#define VO_DISP_VSYNC2_CTL                                          0x110
-#define VO_DISP_HSYNC2_CTL                                          0x10c
-#define VO_DISP_TOTAL_SIZE                                          0x11C
-#define VO_DISP_XZONE_CTL                                           0x0C0
-#define VO_DISP_YZONE_CTL                                           0x0C4
-
-// OFFSET + ACTIVE
-#define VO_DISP_LAYER0_XCTL                                         0x0C8
-#define VO_DISP_LAYER0_YCTL                                         0x0CC
-#define VO_DISP_LAYER1_XCTL                                         0x0D0
-#define VO_DISP_LAYER1_YCTL                                         0x0D4
-#define VO_DISP_LAYER2_XCTL                                         0x0D8
-#define VO_DISP_LAYER2_YCTL                                         0x0DC
-#define VO_DISP_LAYER3_XCTL                                         0x0E0
-#define VO_DISP_LAYER3_YCTL                                         0x0E4
-#define VO_DISP_LAYER4_XCTL                                         0x0E8
-#define VO_DISP_LAYER4_YCTL                                         0x0EC
-#define VO_DISP_LAYER5_XCTL                                         0x0F0
-#define VO_DISP_LAYER5_YCTL                                         0x0F4
-#define VO_DISP_LAYER6_XCTL                                         0x0F8
-#define VO_DISP_LAYER6_YCTL                                         0x0FC
-
-// offset
-#define VO_LAYER0_IMG_IN_OFFSET                                     0x16C
-#define VO_LAYER1_IMG_IN_OFFSET                                     0x1D4
-#define VO_LAYER2_IMG_IN_OFFSET                                     0x214
-#define VO_LAYER3_IMG_IN_OFFSET                                     0x254
-
-// VO ACTIVE
-#define VO_DISP_OSD0_ACT_SIZE                                       0x284
-#define VO_DISP_OSD1_ACT_SIZE                                       0x2C4
-#define VO_DISP_OSD2_ACT_SIZE                                       0x304
-#define VO_DISP_LAYER0_IN_ACT_SIZE                                  0x15C
-#define VO_DISP_LAYER0_OUT_ACT_SIZE                                 0x160
-#define VO_DISP_LAYER1_ACT_SIZE                                     0x1E0
-#define VO_DISP_LAYER2_ACT_SIZE                                     0x220
-#define VO_DISP_LAYER3_ACT_SIZE                                     0x260
-
-//ADDR
-#define VO_DISP_LAYER0_Y_ADDR0                                    0x14C
-#define VO_DISP_LAYER0_Y_ADDR1                                    0x154
-#define VO_DISP_LAYER0_UV_ADDR0                                   0x150
-#define VO_DISP_LAYER0_UV_ADDR1                                   0x158
-
-#define VO_DISP_LAYER1_Y_ADDR0                                    0x1C4
-#define VO_DISP_LAYER1_Y_ADDR1                                    0x1CC
-#define VO_DISP_LAYER1_UV_ADDR0                                   0x1C8
-#define VO_DISP_LAYER1_UV_ADDR1                                   0x1D0
-
-#define VO_DISP_LAYER2_Y_ADDR0                                    0x204
-#define VO_DISP_LAYER2_Y_ADDR1                                    0x20c 
-#define VO_DISP_LAYER2_UV_ADDR0                                   0x208  
-#define VO_DISP_LAYER2_UV_ADDR1                                   0x210
-
-#define VO_DISP_LAYER3_Y_ADDR0                                    0x244
-#define VO_DISP_LAYER3_Y_ADDR1                                    0x24c
-#define VO_DISP_LAYER3_UV_ADDR0                                   0x248
-#define VO_DISP_LAYER3_UV_ADDR1                                   0x250
-
-#define VO_DISP_OSD0_VLU_ADDR0                                    0x288
-#define VO_DISP_OSD0_ALP_ADDR0                                    0x28C
-#define VO_DISP_OSD0_VLU_ADDR1                                    0x290
-#define VO_DISP_OSD0_ALP_ADDR1                                    0x294
-
-#define VO_DISP_OSD1_VLU_ADDR0                                    0x2C8
-#define VO_DISP_OSD1_ALP_ADDR0                                    0x2CC
-#define VO_DISP_OSD1_VLU_ADDR1                                    0x2D0
-#define VO_DISP_OSD1_ALP_ADDR1                                    0x2D4
-
-#define VO_DISP_OSD2_VLU_ADDR0                                    0x308
-#define VO_DISP_OSD2_ALP_ADDR0                                    0x30C
-#define VO_DISP_OSD2_VLU_ADDR1                                    0x310
-#define VO_DISP_OSD2_ALP_ADDR1                                    0x314
-
-//VO LAYER CRTL
-#define VO_LAYER0_CTL                                             0x140
-#define VO_LAYER0_IMG_IN_DAT_MODE                                 0x148            
-#define VO_LAYER1_CTL                                             0x1C0
-#define VO_LAYER2_CTL                                             0x200
-#define VO_LAYER3_CTL                                             0x240
-#define VO_DISP_ENABLE                                            0x118
-#define VO_DISP_CTL                                               0x114
-#define VO_DISP_OSD0_INFO                                         0x280
-#define VO_DISP_OSD1_INFO                                         0x2C0
-#define VO_DISP_OSD2_INFO                                         0x300
-
-//VO LAYER STRIDE
-#define VO_LAYER0_IMG_IN_STRIDE                                   0x164
-#define VO_LAYER1_IMG_IN_STRIDE                                   0x1DC
-#define VO_LAYER2_IMG_IN_STRIDE                                   0x21C
-#define VO_LAYER3_IMG_IN_STRIDE                                   0x25C
-#define VO_DISP_OSD0_STRIDE                                       0x29C
-#define VO_DISP_OSD1_STRIDE                                       0x2DC
-#define VO_DISP_OSD2_STRIDE                                       0x31C
-
-//dma burst length
-#define VO_LAYER0_SCALE_BLENTH                                    0x144
-#define VO_LAYER1_IMG_IN_BLENTH                                   0x1D8
-#define VO_LAYER2_IMG_IN_BLENTH                                   0x21C
-#define VO_LAYER3_IMG_IN_BLENTH                                   0x25C
-#define VO_DISP_OSD0_DMA_CTRL                                     0x298
-#define VO_DISP_OSD1_DMA_CTRL                                     0x2D8
-#define VO_DISP_OSD2_DMA_CTRL                                     0x318
-
-//VO PINPANG MODE SELSET
-#define VO_LAYER0_PINGPANG_SEL_MODE                               0x184
-#define VO_LAYER1_PINGPANG_SEL_MODE                               0x1E4
-#define VO_LAYER2_PINGPANG_SEL_MODE                               0x224
-#define VO_LAYER3_PINGPANG_SEL_MODE                               0x264
-#define VO_LAYER4_PINGPANG_SEL_MODE                               0x2A0
-#define VO_LAYER5_PINGPANG_SEL_MODE                               0x2E0
-#define VO_LAYER6_PINGPANG_SEL_MODE                               0x320
-
-#define VO_DISP_BACKGROUND                                        0x3D0
-#define ADDR_VO_DISP_MIX_LAYER_GLB_EN                             0x3c0
-#define ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA0                         0x3c4
-#define ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA1                         0x3c8
-#define ADDR_VO_DISP_MIX_SEL                                      0x3cc
-          
-#define ADDR_VO_DISP_YUV2RGB_CTL                                  0x380
-#define ADDR_VO_DISP_CLUT_CTL                                     0x3d8
-#define ADDR_VO_DISP_DITH_CTL                                     0x3d4
-#define VO_OSD_RGB2YUV_CTL                                        0x340
-
-#define ADDR_VO_DISP_IRQ0_CTL                                     0x3e0
-#define ADDR_VO_DISP_IRQ1_CTL                                     0x3e4
-#define ADDR_VO_DISP_IRQ2_CTL                                     0x3e8
-#define ADDR_VO_DISP_IRQ_STATUS                                   0x3ec
-
-#define ADDR_VO_DISP_DRAW_FRAME                                   0x600
+#ifndef _KENDRYTE_VO_H_
+#define _KENDRYTE_VO_H_
+
+#include "kendryte_layer.h"
+#include <drm/drm_flip_work.h>
+
+// clang-format off
+#define VO_SOFT_RST_CTL                                             0x00
+#define VO_REG_LOAD_CTL                                             0x04
+#define VO_DMA_SW_CTL                                               0x08
+#define VO_DMA_RD_CTL_OUT                                           0x0c
+#define VO_DMA_ARB_MODE                                             0x10
+#define VO_DMA_WEIGHT_RD0                                           0x24
+#define VO_DMA_WEIGHT_RD1                                           0x28
+#define VO_DMA_WEIGHT_RD2                                           0x2c
+#define VO_DMA_WEIGHT_RD3                                           0x30
+
+#define VO_DMA_PRIORITY_RD_1                                        0x40
+#define VO_DMA_ID_RD_0                                              0x4c
+#define VO_DMA_ID_RD_1                                              0x50
+
+#define VO_CONFIG_LINE_BASE                                         0x0600
+#define VO_HSCALE_BASE                                              0x8000
+#define VO_VSCALE_BASE                                              0x8C00
+#define VO_GAMMA_BASE                                               0xC000
+  
+
+#define VO_LAYER0_LINE0_BD_CTL                                      0x80
+#define VO_LAYER0_LINE1_BD_CTL                                      0x84
+#define VO_LAYER0_LINE2_BD_CTL                                      0x88
+#define VO_LAYER0_LINE3_BD_CTL                                      0x8C
+#define VO_LAYER1_BD_CTL                                            0x90
+#define VO_LAYER2_BD_CTL                                            0x94
+#define VO_LAYER3_BD_CTL                                            0x98
+#define VO_LAYER4_BD_CTL                                            0x9c
+#define VO_LAYER5_BD_CTL                                            0xa0
+#define VO_LAYER6_BD_CTL                                            0xa4
+
+//TIMING 
+#define VO_DISP_HSYNC_CTL                                           0x100
+#define VO_DISP_HSYNC1_CTL                                          0x104
+#define VO_DISP_VSYNC1_CTL                                          0x108
+#define VO_DISP_VSYNC2_CTL                                          0x110
+#define VO_DISP_HSYNC2_CTL                                          0x10c
+#define VO_DISP_TOTAL_SIZE                                          0x11C
+#define VO_DISP_XZONE_CTL                                           0x0C0
+#define VO_DISP_YZONE_CTL                                           0x0C4
+
+// OFFSET + ACTIVE
+#define VO_DISP_LAYER0_XCTL                                         0x0C8
+#define VO_DISP_LAYER0_YCTL                                         0x0CC
+#define VO_DISP_LAYER1_XCTL                                         0x0D0
+#define VO_DISP_LAYER1_YCTL                                         0x0D4
+#define VO_DISP_LAYER2_XCTL                                         0x0D8
+#define VO_DISP_LAYER2_YCTL                                         0x0DC
+#define VO_DISP_LAYER3_XCTL                                         0x0E0
+#define VO_DISP_LAYER3_YCTL                                         0x0E4
+#define VO_DISP_LAYER4_XCTL                                         0x0E8
+#define VO_DISP_LAYER4_YCTL                                         0x0EC
+#define VO_DISP_LAYER5_XCTL                                         0x0F0
+#define VO_DISP_LAYER5_YCTL                                         0x0F4
+#define VO_DISP_LAYER6_XCTL                                         0x0F8
+#define VO_DISP_LAYER6_YCTL                                         0x0FC
+
+// offset
+#define VO_LAYER0_IMG_IN_OFFSET                                     0x16C
+#define VO_LAYER1_IMG_IN_OFFSET                                     0x1D4
+#define VO_LAYER2_IMG_IN_OFFSET                                     0x214
+#define VO_LAYER3_IMG_IN_OFFSET                                     0x254
+
+// VO ACTIVE
+#define VO_DISP_OSD0_ACT_SIZE                                       0x284
+#define VO_DISP_OSD1_ACT_SIZE                                       0x2C4
+#define VO_DISP_OSD2_ACT_SIZE                                       0x304
+#define VO_DISP_LAYER0_IN_ACT_SIZE                                  0x15C
+#define VO_DISP_LAYER0_OUT_ACT_SIZE                                 0x160
+#define VO_DISP_LAYER1_ACT_SIZE                                     0x1E0
+#define VO_DISP_LAYER2_ACT_SIZE                                     0x220
+#define VO_DISP_LAYER3_ACT_SIZE                                     0x260
+
+//ADDR
+#define VO_DISP_LAYER0_Y_ADDR0                                    0x14C
+#define VO_DISP_LAYER0_Y_ADDR1                                    0x154
+#define VO_DISP_LAYER0_UV_ADDR0                                   0x150
+#define VO_DISP_LAYER0_UV_ADDR1                                   0x158
+
+#define VO_DISP_LAYER1_Y_ADDR0                                    0x1C4
+#define VO_DISP_LAYER1_Y_ADDR1                                    0x1CC
+#define VO_DISP_LAYER1_UV_ADDR0                                   0x1C8
+#define VO_DISP_LAYER1_UV_ADDR1                                   0x1D0
+
+#define VO_DISP_LAYER2_Y_ADDR0                                    0x204
+#define VO_DISP_LAYER2_Y_ADDR1                                    0x20c 
+#define VO_DISP_LAYER2_UV_ADDR0                                   0x208  
+#define VO_DISP_LAYER2_UV_ADDR1                                   0x210
+
+#define VO_DISP_LAYER3_Y_ADDR0                                    0x244
+#define VO_DISP_LAYER3_Y_ADDR1                                    0x24c
+#define VO_DISP_LAYER3_UV_ADDR0                                   0x248
+#define VO_DISP_LAYER3_UV_ADDR1                                   0x250
+
+#define VO_DISP_OSD0_VLU_ADDR0                                    0x288
+#define VO_DISP_OSD0_ALP_ADDR0                                    0x28C
+#define VO_DISP_OSD0_VLU_ADDR1                                    0x290
+#define VO_DISP_OSD0_ALP_ADDR1                                    0x294
+
+#define VO_DISP_OSD1_VLU_ADDR0                                    0x2C8
+#define VO_DISP_OSD1_ALP_ADDR0                                    0x2CC
+#define VO_DISP_OSD1_VLU_ADDR1                                    0x2D0
+#define VO_DISP_OSD1_ALP_ADDR1                                    0x2D4
+
+#define VO_DISP_OSD2_VLU_ADDR0                                    0x308
+#define VO_DISP_OSD2_ALP_ADDR0                                    0x30C
+#define VO_DISP_OSD2_VLU_ADDR1                                    0x310
+#define VO_DISP_OSD2_ALP_ADDR1                                    0x314
+
+//VO LAYER CRTL
+#define VO_LAYER0_CTL                                             0x140
+#define VO_LAYER0_IMG_IN_DAT_MODE                                 0x148            
+#define VO_LAYER1_CTL                                             0x1C0
+#define VO_LAYER2_CTL                                             0x200
+#define VO_LAYER3_CTL                                             0x240
+#define VO_DISP_ENABLE                                            0x118
+#define VO_DISP_CTL                                               0x114
+#define VO_DISP_OSD0_INFO                                         0x280
+#define VO_DISP_OSD1_INFO                                         0x2C0
+#define VO_DISP_OSD2_INFO                                         0x300
+
+//VO LAYER STRIDE
+#define VO_LAYER0_IMG_IN_STRIDE                                   0x164
+#define VO_LAYER1_IMG_IN_STRIDE                                   0x1DC
+#define VO_LAYER2_IMG_IN_STRIDE                                   0x21C
+#define VO_LAYER3_IMG_IN_STRIDE                                   0x25C
+#define VO_DISP_OSD0_STRIDE                                       0x29C
+#define VO_DISP_OSD1_STRIDE                                       0x2DC
+#define VO_DISP_OSD2_STRIDE                                       0x31C
+
+//dma burst length
+#define VO_LAYER0_SCALE_BLENTH                                    0x144
+#define VO_LAYER1_IMG_IN_BLENTH                                   0x1D8
+#define VO_LAYER2_IMG_IN_BLENTH                                   0x21C
+#define VO_LAYER3_IMG_IN_BLENTH                                   0x25C
+#define VO_DISP_OSD0_DMA_CTRL                                     0x298
+#define VO_DISP_OSD1_DMA_CTRL                                     0x2D8
+#define VO_DISP_OSD2_DMA_CTRL                                     0x318
+
+//VO PINPANG MODE SELSET
+#define VO_LAYER0_PINGPANG_SEL_MODE                               0x184
+#define VO_LAYER1_PINGPANG_SEL_MODE                               0x1E4
+#define VO_LAYER2_PINGPANG_SEL_MODE                               0x224
+#define VO_LAYER3_PINGPANG_SEL_MODE                               0x264
+#define VO_LAYER4_PINGPANG_SEL_MODE                               0x2A0
+#define VO_LAYER5_PINGPANG_SEL_MODE                               0x2E0
+#define VO_LAYER6_PINGPANG_SEL_MODE                               0x320
+
+#define VO_DISP_BACKGROUND                                        0x3D0
+#define ADDR_VO_DISP_MIX_LAYER_GLB_EN                             0x3c0
+#define ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA0                         0x3c4
+#define ADDR_VO_DISP_MIX_LAYER_GLB_ALPHA1                         0x3c8
+#define ADDR_VO_DISP_MIX_SEL                                      0x3cc
+          
+#define ADDR_VO_DISP_YUV2RGB_CTL                                  0x380
+#define ADDR_VO_DISP_CLUT_CTL                                     0x3d8
+#define ADDR_VO_DISP_DITH_CTL                                     0x3d4
+#define VO_OSD_RGB2YUV_CTL                                        0x340
+
+#define ADDR_VO_DISP_IRQ0_CTL                                     0x3e0
+#define ADDR_VO_DISP_IRQ1_CTL                                     0x3e4
+#define ADDR_VO_DISP_IRQ2_CTL                                     0x3e8
+#define ADDR_VO_DISP_IRQ_STATUS                                   0x3ec
+
+#define ADDR_VO_DISP_DRAW_FRAME                                   0x600
 #define ADDR_VO_DISP_DRAW_FRAME_CMD                               0x780
-
-#define KENDRYTE_VO_NUM_LAYERS		        7 
-
-
-enum VO_LAYER {
-    LAYER0 = 0x01,
-    LAYER1 = 0x02,
-    LAYER2 = 0x03,
-    LAYER3 = 0x04,
-    OSD0   = 0x05,
-    OSD1   = 0x06,
-    OSD2   = 0x07,
-    BACkGROUD = 0X08
-};
-
-enum _VO_VIDEOLAYER_YUV_MODE_E
-{
-    VO_VIDEO_LAYER_YUV_MODE_420              = 0x08,
-    VO_VIDEO_LAYER_YUV_MODE_422              = 0x09,
-
-} ;
-
-enum VO_VIDEOLAYER_Y_ENDIAN_E
-{
-    VO_VIDEO_LAYER_Y_ENDIAN_MODE0              = 0x0,//Y4 Y5 Y6 Y7 Y0 Y1 Y2 Y3
-    VO_VIDEO_LAYER_Y_ENDIAN_MODE1              = 0x1,//Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
-    VO_VIDEO_LAYER_Y_ENDIAN_MODE2              = 0x2,//Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
-    VO_VIDEO_LAYER_Y_ENDIAN_MODE3              = 0x3,//Y3 Y2 Y1 Y0 Y7 Y6 Y5 Y4
-} ;
-
-
-enum VO_VIDEOLAYER_UV_ENDIAN_E
-{
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE0              = 0x0,//U2 V2 U3 V3 U0 V0 U1 V1
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE1              = 0x1,//V2 U2 V3 U3 V0 U0 V1 U1
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE2              = 0x2,//U3 V3 U2 V2 U1 V1 U0 V0
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE3              = 0x3,//V3 U3 V2 U2 V1 U1 V0 U0  
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE4              = 0x4,//U0 V0 U1 V1 U2 V2 U3 V3  
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE5              = 0x5,//V0 U0 V1 U1 V2 U2 V3 U3 
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE6              = 0x6,//U1 V1 U0 V0 U3 V3 U2 V2
-    VO_VIDEO_LAYER_UV_ENDIAN_MODE7              = 0x7//V1 U1 V0 U0 V3 U3 V2 U2 
-
-};
-
-enum VO_LAYER_PINGPANG_MODE
-{
-    VO_LAYER_PINGPANG_AUTO = 0x01,
-    VO_LAYER_PING,
-    VO_LAYER_PANG,
-    VO_LAYER_PINGPANG,
-};
-
-enum VO_LAYER_FORMATS {
-
-	VO_FORMAT_YUV422 = 0X01,
-	VO_FORMAT_YUV420,
-
-	VO_FORMAT_ARGB1555,             //ARGB A 1BIT 
-    VO_FORMAT_RGB888,
-    VO_FORMAT_RGB565,
-	VO_FORMAT_RGBA5551,
-	VO_FORMAT_RGBA4444,	
-    
-	VO_FORMAT_UYVY,
-	VO_FORMAT_VYUY,
-	VO_FORMAT_XRGB8888,
-	VO_FORMAT_YUYV,
-	VO_FORMAT_YVYU,
-};
-
-enum vop_pending {
-	VOP_PENDING_FB_UNREF,
-};
-
-
-struct vo_act_size {
-    int  HA;
-    int  VA;
-};
-
-struct vo_offset_size {
-    int  h_offset;
-    int  v_offset;
-};
-
-struct vo_total_size {
-    int  HT;
-    int  VT;
-};
-    
-struct kendryte_vo_timing {
-
-    // hsa
-    int  hsa_start; 
-    int  hsa_end;
-    
-    int  zone_x_start;
-    int  zone_x_stop;
-
-
-    //vsa
-    int  vas_start;
-    int  vas_end;
-
-    int  zone_y_start;
-    int  zone_y_stop;
-
-    struct vo_total_size total_size;           //vo size
-    struct vo_act_size act_size;               // vo  sizeact,size
-
-};
-
-struct kendryte_layer {
-    struct drm_plane        plane;
-    enum drm_plane_type     type;
-    struct kendryte_drv     *drv;
-    int status;
-    int id;
-    int layer_id;
-	int area_id;
-	int zpos;
-	uint32_t offset;
-    uint16_t stride;
-    struct kendryte_layer_state state;
-    struct kendryte_vo      *vo;
-
-};
-
-
-
-typedef union { /* ctrl_fill_info_area_0_0 */
-
-    struct 
-    {
-        unsigned int line_end_pos_x                    : 13;
-        unsigned int line_draw_en                      : 1;
-        unsigned int v_line_r_en                       : 1;
-        unsigned int v_line_l_en                       : 1;
-        unsigned int line_start_pos_x                  : 13;
-        unsigned int h_line_b_en                       : 1;
-        unsigned int v_line_u_en                       : 1;
-        unsigned int reserved0                         : 1;
-    } bits;    
-    unsigned int u32; 
-} U_VO_REMAP_CTRL_FILL_INFO_AREA_0;
-
-typedef union { /* ctrl_fill_info_area_0_1 */
-
-    struct 
-    {
-        unsigned int line_end_pos_y                    : 13;
-        unsigned int line_width_l                      : 3;
-        unsigned int line_start_pos_y                  : 13;
-        unsigned int line_width_h                      : 3;
-    } bits;    
-    unsigned int u32; 
-} U_VO_REMAP_CTRL_FILL_INFO_AREA_1;
-
-typedef union { /* ctrl_fill_data_area_0_0 */
-
-    struct 
-    {
-        unsigned int fill_value_cr                     : 8;
-        unsigned int fill_value_cb                     : 8;
-        unsigned int fill_value_y                      : 8;
-        unsigned int fill_alpha                        : 8;
-    } bits;    
-    unsigned int u32; 
-} U_VO_REMAP_CTRL_FILL_DATA_AREA_0;
-
-
-struct vo_draw_frame {
-    uint32_t draw_en;
-    uint32_t line_x_start;
-    uint32_t line_y_start;
-
-    uint32_t line_x_end;
-    uint32_t line_y_end;
-
-    uint32_t frame_num;
-
-    uint32_t crtc_id;
-};
-
-#define DRM_KENDRYTE_DRAW_FRAME         0x00
-#define DRM_KENDRYTE_RESET              0x01
-
-#define DRM_IOCTL_KENDRYTE_DRAW_FRAME   DRM_IOWR(DRM_COMMAND_BASE + \
-                DRM_KENDRYTE_DRAW_FRAME, struct vo_draw_frame)
-#define DRM_IOCTL_KENDRYTE_RESET   DRM_IOWR(DRM_COMMAND_BASE + \
-                DRM_KENDRYTE_RESET, unsigned int)
-
-struct kendryte_vo {
-
-    struct drm_crtc                  crtc;
-    struct device                   *dev;
-    struct drm_device               *drm;
-    
-    // vo clk
-    struct clk                      *vo_apb;
-    struct clk                      *vo_axi;
-    // vo base addr
-    void __iomem  *base;
-
-    /* lock vop irq reg */
-	spinlock_t irq_lock;
-
-    /* protected by dev->event_lock */
-	struct drm_pending_vblank_event *event;
-
-    struct drm_flip_work fb_unref_work;
-
-	unsigned long pending;
-
-    /* Reset control */
-    struct reset_control *reset;
-
-    // interrupt irq id
-    int irq_vo;
-
-    /* Platform adjustments */
-    int     ch_num;     ;
-    unsigned int layer_size;
-
-    /* Associated crtc */
-    int                             id;
-    struct kendryte_vo_timing       *vo_timing;
-    
-    struct vo_act_size  act_size[KENDRYTE_VO_NUM_LAYERS];              //layer0 - layer6
-    struct vo_offset_size offset_size[KENDRYTE_VO_NUM_LAYERS];         //layer0 - layer6
-
-    struct kendryte_layer layer[];
-};
-
-
-static inline struct kendryte_vo *to_vop(struct drm_crtc *crtc)
-{
-    return container_of(crtc, struct kendryte_vo, crtc);
-}
-
-static inline struct kendryte_layer *to_vop_layer(struct drm_plane *plane)
-{
-    return container_of(plane, struct kendryte_layer, plane);
-}
-
-
-//#define to_vop(x) container_of(x, struct kendryte_vo, crtc)
-//#define to_vop_layer(x) container_of(x, struct kendryte_layer, plane)
-
-/*
-
-struct vo_hw_ctx {
-	void __iomem  *base;
-	struct regmap *noc_regmap;
-	struct clk *vo_core_clk;
-	struct clk *media_noc_clk;
-	struct clk *vo_pix_clk;
-	struct reset_control *reset;
-	bool power_on;
-	int irq;
-};
-
-*/
-
-void kendryte_vo_enable_vblank(struct kendryte_vo *vo, bool enable);
-void kendryte_vo_wrap_init(struct kendryte_vo *vo);
-void kendryte_vo_table_init(struct kendryte_vo *vo);
-void kendryte_vo_set_yuv_background(struct kendryte_vo *vo, uint16_t y, uint32_t u, uint32_t v);
-//void kendryte_vo_set_rgb_background(struct kendryte_vo *vo, uint16_t R, uint32_t G, uint32_t B);
-void kendryte_vo_software_reset(struct kendryte_vo *vo);
-void kendryte_vo_timing_init(struct kendryte_vo *vo, struct kendryte_vo_timing *vo_timing);
-void kendryte_set_layer_addr(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t y_addr0, uint32_t y_addr1, uint32_t uv_addr0, uint32_t uv_addr1);
-void kendryte_set_osd_addr(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t alpha_addr0, uint32_t alpha_addr1, uint32_t value0, uint32_t value1);
-void kendryte_set_layer_enable(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t status);
-//void kendryte_set_layer_act_size(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vact, uint32_t hact);
-//void kendryte_set_layer_offset_position(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vpos, uint32_t hpos);
-void kendryte_set_layer_y_endian(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_VIDEOLAYER_Y_ENDIAN_E ENDIAN);
-void kendryte_set_layer_uv_endian(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_VIDEOLAYER_UV_ENDIAN_E ENDIAN);
-void kendryte_vo_set_pingpang_mode(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_LAYER_PINGPANG_MODE);
-void kendryte_vo_set_layer_format(struct kendryte_vo *vo, enum VO_LAYER layer, enum VO_LAYER_FORMATS formats);
-void kendryte_vo_blenth_init(struct kendryte_vo *vo);
-void kendryte_display_crtl(struct kendryte_vo *vo, int status);
-void kendryte_vo_set_config_done(struct kendryte_vo *vo);
-void kendryte_vo_set_config_mix(struct kendryte_vo *vo);
-void kendryte_set_layer_postion(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vpos, uint32_t hpos, uint32_t v_offset, uint32_t h_offset, struct drm_display_mode *mode);
-void kendryte_vo_set_mode(struct kendryte_vo *vo, struct drm_display_mode *mode);
-void kendryte_set_layer_stride(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t stride);
-void kendryte_vo_get_reg_val(struct kendryte_vo *vop);
-void kendryte_vo_clear_intr(struct kendryte_vo *vop);
-void kendryte_vo_set_irq(struct kendryte_vo *vop, int status);
-void kendryte_layer_set_uv_swap(struct kendryte_vo *vo, enum VO_LAYER layer, int swap);
-void kendryte_layer_set_in_offset(struct kendryte_vo *vo, enum VO_LAYER layer, int offset);
-
-int kendryte_vo_draw_frame(struct kendryte_vo *vop, struct vo_draw_frame *frame);
-void kendryte_vo_set_osd_alpha_tpye(struct kendryte_vo *vop, enum VO_LAYER layer, int type);
-int kendryte_vo_osd_set_format(struct kendryte_vo *vo, enum VO_LAYER layer, int type);
-int kendryte_vo_osd_set_rgb2yuv_enable(struct kendryte_vo *vo, enum VO_LAYER layer);
-#endif
+
+#define KENDRYTE_VO_NUM_LAYERS		        7
+// clang-format on
+
+enum VO_LAYER {
+	LAYER0 = 0x01,
+	LAYER1 = 0x02,
+	LAYER2 = 0x03,
+	LAYER3 = 0x04,
+	OSD0 = 0x05,
+	OSD1 = 0x06,
+	OSD2 = 0x07,
+	BACkGROUD = 0X08
+};
+
+enum _VO_VIDEOLAYER_YUV_MODE_E {
+	VO_VIDEO_LAYER_YUV_MODE_420 = 0x08,
+	VO_VIDEO_LAYER_YUV_MODE_422 = 0x09,
+
+};
+
+enum VO_VIDEOLAYER_Y_ENDIAN_E {
+	VO_VIDEO_LAYER_Y_ENDIAN_MODE0 = 0x0, //Y4 Y5 Y6 Y7 Y0 Y1 Y2 Y3
+	VO_VIDEO_LAYER_Y_ENDIAN_MODE1 = 0x1, //Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
+	VO_VIDEO_LAYER_Y_ENDIAN_MODE2 = 0x2, //Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+	VO_VIDEO_LAYER_Y_ENDIAN_MODE3 = 0x3, //Y3 Y2 Y1 Y0 Y7 Y6 Y5 Y4
+};
+
+enum VO_VIDEOLAYER_UV_ENDIAN_E {
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE0 = 0x0, //U2 V2 U3 V3 U0 V0 U1 V1
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE1 = 0x1, //V2 U2 V3 U3 V0 U0 V1 U1
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE2 = 0x2, //U3 V3 U2 V2 U1 V1 U0 V0
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE3 = 0x3, //V3 U3 V2 U2 V1 U1 V0 U0
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE4 = 0x4, //U0 V0 U1 V1 U2 V2 U3 V3
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE5 = 0x5, //V0 U0 V1 U1 V2 U2 V3 U3
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE6 = 0x6, //U1 V1 U0 V0 U3 V3 U2 V2
+	VO_VIDEO_LAYER_UV_ENDIAN_MODE7 = 0x7 //V1 U1 V0 U0 V3 U3 V2 U2
+
+};
+
+enum VO_LAYER_PINGPANG_MODE {
+	VO_LAYER_PINGPANG_AUTO = 0x01,
+	VO_LAYER_PING,
+	VO_LAYER_PANG,
+	VO_LAYER_PINGPANG,
+};
+
+enum VO_LAYER_FORMATS {
+
+	VO_FORMAT_YUV422 = 0X01,
+	VO_FORMAT_YUV420,
+
+	VO_FORMAT_ARGB1555, //ARGB A 1BIT
+	VO_FORMAT_RGB888,
+	VO_FORMAT_RGB565,
+	VO_FORMAT_RGBA5551,
+	VO_FORMAT_RGBA4444,
+
+	VO_FORMAT_UYVY,
+	VO_FORMAT_VYUY,
+	VO_FORMAT_XRGB8888,
+	VO_FORMAT_YUYV,
+	VO_FORMAT_YVYU,
+};
+
+enum vop_pending {
+	VOP_PENDING_FB_UNREF,
+};
+
+struct vo_act_size {
+	int HA;
+	int VA;
+};
+
+struct vo_offset_size {
+	int h_offset;
+	int v_offset;
+};
+
+struct vo_total_size {
+	int HT;
+	int VT;
+};
+
+struct kendryte_vo_timing {
+	// hsa
+	int hsa_start;
+	int hsa_end;
+
+	int zone_x_start;
+	int zone_x_stop;
+
+	//vsa
+	int vas_start;
+	int vas_end;
+
+	int zone_y_start;
+	int zone_y_stop;
+
+	struct vo_total_size total_size; //vo size
+	struct vo_act_size
+		act_size; // vo  sizeact,size
+};
+
+struct kendryte_layer {
+	struct drm_plane plane;
+	enum drm_plane_type type;
+	struct kendryte_drv *drv;
+	int status;
+	int id;
+	int layer_id;
+	int area_id;
+	int zpos;
+	uint32_t offset;
+	uint16_t stride;
+	struct kendryte_layer_state state;
+	struct kendryte_vo *vo;
+};
+
+typedef union { /* ctrl_fill_info_area_0_0 */
+
+	struct {
+		unsigned int line_end_pos_x : 13;
+		unsigned int line_draw_en : 1;
+		unsigned int v_line_r_en : 1;
+		unsigned int v_line_l_en : 1;
+		unsigned int line_start_pos_x : 13;
+		unsigned int h_line_b_en : 1;
+		unsigned int v_line_u_en : 1;
+		unsigned int reserved0 : 1;
+	} bits;
+	unsigned int u32;
+} U_VO_REMAP_CTRL_FILL_INFO_AREA_0;
+
+typedef union { /* ctrl_fill_info_area_0_1 */
+
+	struct {
+		unsigned int line_end_pos_y : 13;
+		unsigned int line_width_l : 3;
+		unsigned int line_start_pos_y : 13;
+		unsigned int line_width_h : 3;
+	} bits;
+	unsigned int u32;
+} U_VO_REMAP_CTRL_FILL_INFO_AREA_1;
+
+typedef union { /* ctrl_fill_data_area_0_0 */
+
+	struct {
+		unsigned int fill_value_cr : 8;
+		unsigned int fill_value_cb : 8;
+		unsigned int fill_value_y : 8;
+		unsigned int fill_alpha : 8;
+	} bits;
+	unsigned int u32;
+} U_VO_REMAP_CTRL_FILL_DATA_AREA_0;
+
+struct vo_draw_frame {
+	uint32_t draw_en;
+	uint32_t line_x_start;
+	uint32_t line_y_start;
+
+	uint32_t line_x_end;
+	uint32_t line_y_end;
+
+	uint32_t frame_num;
+
+	uint32_t crtc_id;
+};
+
+#define DRM_KENDRYTE_DRAW_FRAME 0x00
+#define DRM_KENDRYTE_RESET 0x01
+
+#define DRM_IOCTL_KENDRYTE_DRAW_FRAME                                          \
+	DRM_IOWR(DRM_COMMAND_BASE + DRM_KENDRYTE_DRAW_FRAME,                   \
+		 struct vo_draw_frame)
+#define DRM_IOCTL_KENDRYTE_RESET                                               \
+	DRM_IOWR(DRM_COMMAND_BASE + DRM_KENDRYTE_RESET, unsigned int)
+
+struct kendryte_vo {
+	struct drm_crtc crtc;
+	struct device *dev;
+	struct drm_device *drm;
+
+	// vo clk
+	struct clk *vo_apb;
+	struct clk *vo_axi;
+	// vo base addr
+	void __iomem *base;
+
+	/* lock vop irq reg */
+	spinlock_t irq_lock;
+
+	/* protected by dev->event_lock */
+	struct drm_pending_vblank_event *event;
+
+	struct drm_flip_work fb_unref_work;
+
+	unsigned long pending;
+
+	/* Reset control */
+	struct reset_control *reset;
+
+	// interrupt irq id
+	int irq_vo;
+
+	/* Platform adjustments */
+	int ch_num;
+	;
+	unsigned int layer_size;
+
+	/* Associated crtc */
+	int id;
+	struct kendryte_vo_timing *vo_timing;
+
+	struct vo_act_size act_size[KENDRYTE_VO_NUM_LAYERS]; //layer0 - layer6
+	struct vo_offset_size
+		offset_size[KENDRYTE_VO_NUM_LAYERS]; //layer0 - layer6
+
+	struct kendryte_layer layer[];
+};
+
+static inline struct kendryte_vo *to_vop(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct kendryte_vo, crtc);
+}
+
+static inline struct kendryte_layer *to_vop_layer(struct drm_plane *plane)
+{
+	return container_of(plane, struct kendryte_layer, plane);
+}
+
+//#define to_vop(x) container_of(x, struct kendryte_vo, crtc)
+//#define to_vop_layer(x) container_of(x, struct kendryte_layer, plane)
+
+/*
+
+struct vo_hw_ctx {
+	void __iomem  *base;
+	struct regmap *noc_regmap;
+	struct clk *vo_core_clk;
+	struct clk *media_noc_clk;
+	struct clk *vo_pix_clk;
+	struct reset_control *reset;
+	bool power_on;
+	int irq;
+};
+
+*/
+
+void kendryte_vo_enable_vblank(struct kendryte_vo *vo, bool enable);
+void kendryte_vo_wrap_init(struct kendryte_vo *vo);
+void kendryte_vo_table_init(struct kendryte_vo *vo);
+void kendryte_vo_set_yuv_background(struct kendryte_vo *vo, uint16_t y,
+				    uint32_t u, uint32_t v);
+//void kendryte_vo_set_rgb_background(struct kendryte_vo *vo, uint16_t R, uint32_t G, uint32_t B);
+void kendryte_vo_software_reset(struct kendryte_vo *vo);
+void kendryte_vo_timing_init(struct kendryte_vo *vo,
+			     struct kendryte_vo_timing *vo_timing);
+void kendryte_set_layer_addr(struct kendryte_vo *vo, enum VO_LAYER layer,
+			     uint32_t y_addr0, uint32_t y_addr1,
+			     uint32_t uv_addr0, uint32_t uv_addr1);
+void kendryte_set_osd_addr(struct kendryte_vo *vo, enum VO_LAYER layer,
+			   uint32_t alpha_addr0, uint32_t alpha_addr1,
+			   uint32_t value0, uint32_t value1);
+void kendryte_set_layer_enable(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       uint32_t status);
+//void kendryte_set_layer_act_size(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vact, uint32_t hact);
+//void kendryte_set_layer_offset_position(struct kendryte_vo *vo, enum VO_LAYER layer, uint32_t vpos, uint32_t hpos);
+void kendryte_set_layer_y_endian(struct kendryte_vo *vo, enum VO_LAYER layer,
+				 enum VO_VIDEOLAYER_Y_ENDIAN_E ENDIAN);
+void kendryte_set_layer_uv_endian(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  enum VO_VIDEOLAYER_UV_ENDIAN_E ENDIAN);
+void kendryte_vo_set_pingpang_mode(struct kendryte_vo *vo, enum VO_LAYER layer,
+				   enum VO_LAYER_PINGPANG_MODE);
+void kendryte_vo_set_layer_format(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  enum VO_LAYER_FORMATS formats);
+void kendryte_vo_blenth_init(struct kendryte_vo *vo);
+void kendryte_display_crtl(struct kendryte_vo *vo, int status);
+void kendryte_vo_set_config_done(struct kendryte_vo *vo);
+void kendryte_vo_set_config_mix(struct kendryte_vo *vo);
+void kendryte_set_video_layer_postion(struct kendryte_vo *vo,
+				      enum VO_LAYER layer, struct drm_rect *src,
+				      struct drm_rect *dst,
+				      struct drm_display_mode *mode);
+void kendryte_set_layer_postion(struct kendryte_vo *vo, enum VO_LAYER layer,
+				uint32_t vpos, uint32_t hpos, uint32_t v_offset,
+				uint32_t h_offset,
+				struct drm_display_mode *mode);
+void kendryte_vo_set_mode(struct kendryte_vo *vo,
+			  struct drm_display_mode *mode);
+void kendryte_set_layer_stride(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       uint32_t stride);
+void kendryte_vo_get_reg_val(struct kendryte_vo *vop);
+void kendryte_vo_clear_intr(struct kendryte_vo *vop);
+void kendryte_vo_set_irq(struct kendryte_vo *vop, int status);
+void kendryte_layer_set_uv_swap(struct kendryte_vo *vo, enum VO_LAYER layer,
+				int swap);
+void kendryte_layer_set_in_offset(struct kendryte_vo *vo, enum VO_LAYER layer,
+				  int offset);
+
+int kendryte_vo_draw_frame(struct kendryte_vo *vop,
+			   struct vo_draw_frame *frame);
+void kendryte_vo_set_osd_alpha_tpye(struct kendryte_vo *vop,
+				    enum VO_LAYER layer, int type);
+int kendryte_vo_osd_set_format(struct kendryte_vo *vo, enum VO_LAYER layer,
+			       int type);
+int kendryte_vo_osd_set_rgb2yuv_enable(struct kendryte_vo *vo,
+				       enum VO_LAYER layer);
+#endif
-- 
2.17.1

